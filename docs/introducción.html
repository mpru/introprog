<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>1 Introducci<U+FFFD>n | Introducci<U+FFFD>n a la Programaci<U+FFFD>n</title>
<meta name="author" content="Mgs. Lic. Marcos Prunello (Prof.<U+FFFD>Tit. Ord.)">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.2"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/header-attrs-2.7/header-attrs.js"></script><script src="libs/jquery-3.5.1/jquery-3.5.1.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.2.4.9003/tabs.js"></script><script src="libs/bs3compat-0.2.4.9003/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="https://cdn.jsdelivr.net/autocomplete.js/0/autocomplete.jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/mark.min.js"></script><!-- CSS --><link rel="stylesheet" href="style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="Gu<U+FFFD>a de estudio - Lic. en Estad<U+FFFD>stica - FCEyE - UNR">Introducci<U+FFFD>n a la Programaci<U+FFFD>n</a>:
        <small class="text-muted">Gu<U+FFFD>a de estudio - Lic. en Estad<U+FFFD>stica - FCEyE - UNR</small>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Tabla de contenidos"><h2>Tabla de contenidos</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Bienvenida</a></li>
<li><a class="active" href="introducci%C3%B3n.html"><span class="header-section-number">1</span> Introducci<U+FFFD>n</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="introducci<U+FFFD>n" class="section level1" number="1">
<h1>
<span class="header-section-number">1</span> Introducci<U+FFFD>n<a class="anchor" aria-label="anchor" href="#introducci%C3%B3n"><i class="fas fa-link"></i></a>
</h1>
<div id="qu<U+FFFD>-es-la-programaci<U+FFFD>n" class="section level2" number="1.1">
<h2>
<span class="header-section-number">1.1</span> Qu<U+FFFD> es la programaci<U+FFFD>n<a class="anchor" aria-label="anchor" href="#qu%C3%A9-es-la-programaci%C3%B3n"><i class="fas fa-link"></i></a>
</h2>
<p>Las computadoras son una parte esencial de nuestra vida cotidiana. Casi todos los aparatos que usamos tienen alg<U+FFFD>n tipo de computadora capaz de ejecutar ciertas tareas: lavarropas con distintos modos de lavado, consolas de juegos para momentos de entretenimiento, calculadoras s<U+FFFD>per potentes, computadoras personales que se usan para un mont<U+FFFD>n de prop<U+FFFD>sitos, tel<U+FFFD>fonos celulares con un sinf<U+FFFD>n de aplicaciones y miles de cosas m<U+FFFD>s.</p>
<p>Todos estos dispositivos con computadoras de distinto tipo tienen algo en com<U+FFFD>n: alguien <U+FFFD>les dice<U+FFFD> c<U+FFFD>mo funcionar, es decir, les indica cu<U+FFFD>les son los pasos que deben seguir para cumplir una tarea. De eso se trata la <strong>programaci<U+FFFD>n</strong>: es la actividad mediante la cual las <em>personas</em> le entregan a una <em>computadora</em> un conjunto de instrucciones para que, al ejecutarlas, <U+FFFD>sta pueda <em>resolver un problema</em>. Quienes realizan esta actividad reciben el nombre de <strong>programadores</strong>. Sin las personas que las programen, las computadoras dejan de ser <U+FFFD>tiles, por m<U+FFFD>s complejos que sean estos aparatos. Los conjuntos de instrucciones que reciben las computadoras reciben el nombre de <strong>programas</strong>.</p>
<p>La programaci<U+FFFD>n es un proceso creativo: en muchas ocasiones la tarea en cuesti<U+FFFD>n puede cumplirse siguiendo distintos caminos y el programador es el que debe imaginar cu<U+FFFD>les son y elegir uno. Algunos de estos caminos pueden ser mejores que otros, pero en cualquier caso la computadora se limitar<U+FFFD> a seguir las instrucciones ideadas por el programador.</p>
<p>Desafortunadamente, las computadoras no entienden espa<U+FFFD>ol ni otro idioma humano. Hay que pasarles las instrucciones en un lenguaje que sean capaces de entender. Para eso debemos aprender alg<U+FFFD>n <strong>lenguaje de programaci<U+FFFD>n</strong>, que no es m<U+FFFD>s que un lenguaje artificial compuesto por una serie de expresiones que la computadora puede interpretar. Las computadoras interpretan nuestras instrucciones de forma muy literal, por lo tanto a la hora de programar hay que ser muy espec<U+FFFD>ficos. Es necesario respetar las reglas del lenguaje de programaci<U+FFFD>n y ser claros en las indicaciones provistas.</p>
<p>Ahora bien, <U+FFFD>por qu<U+FFFD> debemos estudiar programaci<U+FFFD>n en la Licenciatura en Estad<U+FFFD>stica? La actividad de los profesionales estad<U+FFFD>sticos est<U+FFFD> atravesada en su totalidad por la necesidad de manejar con soltura herramientas inform<U+FFFD>ticas que nos asisten en las distintas etapas de nuestra labor, desde la recolecci<U+FFFD>n y depuraci<U+FFFD>n de conjuntos de datos, pasando por la aplicaci<U+FFFD>n de distintas metodolog<U+FFFD>as de an<U+FFFD>lisis, hasta la comunicaci<U+FFFD>n efectiva de los resultados. Por eso, en la asignatura <strong>Introducci<U+FFFD>n a la Programaci<U+FFFD>n</strong> estudiaremos los conceptos b<U+FFFD>sicos de esta disciplina, fomentando la ejercitaci<U+FFFD>n del pensamiento abstracto y l<U+FFFD>gico necesario para poder entendernos h<U+FFFD>bilmente con la computadora y lograr que la misma realice las tareas que necesitamos.</p>
<p>Para poner en pr<U+FFFD>ctica los conceptos sobre Programaci<U+FFFD>n que aprenderemos, vamos a emplear un lenguaje que ha sido desarrollado espec<U+FFFD>ficamente para realizar tareas estad<U+FFFD>sticas, llamado <strong>R</strong>. Sin embargo, debemos resaltar que <U+FFFD>ste no es un curso sobre R, es decir, no nos dedicaremos a aprender las herramientas que este lenguaje brinda para el an<U+FFFD>lisis de datos. De hecho, frente a variados problemas vamos a dedicarnos a crear soluciones que ya existen y est<U+FFFD>n disponibles en R, pero lo haremos con el fin de utilizar dicho lenguaje para aprender y ejercitar nociones b<U+FFFD>sicas de programaci<U+FFFD>n.</p>
</div>
<div id="una-breve-rese<U+FFFD>a-hist<U+FFFD>rica-sobre-la-programaci<U+FFFD>n" class="section level2" number="1.2">
<h2>
<span class="header-section-number">1.2</span> Una breve rese<U+FFFD>a hist<U+FFFD>rica sobre la programaci<U+FFFD>n<a class="anchor" aria-label="anchor" href="#una-breve-rese%C3%B1a-hist%C3%B3rica-sobre-la-programaci%C3%B3n"><i class="fas fa-link"></i></a>
</h2>
<p>La historia de la programaci<U+FFFD>n est<U+FFFD> vinculada directamente con la de la computaci<U+FFFD>n. Esta palabra proviene del lat<U+FFFD>n <em>computatio</em>, que deriva del verbo <em>computare</em>, cuyo significado es <U+FFFD>enumerar cantidades<U+FFFD>. Computaci<U+FFFD>n, en este sentido, designa la acci<U+FFFD>n y efecto de computar, realizar una cuenta, un c<U+FFFD>lculo matem<U+FFFD>tico. De all<U+FFFD> que antiguamente computaci<U+FFFD>n fuese un t<U+FFFD>rmino usado para referirse a los c<U+FFFD>lculos realizados por una persona con un instrumento expresamente utilizado para tal fin (como el <U+FFFD>baco, por ejemplo) o sin <U+FFFD>l. En este sentido, la computaci<U+FFFD>n ha estado presente desde tiempos ancestrales, sin embargo debemos remontarnos al siglo XVII para encontrar los primeros dispositivos dise<U+FFFD>ados para automatizar c<U+FFFD>mputos matem<U+FFFD>ticos.</p>
<p>En 1617 el matem<U+FFFD>tico escoc<U+FFFD>s John Napier (el mismo que defini<U+FFFD> los logaritmos) invent<U+FFFD> un sistema conocido como <em>los huesos de Napier</em> o <em>huesos neperianos</em> que facilitaba la tarea de multiplicar, dividir y tomar ra<U+FFFD>ces cuadradas, usando unas barras de hueso o marfil que ten<U+FFFD>an d<U+FFFD>gitos grabados. Esta fue la base para otras ideas m<U+FFFD>s avanzadas, entre ellas la que dio origen a la primera calculadora mec<U+FFFD>nica, inventada por el alem<U+FFFD>n Wilhelm Schickard en 1623, capaz de realizar c<U+FFFD>mputos aritm<U+FFFD>ticos sencillos funcionando a base de ruedas y engranajes. Se compon<U+FFFD>a de dos mecanismos diferenciados, un <U+FFFD>baco de Napier de forma cil<U+FFFD>ndrica en la parte superior y un mecanismo en la inferior para realizar sumas parciales de los resultados obtenidos con el aparato de la parte superior. Fue llamado <em>reloj calculador</em>. A partir de aqu<U+FFFD> se fueron desarrollando otros modelos, todos ellos teniendo en com<U+FFFD>n el hecho de ser puramente mec<U+FFFD>nicos, sin motores ni otras fuentes de energ<U+FFFD>a. El operador ingresaba n<U+FFFD>meros ubicando ruedas de metal en posiciones particulares y al girarlas otras partes de la m<U+FFFD>quina se mov<U+FFFD>an y mostraban el resultado. Algunos ejemplos son las calculadoras del ingl<U+FFFD>s William Oughtred en 1624, de Blaise Pascal en 1645 (llamada <em>pascalina</em>), la de Samuel Morland en 1666 y las de Leibniz, en 1673 y 1694.</p>
<div class="figure" style="text-align: center">
<span id="fig:calculadora"></span>
<img src="images/historia/calculadoras.png" alt="De izquierda a derecha: los huesos de Napier (Museo Arqueol<U+FFFD>gico Nacional de Espa<U+FFFD>a), el reloj calculador de Schickard (Museo de la Ciencia de la Universidad P<U+FFFD>blica de Navarra) y una pascalina del a<U+FFFD>o 1952" width="100%"><p class="caption">
Figura 1.1: De izquierda a derecha: los huesos de Napier (Museo Arqueol<U+FFFD>gico Nacional de Espa<U+FFFD>a), el reloj calculador de Schickard (Museo de la Ciencia de la Universidad P<U+FFFD>blica de Navarra) y una pascalina del a<U+FFFD>o 1952
</p>
</div>
<p>El siglo XVIII trajo consigo algunos otros dise<U+FFFD>os, pero un gran salto se dio a comienzos del siglo XIX de mano de un tejedor y comerciante franc<U+FFFD>s, Joseph Jacquard. En 1801 cre<U+FFFD> un telar que ten<U+FFFD>a un sistema de tarjetas perforadas para controlar las puntadas del tejido, de forma que fuera posible <em>programar</em> una gran diversidad de tramas y figuras. Sin saberlo, Jacquard sent<U+FFFD> una idea fundamental para la creaci<U+FFFD>n de las computadoras.</p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-1"></span>
<img src="images/historia/telar.png" alt="Un telar de Jacquard y sus tarjetas perforadas en el Museo de la ciencia y la industria en M<U+FFFD>nchester." width="50%"><p class="caption">
Figura 1.2: Un telar de Jacquard y sus tarjetas perforadas en el Museo de la ciencia y la industria en M<U+FFFD>nchester.
</p>
</div>
<p>En 1822 el matem<U+FFFD>tico brit<U+FFFD>nico Charles Babbage public<U+FFFD> un dise<U+FFFD>o para la construcci<U+FFFD>n de una <em>m<U+FFFD>quina diferencial</em>, que pod<U+FFFD>a calcular valores de funciones polin<U+FFFD>micas mediante el m<U+FFFD>todo de las diferencias. Este complejo sistema de ruedas y engranajes era el primero que pod<U+FFFD>a trabajar autom<U+FFFD>ticamente utilizando resultados de operaciones previas. Si bien el dise<U+FFFD>o era viable, por motivos t<U+FFFD>cnicos y econ<U+FFFD>micos no lo pudo concretar (s<U+FFFD>lo construy<U+FFFD> un modelo de menor escala). Sin embargo, Babbage no se dio por vencido y en 1837 present<U+FFFD> el dise<U+FFFD>o de una <em>m<U+FFFD>quina anal<U+FFFD>tica</em>, un aparato capaz de ejecutar cualquier tipo de c<U+FFFD>lculo matem<U+FFFD>tico y que, por lo tanto, se podr<U+FFFD>a utilizar con cualquier prop<U+FFFD>sito. Tal como el telar de Jacquard, la operaci<U+FFFD>n de esta m<U+FFFD>quina ser<U+FFFD>a controlada por un patr<U+FFFD>n de perforaciones hechas sobre una tarjetas que la misma podr<U+FFFD>a leer. Al cambiar el patr<U+FFFD>n de las perforaciones, se podr<U+FFFD>a cambiar el comportamiento de la m<U+FFFD>quina para que resuelva diferentes tipos de c<U+FFFD>lculos. Para la salida de resultados, la m<U+FFFD>quina ser<U+FFFD>a capaz de perforar tarjetas. Adem<U+FFFD>s, funcionar<U+FFFD>a con un motor a vapor y su tama<U+FFFD>o hubiese sido de 30 metros de largo por 10 de ancho. Si bien Babbage tampoco lleg<U+FFFD> a concretar en vida este dise<U+FFFD>o que dej<U+FFFD> plasmado en m<U+FFFD>s de 300 dibujos y 2200 p<U+FFFD>ginas por motivos pol<U+FFFD>ticos, se lo considera como la primera conceptualizaci<U+FFFD>n de lo que hoy conocemos como computadora, por lo cual Babbage es conocido como <em>el padre de la computaci<U+FFFD>n</em>.</p>
<p>En 1843 Lady Ada Lovelace, una matem<U+FFFD>tica y escritora brit<U+FFFD>nica, public<U+FFFD> una serie de notas sobre la m<U+FFFD>quina anal<U+FFFD>tica de Babbage, en las que resaltaba sus potenciales aplicaciones pr<U+FFFD>cticas, incluyendo la descripci<U+FFFD>n detallada de tarjetas perforadas para que sea capaz de calcular los n<U+FFFD>meros de Bernoulli. Al haber se<U+FFFD>alado los pasos para que la m<U+FFFD>quina pueda cumplir con estas y otras tareas, Ada es considerada actualmente como la primera programadora del mundo, a pesar de que en la <U+FFFD>poca no fue tomada en serio por la comunidad cient<U+FFFD>fica, principalmente por su condici<U+FFFD>n de mujer.</p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-2"></span>
<img src="images/historia/babbage_ada.png" alt="Charles Babbage, Ada Lovelace y el algoritmo que public<U+FFFD> Ada para calcular los n<U+FFFD>meros de Bernoulli con la m<U+FFFD>quina anal<U+FFFD>stica de Charles." width="100%"><p class="caption">
Figura 1.3: Charles Babbage, Ada Lovelace y el algoritmo que public<U+FFFD> Ada para calcular los n<U+FFFD>meros de Bernoulli con la m<U+FFFD>quina anal<U+FFFD>stica de Charles.
</p>
</div>
<p>La utilidad de las tarjetas perforadas qued<U+FFFD> confirmada en 1890, cuando Herman Hollerith las utiliz<U+FFFD> para automatizar la tabulaci<U+FFFD>n de datos en el censo de Estados Unidos. Las perforaciones en determinados lugares representaban informaci<U+FFFD>n como el sexo o la edad de las personas, logrando que se pudieran lograr clasificaciones y conteos de forma muy veloz. As<U+FFFD>, se tardaron s<U+FFFD>lo 3 a<U+FFFD>os en procesar la informaci<U+FFFD>n del censo, cinco a<U+FFFD>os menos que en el anterior de 1880. Con el fin de comercializar esta tecnolog<U+FFFD>a, Hollerith fund<U+FFFD> una compa<U+FFFD><U+FFFD>a que terminar<U+FFFD>a siendo la famosa International Business Machine (IBM), empresa l<U+FFFD>der en inform<U+FFFD>tica hasta el d<U+FFFD>a de hoy.</p>
<p>Sin embargo, la visi<U+FFFD>n de Babbage de una computadora programable no se hizo realidad hasta los a<U+FFFD>os 1940, cuando el advenimiento de la electr<U+FFFD>nica hizo posible superar a los dispositivos mec<U+FFFD>nicos existentes. John Atanasoff y Clifford Barry (Iowa State College, Estados Unidos) terminaron en 1942 en Iowa State College (Estados Unidos) una computadora electr<U+FFFD>nica capaz de resolver sistemas de ecuaciones lineales simult<U+FFFD>neas, llamada <em>ABC</em> (por <U+FFFD>Atanasoff Berry Computer<U+FFFD>). La misma contaba con 300 tubos de vac<U+FFFD>os, unas bombillas de vidrio con ciertos componentes que pod<U+FFFD>an recibir y modificar una se<U+FFFD>al el<U+FFFD>ctrica mediante el control del movimiento de los electrones produciendo una respuesta, que hab<U+FFFD>an sido presentados por primera vez en 1906 por el estadounidense Lee De Forest. La <em>ABC</em> dio comienzo a la conocida como la <em>primera generaci<U+FFFD>n de computadoras</em> basadas en el empleo de tubos de vac<U+FFFD>o.</p>
<p>La primera computadora electr<U+FFFD>nica de prop<U+FFFD>sito general fue la <em>ENIAC</em>, <em>Electronic Numerical Integrator and Computer</em>, completada por Presper Eckert y John Mauchly en la Universidad de Pensilvania. Pod<U+FFFD>a realizar cinco mil operaciones aritm<U+FFFD>tica por segundo y ten<U+FFFD>a m<U+FFFD>s de 18000 tubos de vac<U+FFFD>o, ocupando una sala de 9x15 metros en un s<U+FFFD>tano de la universidad donde se mont<U+FFFD> un sistema de aire acondicionado especial.</p>
<p>Ni la <em>ABC</em> ni la <em>ENIAC</em> eran reprogramables: la <em>ABC</em> serv<U+FFFD>a el prop<U+FFFD>sito espec<U+FFFD>fico de resolver sistemas de ecuaciones y la <em>ENIAC</em> era controlada conectando ciertos cables en un panel, lo que hac<U+FFFD>a muy complejo su programaci<U+FFFD>n. El siguiente gran avance se produjo en 1945, cuando el matem<U+FFFD>tico h<U+FFFD>ngaro-estadounidense John von Neumann (Universidad de Princeton) propuso que los programas, es decir, las instrucciones para que la m<U+FFFD>quina opere, y tambi<U+FFFD>n los datos necesarios, podr<U+FFFD>an ser representados y guardados en una memoria electr<U+FFFD>nica interna. As<U+FFFD> naci<U+FFFD> el concepto de <em>programa almacenado</em> (o <em>stored-program</em>), en contraposici<U+FFFD>n con el uso de tableros de conexiones y mecanismos similares de los modelos vigentes. Los creadores de la ENIAC, bajo la consultor<U+FFFD>a de von Neumann, implementaron esto en el dise<U+FFFD>o de su sucesora, la <em>EDVAC</em>, terminada en 1949.
Tambi<U+FFFD>n ya hab<U+FFFD>a experimentado con esta idea en el continente veijo el alem<U+FFFD>n Konrad Zuse, quien entre 1937 y 1941 desarroll<U+FFFD> la <em>Z3</em>, por lo cual es considerada por algunos como la primera m<U+FFFD>quina completamente autom<U+FFFD>tica y programable. En lugar de usar tubos de vac<U+FFFD>os, empleaba un conjunto de 2600 rel<U+FFFD>s, unos dispositivos electromagn<U+FFFD>ticos inventados en 1835 y empleados, por ejemplo, en telegraf<U+FFFD>a.
<!-- Un rel<U+FFFD> funciona como un interruptor controlado por una bobina y un electroim<U+FFFD>n que integrado en un circuito el<U+FFFD>ctrico acciona uno o varios contactos, abriendo o cerrando otros circuitos el<U+FFFD>ctricos independientes.  -->
El modelo original de la Z3 fue destruido en Berl<U+FFFD>n por un bombardeo durante la segunda guerra mundial.</p>
<div class="figure" style="text-align: center">
<span id="fig:berry"></span>
<img src="images/historia/berry_eniac_z3.png" alt="De izquierda a derecha: las computadoras ABC, ENIAC y Z3" width="100%"><p class="caption">
Figura 1.4: De izquierda a derecha: las computadoras ABC, ENIAC y Z3
</p>
</div>
<p>Este nuevo paradigma cambi<U+FFFD> la historia de la computaci<U+FFFD>n, como tambi<U+FFFD>n lo hizo la invenci<U+FFFD>n del <em>transistor</em> en 1947 en los Laboratorios Bell. Un <em>transistor</em> es un dispositivo electr<U+FFFD>nico semiconductor que entrega una se<U+FFFD>al de salida en respuesta a una se<U+FFFD>al de entrada, mucho m<U+FFFD>s peque<U+FFFD>o que los tubos de vac<U+FFFD>o y que consumen menos energ<U+FFFD>a el<U+FFFD>ctrica. As<U+FFFD>, una computadora pod<U+FFFD>a tener cientos de miles de transistores, no obstante ocupando mucho espacio.</p>
<p>Desde entonces, la computaci<U+FFFD>n ha evolucionado muy r<U+FFFD>pidamente, con la introducci<U+FFFD>n de nuevos sistemas y conceptos, que llegan a los complejos y poderosos dise<U+FFFD>os electr<U+FFFD>nicos que caracterizan la vida actual. En un intento de caracterizar y resumir esta impactante evoluci<U+FFFD>n, algunos historiadores dividen al desarrollo de las computadoras modernas en <U+FFFD>generaciones<U+FFFD> (esta clasificaci<U+FFFD>n no es <U+FFFD>nica y existen diversas versiones de la misma):</p>
<ul>
<li>
<strong>Primera generaci<U+FFFD>n</strong> (aprox. 1940-1958): se trata de las computadoras electr<U+FFFD>nicas que usaban tubos de vac<U+FFFD>o para su circuito interno. Los equipos eran enormes y ocupan habitaciones enteras. Consum<U+FFFD>an mucha electricidad y generaban demasiado calor. Pod<U+FFFD>a llevar d<U+FFFD>as o semanas modificar las conexiones para hacer que la computadora resuelva un problema diferente. Usaban tarjetas perforadas y cinta de papel para la lectura de datos e impresiones para mostrar las salidas.</li>
<li>
<strong>Segunda generaci<U+FFFD>n</strong> (aprox. 1958-1964): se caracteriza por el uso de <em>transistores</em> (inventados en 1947) en lugar de tubos de vac<U+FFFD>o, permitiendo que las computadoras tengan un consumo el<U+FFFD>ctrico m<U+FFFD>s eficiente, sean m<U+FFFD>s baratas, m<U+FFFD>s peque<U+FFFD>as y m<U+FFFD>s r<U+FFFD>pidas.</li>
<li>
<strong>Tercera generaci<U+FFFD>n</strong> (aprox. 1964-1971): se inici<U+FFFD> en 1959 con el desarrollo de un circuito integrado (<U+FFFD>chip<U+FFFD>) que se trata de una peque<U+FFFD>a placa de silicio sobre el cual se imprime un gran n<U+FFFD>mero de transistores conectados. La primera computadora de este estilo fue de IBM en 1960. Al ser m<U+FFFD>s peque<U+FFFD>as y baratas, su uso lleg<U+FFFD> a una mayor audiencia. Se pudo interactuar con la m<U+FFFD>quina mediante teclados, monitores y un sistema operativo, que posibilitaba ejecutar m<U+FFFD>ltiples acciones a la vez bajo el monitoreo de un programa central.</li>
<li>
<strong>Cuarta generaci<U+FFFD>n</strong> (aprox. 1971-presente): los avances tecnol<U+FFFD>gicos permitieron construir la unidad entera de procesamiento de una computadora sobre un <U+FFFD>nico chip de silicio (<em>microprocesador</em>), incluyendo la memoria y los controles de entrada y salida de datos. Todo lo que en una computadora de la primera generaci<U+FFFD>n ocupaba una habitaci<U+FFFD>n entera, fue capaz de entrar en la palma de una mano. El primer microprocesador fue el Intel 4004 de 1971, mientras que la primera computadora de uso dom<U+FFFD>stico fue desarrollada por IBM en 1981. Surgieron tambi<U+FFFD>n en esta generaci<U+FFFD>n el rat<U+FFFD>n (<em>mouse</em>) y las interfaces gr<U+FFFD>ficas de usuario (como Windows, en 1985).</li>
</ul>
<div class="figure" style="text-align: center">
<span id="fig:evolucion"></span>
<img src="images/historia/05_tubovacio_transistor_chip.jpg" alt="De derecha a izquierda: un tubo de vac<U+FFFD>o, un transistor y un chip." width="50%"><p class="caption">
Figura 1.5: De derecha a izquierda: un tubo de vac<U+FFFD>o, un transistor y un chip.
</p>
</div>
</div>
<div id="software-y-hardware" class="section level2" number="1.3">
<h2>
<span class="header-section-number">1.3</span> Software y hardware<a class="anchor" aria-label="anchor" href="#software-y-hardware"><i class="fas fa-link"></i></a>
</h2>
<p>Como podemos ver, en la historia de la computaci<U+FFFD>n hubo dos aspectos que fueron evolucionando: las m<U+FFFD>quinas y los programas que las dirigen. Hacemos referencia a estos elementos como <strong>hardware</strong> y <strong>software</strong> respectivamente, y es la conjunci<U+FFFD>n de ambos la que le da vida a la computaci<U+FFFD>n y hace posible la programaci<U+FFFD>n.</p>
<div class="figure" style="text-align: center">
<span id="fig:hardvssoft"></span>
<img src="images/intro/06_hardsoft.jpg" alt="Representaci<U+FFFD>n de la diferencia entre hardware y software." width="50%"><p class="caption">
Figura 1.6: Representaci<U+FFFD>n de la diferencia entre hardware y software.
</p>
</div>
<p>El <strong>hardware</strong> es el conjunto de piezas f<U+FFFD>sicas y tangibles de la computadora. Existen diversas formas de clasificar a los elementos que componene al hardware, seg<U+FFFD>n distintos criterios:</p>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#9ABAD9;border-spacing:0;}
.tg td{background-color:#EBF5FF;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#444;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#409cff;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#fff;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-9wq8{border-color:inherit;text-align:center;vertical-align:middle}
.tg .tg-nrix{text-align:center;vertical-align:middle}
</style>
<div class="inline-table"><table class="tg">
<thead><tr>
<th class="tg-9wq8">
Critero
</th>
<th class="tg-9wq8">
Clasificaci<U+FFFD>n
</th>
<th class="tg-9wq8">
Descripci<U+FFFD>n
</th>
<th class="tg-nrix">
Ejemplos
</th>
</tr></thead>
<tbody>
<tr>
<td class="tg-9wq8" rowspan="4">
Seg<U+FFFD>n su utilidad
</td>
<td class="tg-9wq8">
Dispositivos de procesamiento
</td>
<td class="tg-9wq8">
Son los que reciben las instrucciones mediante se<U+FFFD>ales el<U+FFFD>ctricas y usan c<U+FFFD>lculos y l<U+FFFD>gica para interpretarlas y emitir otras se<U+FFFD>ales el<U+FFFD>ctricas como resultado.
</td>
<td class="tg-nrix">
microprocesador, tarjeta gr<U+FFFD>fica, tarjeta de sonido, etc.
</td>
</tr>
<tr>
<td class="tg-nrix">
Dispositivos de almacenamiento
</td>
<td class="tg-nrix">
Son capaces de guardar informaci<U+FFFD>n para que est<U+FFFD> disponible para el sistema.
</td>
<td class="tg-nrix">
<span style="font-weight:400;font-style:normal">disco duro, pen drive, DVD, etc.</span>
</td>
</tr>
<tr>
<td class="tg-nrix">
Dispositivos de entrada
</td>
<td class="tg-nrix">
Captan instrucciones por parte de los usuarios y las transforman en se<U+FFFD>ales el<U+FFFD>ctricas interpretables por la m<U+FFFD>quina.
</td>
<td class="tg-nrix">
teclado, mouse, touch pad, etc.
</td>
</tr>
<tr>
<td class="tg-nrix">
Dispositivos de salida
</td>
<td class="tg-nrix">
Transforman los resultados de los dispositivos de procesamiento para presentarlos de una forma f<U+FFFD>cilmente interpretable para el usuario.
</td>
<td class="tg-nrix">
monitor, impresora, etc
</td>
</tr>
<tr>
<td class="tg-nrix" rowspan="2">
Seg<U+FFFD>n su ubicaci<U+FFFD>n
</td>
<td class="tg-nrix">
Dispositivos internos
</td>
<td class="tg-nrix">
Generalmente se incluye dentro de la carcasa de la computadora.
</td>
<td class="tg-nrix">
microprocesador, disco r<U+FFFD>gido, ventiladores, m<U+FFFD>dem, tarjeta gr<U+FFFD>fica, fuente de alimentaci<U+FFFD>n, puertos, etc.
</td>
</tr>
<tr>
<td class="tg-nrix">
Dispositivos externos o perif<U+FFFD>ricos
</td>
<td class="tg-nrix">
No se incluye dentro de la carcasa de la computadora y est<U+FFFD> al alcance del usuario
</td>
<td class="tg-nrix">
monitor, teclado, mouse, joystick, micr<U+FFFD>fono, impresora, esc<U+FFFD>ner, pen drive, lectores de c<U+FFFD>digo de barras, etc.
</td>
</tr>
<tr>
<td class="tg-nrix" rowspan="2">
Seg<U+FFFD>n su importancia
</td>
<td class="tg-nrix">
Hardware principal
</td>
<td class="tg-nrix">
Dispositvos esenciales para el funcionamiento de la computadora
</td>
<td class="tg-nrix">
microprocesador, disco r<U+FFFD>gido, memoria RAM, fuente de alimentaci<U+FFFD>n, monitor, etc.
</td>
</tr>
<tr>
<td class="tg-nrix">
Hardware complementario
</td>
<td class="tg-nrix">
Aquellos elementos no indispensables (claramente, dependiendo del contexto, alguna pieza del hardware que en alguna situaci<U+FFFD>n podr<U+FFFD>a considerarse complementaria, en otras resulta principal).
</td>
<td class="tg-nrix">
</td>
</tr>
</tbody>
</table></div>
<!-- 
\begin{table}[H]
%\begin{tabular}{@{}cccc@{}}
\begin{tabular}{ p{3.5cm} p{2.5cm} p{6cm}p{4cm}}
\toprule
Critero                               & Clasificaci<U+FFFD>n                       & Descripci<U+FFFD>n                                                                                                                                                                                    & Ejemplos                                                                                                        \\ \midrule
\multirow{4}{*}{Seg<U+FFFD>n su utilidad}    & Dispositivos de procesamiento       & Son los que reciben las instrucciones mediante se<U+FFFD>ales el<U+FFFD>ctricas y usan c<U+FFFD>lculos y l<U+FFFD>gica para interpretarlas y emitir otras se<U+FFFD>ales el<U+FFFD>ctricas como resultado.                               & microprocesador, tarjeta gr<U+FFFD>fica, tarjeta de sonido, etc.                                                       \\ \cmidrule(l){2-4} 
                                      & Dispositivos de almacenamiento      & Son capaces de guardar informaci<U+FFFD>n para que est<U+FFFD> disponible para el sistema.                                                                                                                   & disco duro, pen drive, DVD, etc.                                                                                \\ \cmidrule(l){2-4} 
                                      & Dispositivos de entrada             & Captan instrucciones por parte de los usuarios y las transforman en se<U+FFFD>ales el<U+FFFD>ctricas interpretables por la m<U+FFFD>quina.                                                                          & teclado, mouse, touch pad, etc.                                                                                 \\ \cmidrule(l){2-4} 
                                      & Dispositivos de salida              & Transforman los resultados de los dispositivos de procesamiento para presentarlos de una forma f<U+FFFD>cilmente interpretable para el usuario.                                                       & monitor, impresora, etc                                                                                         \\ \midrule
\multirow{2}{*}{Seg<U+FFFD>n su ubicaci<U+FFFD>n}   & Dispositivos internos               & Generalmente se incluye dentro de la carcasa de la computadora.                                                                                                                                & microprocesador, disco r<U+FFFD>gido, ventiladores, m<U+FFFD>dem, tarjeta gr<U+FFFD>fica, fuente de alimentaci<U+FFFD>n, puertos, etc.      \\ \cmidrule(l){2-4} 
                                      & Dispositivos externos o perif<U+FFFD>ricos & No se incluye dentro de la carcasa de la computadora y est<U+FFFD> al alcance del usuario                                                                                                             & monitor, teclado, mouse, joystick, micr<U+FFFD>fono, impresora, esc<U+FFFD>ner, pen drive, lectores de c<U+FFFD>digo de barras, etc. \\ \midrule
\multirow{2}{*}{Seg<U+FFFD>n su importancia} & Hardware principal                  & Dispositvos esenciales para el funcionamiento de la computadora                                                                                                                                & microprocesador, disco r<U+FFFD>gido, memoria RAM, fuente de alimentaci<U+FFFD>n, monitor, etc.                               \\ \cmidrule(l){2-4} 
                                      & Hardware complementario             & Aquellos elementos no indispensables (claramente, dependiendo del contexto, alguna pieza del hardware que en alguna situaci<U+FFFD>n podr<U+FFFD>a considerarse complementaria, en otras resulta principal). &                                                                                                                 \\ \bottomrule
\end{tabular}
\end{table}
--><p>Por otro lado tenemos al <strong>software</strong>, que es el conjunto de todos los programas (es decir, todas las instrucciones que recibe la computadora) que permiten que el hardware funcione y que se pueda concretar la ejecuci<U+FFFD>n de las tareas. No tiene una existencia f<U+FFFD>sica, sino que es intangible. El software se puede clasificar de la siguiente forma:</p>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#9ABAD9;border-spacing:0;}
.tg td{background-color:#EBF5FF;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#444;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#409cff;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#fff;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
</style>
<div class="inline-table"><table class="tg">
<thead><tr>
<th class="tg-c3ow">
Clasificaci<U+FFFD>n
</th>
<th class="tg-c3ow">
Descripci<U+FFFD>n
</th>
<th class="tg-c3ow">
Ejemplos
</th>
</tr></thead>
<tbody>
<tr>
<td class="tg-c3ow">
Software de sistema o software base
</td>
<td class="tg-c3ow">
Son los programas inform<U+FFFD>ticos que est<U+FFFD>n escritos en lenguaje de bajo nivel como el de m<U+FFFD>quina o ensamblador y cuyas instrucciones controlan de forma directa el hardware
</td>
<td class="tg-c3ow">
BIOS o UEFIs (sistemas que se encarga de operaciones b<U+FFFD>sicas como el arranque del sistema, la configuraci<U+FFFD>n del hardware, etc), sistemas operativos (Linux, Windows, iOS, Android), controladores o <em>drivers</em>, etc.
</td>
</tr>
<tr>
<td class="tg-c3ow">
Software de aplicaci<U+FFFD>n o utilitario
</td>
<td class="tg-c3ow">
Son los programas o aplicaciones que usamos habitualmente para realizar alguna tarea espec<U+FFFD>fica.
</td>
<td class="tg-c3ow">
procesadores de texto como Word, reproductor de m<U+FFFD>sica, Whatsapp, Guaran<U+FFFD>, navegadores web, juegos, etc.
</td>
</tr>
<tr>
<td class="tg-c3ow">
Software de programaci<U+FFFD>n o de desarrollo
</td>
<td class="tg-c3ow">
Son los programas y entornos que nos permiten desarrollar nuestras propias herramientas de software o nuevos programas. Aqu<U+FFFD> se incluyen los lenguajes de programaci<U+FFFD>n
</td>
<td class="tg-c3ow">
C++, Java, Python, R, etc.
</td>
</tr>
</tbody>
</table></div>
<!--
\begin{table}[H]
\begin{tabular}{ p{4cm} p{6cm} p{6cm}}
\toprule
Clasificaci<U+FFFD>n                            & Descripci<U+FFFD>n                                                                                                                                                               & Ejemplos                                                                                                                                                                                                            \\ \midrule
Software de sistema o software base      & Son los programas inform<U+FFFD>ticos que est<U+FFFD>n escritos en lenguaje de bajo nivel como el de m<U+FFFD>quina o ensamblador y cuyas instrucciones controlan de forma directa el hardware & BIOS o UEFIs (sistemas que se encarga de operaciones b<U+FFFD>sicas como el arranque del sistema, la configuraci<U+FFFD>n del hardware, etc), sistemas operativos (Linux, Windows, iOS, Android), controladores o *drivers*, etc. \\ \midrule
Software de aplicaci<U+FFFD>n o utilitario      & Son los programas o aplicaciones que usamos habitualmente para realizar alguna tarea espec<U+FFFD>fica.                                                                          & procesadores de texto como Word, reproductor de m<U+FFFD>sica, Whatsapp, Guaran<U+FFFD>, navegadores web, juegos, etc.                                                                                                            \\ \midrule
Software de programaci<U+FFFD>n o de desarrollo & Son los programas y entornos que nos permiten desarrollar nuestras propias herramientas de software o nuevos programas. Aqu<U+FFFD> se incluyen los lenguajes de programaci<U+FFFD>n    & C++, Java, Python, R, etc.                                                                                                                                                                                          \\ \bottomrule
\end{tabular}
\end{table}
--><!-- https://www.xataka.com/basics/uefi-y-bios-cuales-son-las-diferencias -->
</div>
<div id="problemas-algoritmos-y-lenguajes-de-programaci<U+FFFD>n" class="section level2" number="1.4">
<h2>
<span class="header-section-number">1.4</span> Problemas, algoritmos y lenguajes de programaci<U+FFFD>n<a class="anchor" aria-label="anchor" href="#problemas-algoritmos-y-lenguajes-de-programaci%C3%B3n"><i class="fas fa-link"></i></a>
</h2>
<p>Mencionamos anteriormente que la <strong>programaci<U+FFFD>n</strong> consist<U+FFFD>a en instruir a una computadora para que resuelva un problema y que la comunicaci<U+FFFD>n de esas instrucciones debe ser realizada de forma clara. Es por eso que, ante un problema que debe ser resuelto computacionalmente, el primer paso es pensar detalladamente cu<U+FFFD>l puede ser una forma de resolverlo, es decir, crear un <strong>algoritmo</strong>. Un <strong>algoritmo</strong> es una estrategia consistente de un conjunto ordenado de pasos que nos lleva a la soluci<U+FFFD>n de un problema o alcance de un objetivo. Luego, hay que traducir el algoritmo elegido al idioma de la computadora.</p>
<p>Entonces, podemos decir que la resoluci<U+FFFD>n computacional de un problema consiste de dos etapas b<U+FFFD>sicas:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Dise<U+FFFD>o algor<U+FFFD>tmico</strong>: desarrollar un algoritmo, o elegir uno existente, que resuelva el problema.</li>
<li>
<strong>Codificaci<U+FFFD>n</strong>: expresar un algoritmo en un lenguaje de programaci<U+FFFD>n para que la computadora lo pueda interpretar y ejecutar.</li>
</ol>
<p>Al aprender sobre programaci<U+FFFD>n, comenzamos enfrent<U+FFFD>ndonos a problemas simples para los cuales la primera etapa parece sencilla, mientras que la codificaci<U+FFFD>n se torna dificultosa ya que hay que aprender las reglas del lenguaje de programaci<U+FFFD>n. Sin embargo, mientras que con pr<U+FFFD>ctica r<U+FFFD>pidamente podemos ganar facilidad para la escritura de c<U+FFFD>digo, el dise<U+FFFD>o algor<U+FFFD>tmico se torna cada vez m<U+FFFD>s desafiante al encarar problemas m<U+FFFD>s complejos. Es por eso que haremos hincapi<U+FFFD> en el planteo y desarrollo de algoritmos como una etapa fundamental en la programaci<U+FFFD>n.</p>
<div id="el-dise<U+FFFD>o-algor<U+FFFD>tmico" class="section level3" number="1.4.1">
<h3>
<span class="header-section-number">1.4.1</span> El dise<U+FFFD>o algor<U+FFFD>tmico<a class="anchor" aria-label="anchor" href="#el-dise%C3%B1o-algor%C3%ADtmico"><i class="fas fa-link"></i></a>
</h3>
<p>Cotidianamente, hacemos uso de algoritmos para llevar adelante casi todas las actividades que realizamos: preparar el desayuno, sacar a pasear la mascota, poner en la tele un servicio de <em>streaming</em> para ver una pel<U+FFFD>cula, etc. Cada una de estas tareas requiere llevar adelante algunas acciones de forma ordenada, aunque no hagamos un listado de las mismas y procedamos casi sin pensar.</p>
<p>Sin embargo, cuando estamos pensando la soluci<U+FFFD>n para un problema que va a resolver una computadora, debemos ser claros y concretos, para asegurarnos de que al seguir los pasos del algoritmo se llegue a la soluci<U+FFFD>n y para que quien tenga que codificarlos, nosotros mismos u otras personas, lo pueda entender sin problemas. Por eso, el primer paso es idear un algoritmo para su soluci<U+FFFD>n y expresarlo por escrito, por ejemplo, en espa<U+FFFD>ol, pero adaptando el lenguaje humano a formas l<U+FFFD>gicas que se acerquen a las tareas que puede realizar una computadora. En programaci<U+FFFD>n, el lenguaje artificial e informal que usan los desarrolladores en la confecci<U+FFFD>n de algoritmos recibe el nombre de <strong>pseudoc<U+FFFD>digo</strong>. Es la herramienta que utilizamos para describir los algoritmos mezclando el lenguaje com<U+FFFD>n con instrucciones de programaci<U+FFFD>n. No es en s<U+FFFD> mismo un lenguaje de programaci<U+FFFD>n, es decir, la computadora no es capaz de entenderlo, sino que el objetivo del mismo es que el programador se centre en la soluci<U+FFFD>n l<U+FFFD>gica y luego lo utilice como gu<U+FFFD>a al escribir el programa.</p>
<p>El pseudoc<U+FFFD>digo, como cualquier otro lenguaje, est<U+FFFD> compuesto por:</p>
<ul>
<li>Un <strong>l<U+FFFD>xico</strong>: conjunto de palabras o frases v<U+FFFD>lidas para escribir las instrucciones.</li>
<li>Una <strong>sintaxis</strong>: reglas que establecen c<U+FFFD>mo se pueden combinar las distintas partes.</li>
<li>Una <strong>sem<U+FFFD>ntica</strong>: significado que se les da a las palabras o frases.</li>
</ul>
<p>El pseudoc<U+FFFD>digo sigue una <strong>estructura secuencial</strong>: define una acci<U+FFFD>n o instrucci<U+FFFD>n que sigue a otra en secuencia. Esta estructura puede representarse de la siguiente forma:</p>
<pre class="text"><code>ALGORITMO: "Ejemplo"
COMENZAR
    Acci<U+FFFD>n 1
    Acci<U+FFFD>n 2
    ...
    Acci<U+FFFD>n N
FIN</code></pre>
<p>Se comienza con un t<U+FFFD>tulo que describa el problema que el algoritmo resuelve, seguido por la palabra <code>COMENZAR</code>. Luego se detallan las acciones o instrucciones a seguir y se concluye con la palabra <code>FIN</code>. Por ejemplo, si nuestro problema es poner en marcha un auto, el algoritmo para resolverlo puede ser expresado mediante el siguiente pseudoc<U+FFFD>digo:</p>
<pre class="text"><code>ALGORITMO: "Arrancar el auto"
COMENZAR
    INSERTAR la llave de contacto
    UBICAR el cambio en punto muerto
    GIRAR la llave hasta la posici<U+FFFD>n de arranque
    SI el motor arranca 
        ENTONCES
            DEJAR la llave en posici<U+FFFD>n "encendido"
        SI NO
            LLAMAR al mec<U+FFFD>nico
    FINSI
FIN</code></pre>
<p>Es importante destacar la presencia de sangr<U+FFFD>as (<em>sangrado</em>) en el ejemplo anterior, que facilitan la lectura.</p>
<p>Los algoritmos suelen ser representados tambi<U+FFFD>n mediante <strong>diagramas de flujo</strong>, como el que se muestra en la siguiente figura<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;En este curso no emplearemos diagramas de flujo&lt;/p&gt;"><sup>1</sup></a>.</p>
<div class="figure" style="text-align: center">
<span id="fig:algoritmo"></span>
<img src="images/intro/flujo.png" alt='Ejemplo del algoritmo "Arrancar el auto" representado gr<U+FFFD>ficamente con un diagrama de flujo.' width="70%"><p class="caption">
Figura 1.7: Ejemplo del algoritmo <U+FFFD>Arrancar el auto<U+FFFD> representado gr<U+FFFD>ficamente con un diagrama de flujo.
</p>
</div>
</div>
<div id="codificaci<U+FFFD>n" class="section level3" number="1.4.2">
<h3>
<span class="header-section-number">1.4.2</span> Codificaci<U+FFFD>n<a class="anchor" aria-label="anchor" href="#codificaci%C3%B3n"><i class="fas fa-link"></i></a>
</h3>
<p>El algoritmo anterior est<U+FFFD> presentado en pseudoc<U+FFFD>digo utilizando el lenguaje espa<U+FFFD>ol, una opci<U+FFFD>n razonable para compartir esta estrategia entre personas que se comuniquen con este idioma. Claramente, si queremos presentarle nuestro algoritmo a alguien que s<U+FFFD>lo habla franc<U+FFFD>s, el espa<U+FFFD>ol ya no ser<U+FFFD>a una buena elecci<U+FFFD>n, y mucho menos si queremos presentarle el algoritmo a una computadora. Para que una computadora pueda entender nuestro algoritmo, debemos traducirlo en un <strong>lenguaje de programaci<U+FFFD>n</strong>, que, como dijimos antes, es un idioma artificial dise<U+FFFD>ado para expresar c<U+FFFD>mputos que puedan ser llevados a cabo por equipos electr<U+FFFD>nicos, es decir es un medio de comunicaci<U+FFFD>n entre el humano y la m<U+FFFD>quina.</p>
<p>Si bien hay distintos lenguajes de programaci<U+FFFD>n, una computadora en definitiva es un aparato que s<U+FFFD>lo sabe <em>hablar</em> en <strong>binario</strong>, es decir, s<U+FFFD>lo interpreta se<U+FFFD>ales el<U+FFFD>ctricas con dos estados posibles, los cuales son representados por los d<U+FFFD>gitos binarios 0 y 1. Toda instrucci<U+FFFD>n que recibe la computadora se construye mediante una adecuada y larga combinaci<U+FFFD>n de ceros y unos<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;Como vimos anteriormente, las computadoras de la primera generaci<U+FFFD>n no se manejaban con lenguajes de programaci<U+FFFD>n, sino que para introducir informaci<U+FFFD>n e instrucciones en las primeras computadoras se usaban tarjetas perforadas, en las cuales los orificios representaban un <U+FFFD>0<U+FFFD> y las posiciones que no los ten<U+FFFD>an se entend<U+FFFD>an como un <U+FFFD>1<U+FFFD>, de modo que la m<U+FFFD>quina pod<U+FFFD>a operar empleando el sistema binario.&lt;/p&gt;"><sup>2</sup></a>. Este sistema de c<U+FFFD>digo con ceros y unos que la computadora interpreta como instrucciones o conjuntos de datos se llama <strong>lenguaje de m<U+FFFD>quina</strong> (o c<U+FFFD>digo de m<U+FFFD>quina).</p>
<p>Programar en lenguaje de m<U+FFFD>quina es muy complejo y lento, y es f<U+FFFD>cil cometer errores pero es dif<U+FFFD>cil arreglarlos. Por eso a principios de la d<U+FFFD>cada de 1950 se inventaron los <strong>lenguaje ensambladores</strong>, que usan palabras para representar simb<U+FFFD>licamente las operaciones que debe realizar la computadora. Cada una de estas palabras reemplaza un c<U+FFFD>digo de m<U+FFFD>quina binario, siendo un poco m<U+FFFD>s f<U+FFFD>cil programar. Imaginemos que deseamos crear un programa que permita sumar dos n<U+FFFD>meros elegidos por una persona. La computadora puede hacer esto si se lo comunicamos mediante un mensaje compuesto por una larga cadena de ceros y unos (lenguaje de m<U+FFFD>quina) que a simple vista no podr<U+FFFD>amos entender. Sin embargo, escrito en lenguaje de m<U+FFFD>quina, el programa se ver<U+FFFD>a as<U+FFFD> (por ejemplo):</p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-5"></span>
<img src="images/intro/ensamblador.png" alt="Programa en lenguaje ensamblador para leer dos n<U+FFFD>meros, sumarlos y mostrar el resultado. Al final de cada l<U+FFFD>nea hay una descripci<U+FFFD>n de la operaci<U+FFFD>n realizada." width="100%"><p class="caption">
Figura 1.8: Programa en lenguaje ensamblador para leer dos n<U+FFFD>meros, sumarlos y mostrar el resultado. Al final de cada l<U+FFFD>nea hay una descripci<U+FFFD>n de la operaci<U+FFFD>n realizada.
</p>
</div>
<p>El programa que se encarga de traducir esto al c<U+FFFD>digo de m<U+FFFD>quina se llama <strong>ensamblador</strong>. A pesar de que no haya ceros y unos como en el lenguaje de m<U+FFFD>quina, probablemente el c<U+FFFD>digo anterior tampoco sea f<U+FFFD>cil de entender. Aparecen instrucciones que tal vez podemos interpretar, como <em>add</em> por sumar o <em>sub</em> por substraer, pero est<U+FFFD> lleno de c<U+FFFD>lculos hexadecimales, referencias a posiciones en la memoria de la computadora y movimientos de valores que no lo hacen muy amigable. Por eso, a pesar de que la existencia de los lenguajes ensambladores simplific<U+FFFD> mucho la comunicaci<U+FFFD>n con la computadora, se hizo necesario desarrollar lenguajes que sean a<U+FFFD>n m<U+FFFD>s sencillos de usar.</p>
<p>Por ejemplo, con el lenguaje que vamos a aprender, R, el problema de pedirle dos n<U+FFFD>meros a una persona y sumarlos se resumen en las siguientes l<U+FFFD>neas de c<U+FFFD>digo:</p>
<pre><code>n1 &lt;- scan()
n2 &lt;- scan()
print(n1 + n2)</code></pre>
<p>En las dos primeras l<U+FFFD>neas con la sentencia <code><a href="https://rdrr.io/r/base/scan.html">scan()</a></code> (que quiere decir <U+FFFD>escanear<U+FFFD>, <U+FFFD>leer<U+FFFD>) se le pide a la persona que indique dos n<U+FFFD>meros y en la tercera l<U+FFFD>nea se muestra el resultado de la suma, con la sentencia <code><a href="https://rdrr.io/r/base/print.html">print()</a></code> (<U+FFFD>imprimir<U+FFFD>, <U+FFFD>mostrar<U+FFFD>). Mucho m<U+FFFD>s corto y entendible.</p>
<p>Esta simplificaci<U+FFFD>n es posible porque nos permitimos <em>ignorar</em> ciertos aspectos del proceso que realiza la computadora. Todas esas acciones que se ven ejemplificadas en la imagen con el c<U+FFFD>digo ensamblador se llevan a cabo de todas formas, pero no lo vemos. Nosotros s<U+FFFD>lo tenemos que aprender esas <U+FFFD>ltimas tres l<U+FFFD>neas de c<U+FFFD>digo, de forma que nos podemos concentrar en el problema a resolver (ingresar dos n<U+FFFD>meros, sumarlos y mostrar el resultado) y no en las complejas operaciones internas que tiene que hacer el microprocesador.</p>
<p>En programaci<U+FFFD>n, la idea de simplificar un proceso complejo ignorando algunas de sus partes para comprender mejor lo que hay que realizar y as<U+FFFD> resolver un problema se conoce como <strong>abstracci<U+FFFD>n</strong><a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;La abstracci<U+FFFD>n no es una idea exclusiva de la programaci<U+FFFD>n. Se encuentra, tambi<U+FFFD>n, por ejemplo, en el &lt;em&gt;arte abstracto&lt;/em&gt;.&lt;/p&gt;"><sup>3</sup></a>. Esto quiere decir que los lenguajes de programaci<U+FFFD>n pueden tener distintos niveles de abstracci<U+FFFD>n:</p>
<ul>
<li>
<strong>Lenguajes de bajo nivel de abstracci<U+FFFD>n</strong>: permiten controlar directamente el <em>hardware</em> de la computadora, son espec<U+FFFD>ficos para cada tipo de m<U+FFFD>quina, y son m<U+FFFD>s r<U+FFFD>gidos y complicados de entender para nosotros. El lenguaje ensamblador entra en esta categor<U+FFFD>a.</li>
<li>
<strong>Lenguajes de alto nivel de abstracci<U+FFFD>n</strong>: dise<U+FFFD>ados para que sea f<U+FFFD>cil para los humanos expresar los algoritmos sin necesidad de entender en detalle c<U+FFFD>mo hace exactamente el hardware para ejecutarlos. El lenguaje que utilizaremos en este taller, R, es de alto nivel. Son independientes del tipo de m<U+FFFD>quina.</li>
<li>
<strong>Lenguajes de nivel medio de abstracci<U+FFFD>n</strong>: son lenguajes con caracter<U+FFFD>sticas mixtas entre ambos grupos anteriores.</li>
</ul>
<div class="figure" style="text-align: center">
<span id="fig:lenguajes"></span>
<img src="images/intro/07_lenguajes.jpg" alt="Distintos lenguajes de programaci<U+FFFD>n y sus logos." width="70%"><p class="caption">
Figura 1.9: Distintos lenguajes de programaci<U+FFFD>n y sus logos.
</p>
</div>
<p>Si bien podemos programar usando un lenguaje de alto nivel para que nos resulte m<U+FFFD>s sencillo, <em>alguien</em> o <em>algo</em> debe traducirlo a lenguaje de m<U+FFFD>quina para que la computadora, que s<U+FFFD>lo entiende de ceros y unos, pueda realizar las tareas. Esto tambi<U+FFFD>n es necesario incluso si program<U+FFFD>ramos en lenguaje ensamblador. Para estos procesos de traducci<U+FFFD>n se crearon los <strong>compiladores</strong> e <strong>int<U+FFFD>rpretes</strong>.</p>
<p>Un <strong>compilador</strong> es un programa que toma el c<U+FFFD>digo escrito en un lenguaje de alto nivel y lo traduce a c<U+FFFD>digo de m<U+FFFD>quina, guard<U+FFFD>ndolo en un archivo que la computadora ejecutar<U+FFFD> posteriormente (archivo ejecutable). Para ilustrar el rol del compilador, imaginemos que alguien que s<U+FFFD>lo habla espa<U+FFFD>ol le quiere mandar una carta escrita en espa<U+FFFD>ol a alguien que vive en Alemania y s<U+FFFD>lo habla alem<U+FFFD>n. Cuando esta persona la reciba, no la va a entender. Se necesita de un intermediario que tome la carta en espa<U+FFFD>ol, la traduzca y la escriba en alem<U+FFFD>n y luego se la mande al destinatario, quien ahora s<U+FFFD> la podr<U+FFFD> entender. Ese es el rol de un <em>compilador</em> en la computadora. Ahora bien, el resultado de la traducci<U+FFFD>n, que es la carta escrita en alem<U+FFFD>n, s<U+FFFD>lo sive para gente que hable alem<U+FFFD>n. Si se quiere enviar el mismo mensaje a personas que hablen otros idiomas, necesitaremos hacer la traducci<U+FFFD>n que corresponda. De la misma forma, el c<U+FFFD>digo generado por un compilador es espec<U+FFFD>fico para cada m<U+FFFD>quina, depende de su arquitectura.</p>
<p>Adem<U+FFFD>s de los compiladores, para realizar este pasaje tambi<U+FFFD>n existen los <strong>int<U+FFFD>rpretes</strong>. Un int<U+FFFD>rprete es un programa que traduce el c<U+FFFD>digo escrito en lenguaje de alto nivel a c<U+FFFD>digo de m<U+FFFD>quina, pero lo va haciendo a medida que se necesita, es decir, su resultado reside en la memoria temporal de la computadora y no se genera ning<U+FFFD>n archivo ejecutable. Siguiendo con el ejemplo anterior, es similar a viajar a Alemania con un int<U+FFFD>rprete que nos vaya traduciendo en vivo y en directo cada vez que le queramos decir algo a alguien de ese pa<U+FFFD>s. En su implementaci<U+FFFD>n por defecto, el lenguaje R es interpretado, no compilado.</p>
<!-- https://stackoverflow.com/questions/1677021/is-r-an-interpreted-or-compiled-programming-language -->
<!-- https://cran.r-project.org/doc/FAQ/R-FAQ.html#What-is-R_003f -->
<!-- https://www.oreilly.com/library/view/r-in-a/9781449358204/ch05s09.html#:~:text=R%20is%20an%20interpreted%20language,programs%20into%20an%20object%20language. -->
<p>Concluyendo, gracias al concepto de la <strong>abstracci<U+FFFD>n</strong> podemos escribir programas en un lenguaje que nos resulte f<U+FFFD>cil entender, y gracias al trabajo de los <strong>compiladores</strong> e <strong>int<U+FFFD>rpretes</strong> la computadora podr<U+FFFD> llevar adelante las tareas necesarias.</p>
<p>Cada una de las acciones que componen al algoritmo son codificadas con una o varias <strong>instrucciones</strong> o <strong>sentencias</strong>, expresadas en el lenguaje de programaci<U+FFFD>n elegido, y el conjunto de todas ellas constituye un <strong>programa</strong>. El programa se guarda en un <strong>archivo</strong> con un nombre generalmente dividido en dos partes por un punto, por ejemplo: <code>mi_primer_programa.R</code>. La primera parte es la <strong>ra<U+FFFD>z</strong> del nombre con la cual podemos describir el contenido del archivo. La segunda parte es indicativa del uso del archivo, por ejemplo, <code>.R</code> indica que contiene un programa escrito en el lenguaje R. El proceso general de ingresar o modificar el contenido de un archivo se denomina <strong>edici<U+FFFD>n</strong>.</p>
</div>
</div>
<div id="errores-de-programaci<U+FFFD>n" class="section level2" number="1.5">
<h2>
<span class="header-section-number">1.5</span> Errores de programaci<U+FFFD>n<a class="anchor" aria-label="anchor" href="#errores-de-programaci%C3%B3n"><i class="fas fa-link"></i></a>
</h2>
<p>Apenas iniciemos nuestro camino en el mundo de la programaci<U+FFFD>n nos daremos cuenta que tendremos siempre ciertos compa<U+FFFD>eros de viaje: los <strong>errores</strong>. Muchas veces nos pasar<U+FFFD> que queremos ejecutar nuestro c<U+FFFD>digo y el mismo no anda o no produce el resultado esperado. No importa cu<U+FFFD>n cuidadosos seamos, ni cu<U+FFFD>nta experiencia tengamos, los errores est<U+FFFD>n siempre presentes. Con el tiempo y pr<U+FFFD>ctica, vamos a poder identificarlos y corregirlos con mayor facilidad, pero probablemente nunca dejemos de cometerlos.</p>
<p>A los errores en programaci<U+FFFD>n se los suele llamar <strong>bugs</strong> (insecto o bicho en ingl<U+FFFD>s) y el proceso de la correcci<U+FFFD>n de los mismos se conoce como <strong>debugging</strong> (depuraci<U+FFFD>n)<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;Algunos usan el t<U+FFFD>rmino bug para referirse exclusivamente a errores l<U+FFFD>gicos&lt;/p&gt;"><sup>4</sup></a>. Se dice que esta terminolog<U+FFFD>a proviene de 1947, cuando una computadora en la Universidad de Harvard (la <em>Mark II</em>) dej<U+FFFD> de funcionar y finalmente se descubri<U+FFFD> que la cause del problema era la presencia de una polilla en un rel<U+FFFD> electromagn<U+FFFD>tico de la m<U+FFFD>quina. Sin embargo, otros historiadores sostienen que el t<U+FFFD>rmino ya se usaba desde antes.</p>
<div class="figure" style="text-align: center">
<span id="fig:unnamed-chunk-6"></span>
<img src="images/intro/First_Computer_Bug.jpg" alt="La polilla (bug) encontrada por la cient<U+FFFD>fica de la computaci<U+FFFD>n Grace Hooper en la Mark II fue pegada con cinta en un reporte sobre el malfuncionamiento de la m<U+FFFD>quina." width="50%"><p class="caption">
Figura 1.10: La polilla (bug) encontrada por la cient<U+FFFD>fica de la computaci<U+FFFD>n Grace Hooper en la Mark II fue pegada con cinta en un reporte sobre el malfuncionamiento de la m<U+FFFD>quina.
</p>
</div>
<p>A continuaci<U+FFFD>n se presenta una de las posibles clasificaciones de los errores que se pueden cometer en programaci<U+FFFD>n:</p>
<ul>
<li><p><strong>Errores de sintaxis</strong>. Tal como el lenguaje humano, los lenguajes de programaci<U+FFFD>n tienen su propio vocabulario y su propia sintaxis, que es el conjunto de reglas gramaticales que establecen c<U+FFFD>mo se pueden combinar las distintas partes. Estas reglas sint<U+FFFD>cticas determinan que ciertas sentencias est<U+FFFD>n correctamente construidas, mientras que otras no. Cuando ejecutamos un programa, el compilador o el int<U+FFFD>rprete chequea si el mismo es sint<U+FFFD>cticamente correcto. Si hemos violado alguna regla, por ejemplo, nos falt<U+FFFD> una coma o nos sobra un par<U+FFFD>ntesis, mostrar<U+FFFD> un mensaje de error y debemos editar nuestro programa para corregirlo. En estos casos, hay que interpretar el mensaje de error, revisar el c<U+FFFD>digo y corregir el error.</p></li>
<li><p><strong>Errores l<U+FFFD>gicos</strong>. Se presentan cuando el programa puede ser compilado sin errores pero arroja resultados incorrectos o ning<U+FFFD>n resultado. El software no muestra mensajes de error, debido a que, por supuesto, no sabe cu<U+FFFD>l es el resultado deseado, sino que s<U+FFFD>lo se limita a hacer lo que hemos programado. En estos casos hay que revisar el programa para encontrar alg<U+FFFD>n error en su l<U+FFFD>gica. Este tipo de errores suelen ser los m<U+FFFD>s problem<U+FFFD>ticos. Algunas ideas para enfrentarlos incluyen volver a pensar paso por paso lo que se deber<U+FFFD>a hacer para solucionar el problema y compararlo con lo que se ha programado, agregar pasos para mostrar resultados intermedios o emplear herramientas especializadas de <em>debugging</em> (llamadas <em>debugger</em>) para explorar el c<U+FFFD>digo paso a paso hasta identificar el error.</p></li>
<li><p><strong>Errores en la ejecuci<U+FFFD>n</strong> (<em>runtime errors</em>). Se presentan cuando el programa est<U+FFFD> bien escrito, sin errores l<U+FFFD>gicos ni sint<U+FFFD>cticos, pero igualmente se comporta de alguna forma incorrecta. Se dan a pesar de que el programa ande bien en el entorno de desarrollo del programador, pero no cuando alg<U+FFFD>n usuario lo utiliza en alg<U+FFFD>n contexto particular. Puede ser que se intente abrir un archivo que no existe, que el proceso supere la memoria disponible, que tomen lugar operaciones aritm<U+FFFD>ticas no definidas como la divisi<U+FFFD>n por cero, etc.</p></li>
</ul>
<p>Los errores en la programaci<U+FFFD>n son tan comunes, que un cient<U+FFFD>fico de la computaci<U+FFFD>n muy reconocido, Edsger Dijkstra, dijo una vez: <U+FFFD>si la depuraci<U+FFFD>n es el proceso de eliminar errores, entonces la programaci<U+FFFD>n es el proceso de generarlos<U+FFFD>. Ante la presencia de uno, no hay m<U+FFFD>s que respirar profundo y con paciencia revisar hasta encontrarlo y solucionarlo.</p>
<div class="figure" style="text-align: center">
<span id="fig:bug"></span>
<img src="images/intro/08_bug.jpg" alt="Encontrando un bug en un programa." width="50%"><p class="caption">
Figura 1.11: Encontrando un bug en un programa.
</p>
</div>

</div>
</div>










  <div class="chapter-nav">
<div class="prev"><a href="index.html">Bienvenida</a></div>
<div class="empty"></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="En esta p<U+FFFD>gina"><h2>En esta p<U+FFFD>gina</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#introducci%C3%B3n"><span class="header-section-number">1</span> Introducci<U+FFFD>n</a></li>
<li><a class="nav-link" href="#qu%C3%A9-es-la-programaci%C3%B3n"><span class="header-section-number">1.1</span> Qu<U+FFFD> es la programaci<U+FFFD>n</a></li>
<li><a class="nav-link" href="#una-breve-rese%C3%B1a-hist%C3%B3rica-sobre-la-programaci%C3%B3n"><span class="header-section-number">1.2</span> Una breve rese<U+FFFD>a hist<U+FFFD>rica sobre la programaci<U+FFFD>n</a></li>
<li><a class="nav-link" href="#software-y-hardware"><span class="header-section-number">1.3</span> Software y hardware</a></li>
<li>
<a class="nav-link" href="#problemas-algoritmos-y-lenguajes-de-programaci%C3%B3n"><span class="header-section-number">1.4</span> Problemas, algoritmos y lenguajes de programaci<U+FFFD>n</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#el-dise%C3%B1o-algor%C3%ADtmico"><span class="header-section-number">1.4.1</span> El dise<U+FFFD>o algor<U+FFFD>tmico</a></li>
<li><a class="nav-link" href="#codificaci%C3%B3n"><span class="header-section-number">1.4.2</span> Codificaci<U+FFFD>n</a></li>
</ul>
</li>
<li><a class="nav-link" href="#errores-de-programaci%C3%B3n"><span class="header-section-number">1.5</span> Errores de programaci<U+FFFD>n</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Introducci<U+FFFD>n a la Programaci<U+FFFD>n</strong>: Gu<U+FFFD>a de estudio - Lic. en Estad<U+FFFD>stica - FCEyE - UNR" was written by Mgs. Lic. Marcos Prunello (Prof.<U+FFFD>Tit. Ord.). It was last built on 2021-04-24.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer>
</body>
</html>

[{"path":"index.html","id":"bienvenida","chapter":"Bienvenida","heading":"Bienvenida","text":"¡Les damos la bienvenida la asignatura Introducción la Programación en la Facultad de Ciencias Económicas y Estadística, Universidad Nacional de Rosario! La presente guía resume los conceptos más importantes que vamos desarrollar. La misma irá siendo revisada, completada y actualizada lo largo del cuatrimestre y está exenta de presentar errores o expresar ideas que puedan ser mejoradas. Avisanos si encontrás algo que deba ser cambiado. ¡Esperamos que juntos podamos pasarla bien al dar nuestros primeros pasos en la programación!Este material fue escrito por el Mgs. Lic. Marcos Prunello (profesor titular) y revisado por los integrantes de la cátedra, Tec. César Mignoni y Lic. Maite San Martín.","code":""},{"path":"estructuras-de-datos.html","id":"estructuras-de-datos","chapter":"1 Estructuras de Datos","heading":"1 Estructuras de Datos","text":"Hasta ahora todos los algoritmos que hemos desarrollado hacen uso de objetos que guardan datos individuales, los cuales representaban un número, una cadena de texto o un valor lógico. Sin embargo, la verdadera utilidad de la computación radica en poder trabajar con conjuntos de datos, organizados de acuerdo ciertas reglas que permitan su manipulación y acceso. Definimos entonces como estructura de datos un conjunto de datos que cuentan con un sistema de organización.Veremos dos tipos de estructuras de datos: los arreglos y las listas.","code":""},{"path":"estructuras-de-datos.html","id":"arreglos","chapter":"1 Estructuras de Datos","heading":"1.1 Arreglos","text":"Un arreglo (o array) se define como una colección de valores individuales con dos características fundamentales:Ordenamiento: los valores individuales pueden ser enumerados en orden, es decir, debe ser posible identificar en qué posición del arreglo se encuentra cada valor.Homogeneidad: los valores individuales almacenados en un arreglo son todos del mismo tipo (numérico, caracter, lógico).Los arreglos son muy útiles para almacenar información en la memoria de la computadora, organizando valores que estén relacionados entre sí de alguna manera, por ejemplo, una conjunto de precios, los meses del año, el listado de calificaciones de estudiantes en distintos parciales, etc.Los componentes individuales del conjunto se llaman elementos. Para indicar qué posición ocupa cada elemento en el arreglo se emplean uno o más índices. Dependiendo de cuántos índices se deban utilizar para acceder cada elemento dentro de los arreglos, estos se clasifican en unidmensionales (vectores), bidimensionales (matrices) o multidimensionales.","code":""},{"path":"estructuras-de-datos.html","id":"arreglos-unidimensionales-o-vectores","chapter":"1 Estructuras de Datos","heading":"1.1.1 Arreglos unidimensionales o vectores","text":"Un arreglo unidimensional o vector tiene n elementos todos del mismo tipo. Por ejemplo, el siguiente es un vector de tipo numérico llamado x con 5 elementos:\nFigura 1.1: Ejemplo de un vector numérico\nCada uno de los elementos ocupa una posición determinada en el vector. Por ejemplo, el elemento 3 del vector x es el numéro 2.71. Se puede acceder o hacer referencia cada elemento mediante el uso de índices, expresados entre corchetes al lado del nombre del vector. De esta forma, si escribimos x[3] hacemos referencia la tercera posición del vector, que actualmente guarda al valor 2.71. Como podemos ver, sólo hace falta un índice para hacer referencia cada elemento de un vector.\nFigura 1.2: Ejemplo de un vector numérico: índices para señalar cada posición.\nLos siguientes son ejemplos de vectores de tipo caracter y lógico, con distintas cantidades de elementos:\nFigura 1.3: Ejemplo de un vector caracter y un vector lógico\nAl igual que todas las variables que empleamos en nuestros algoritmos, los vectores que serán utilizados deben ser declarados en el pseudocódigo, eligiendo un identificador (nombre) e indicando su tipo y su tamaño, es decir, la cantidad de posiciones que contienen. Esto último se señala entre paréntesis al lado del nombre elegido. Por ejemplo, el vector x visto anteriomente puede ser creado de la siguiente forma:Si bien la declaración de un vector sólo tiene como objetivo permitirle la computadora que reserve internamente el espacio necesario en memoria para el mismo, para escribir pseudocódigo de una manera sencilla estableceremos la siguiente convención. Cuando declaramos un vector de tipo numérico con la expresión VARIABLE numérica x(5) asumiremos que, además de reservar espacio en memoria para el vector, se le asigna un 0 (cero) en cada posición. Es decir, el vector x es iniciado con ceros, que más tarde pueden ser reemplazados por otros valores. Del mismo modo, asumiremos que cuando declaramos vectores de tipo caracter, todos sus elementos son iniciados con valores \"\" (una cadena de texto vacía) y cuando declaramos vectores de tipo lógico, con el valor FALSO.En R, los vectores se construyen de forma dinámica por lo cual es necesario declararlos antes de comenzar utilizarlos. La función c() (de combinar) permite crear vectores, por ejemplo, los mencionados anteriormente:\nFigura 1.4: Creación de vectores en R\nCuando ejecutamos dichas líneas, se crean en el ambiente global los objetos x, y y z, como podemos notar en la pestaña Environment de RStudio. Es decir, los vectores, así como cualquier otro tipo de arreglo, son objetos que constituyen entidades en sí mismas y que pueden ser manipulados al hacer referencia sus indicadores. Además, RStudio nos muestra en la pestaña mencionada qué tipo de vector es cada uno (num, chr, logi), cuántos elementos tiene ([1:5], [1:4], [1:3]) y una previsualización de sus primeros elementos.Dado que la función c() resulta, en consecuencia, muy importante al programar en R, es recomendable que evitemos usar la letra c como nombre para otros objetos1.Podemos emplear estructuras iterativas para recorrer todas las posiciones de un vector y realizar operaciones con ellas, por ejemplo:Todos los lenguajes de programación incluyen, además, alguna función para determinar cuántos elementos tiene un vector que ya fue creado. Para esto emplearemos la expresión LARGO() en el pseudocódigo y la función length de R:Entonces, para recorrer todos los elementos del vector podemos hacer también:O bien:Antes comentamos que en R los vectores se crean con expresiones como x <- c(-4.5, 12, 2.71, -6, 25), donde sus elementos están listados de forma literal. También podemos crear vectores de un largo determinado dejando que cada posición quede ocupada por un valor por default. Por ejemplo, el siguiente código crea un vector tipo numérico con 10 posiciones, uno caracter con 7 y otro lógico con 2. En cada caso, R rellena por defecto todas las posiciones con el mismo valor: un 0 para todas las posiciones del vector numérico, un caracter vacío \"\" para las del vector caracter y el valor FALSE para el vector lógico:Se pueden asignar valores una, varias o todas las posiciones de un vector en cualquier parte del algoritmo. Además, en pseudocódigo emplearemos la palabra clave MOSTRAR cuando deseamos que se escriba en pantalla todo el contenido de un vector. Por ejemplo:En los ejemplos anteriores, declaramos los vectores explicitando su tamaño con un número: VARIABLE numérica x(5) o VARIABLE numérica (10). Sin embargo, el tamaño del vector podría estar guardado en otra variable, cuyo valor se determina en cada ejecución del programa mediante información externa o como resultado de algún cálculo anterior. En el siguiente ejemplo se deja que el usuario determine la dimensión del vector y que provea cada uno de los valores para el mismo. Antes de poder declarar la existencia del nuevo vector llamado mi_vector, se “lee” su tamaño:Por ahora, toda instrucción de leer en el pseudocódigo será traducida en R mediante la asignación directa de valores. Por ejemplo, LEER tam se reemplaza por tam <- 5 (o el número que necesitemos).Antes de terminar esta sección haremos una última observación. En R todos los objetos que hemos considerado como “variable” y que guardan un único valor (como tam en el ejemplo anterior), son también considerados como vectores, cuyo largo es 1, como podemos verificar en el siguiente ejemplo:Ejemplo: invertir los elementos de un vectorNos planteamos el problema de dar vuelta los elementos pertenecientes un vector, de manera que el primer elemento pase ser el último, el segundo pase al penúltimo lugar, etcétera. Por ejemplo, dado el vector de tipo caracter v:\nFigura 1.5: Vector v original\nqueremos modificarlo para obtener:\nFigura 1.6: Vector v reordenado\nSi bien podemos pensar en distintas formas para resolver este problema, probablemente la más sencilla requiere que intercambiemos de dos los valores en ciertas posiciones del vector, por ejemplo, empezando por intercambiar el primero con el último. Para esto podemos emplear una variable auxiliar que guarde el valor de alguna de las celdas temporariamente (por eso lo vamos llamar tmp):\nFigura 1.7: Pasos para intercambiar valores\nAhora sólo resta realizar el mismo procedimiento para los valores de las posiciones 2 y 4. Como el número de elementos en el vector es impar, el valor en la posición central queda en su lugar. Podemos definir el siguiente algorimo para resolver este problema de manera general. En el siguiente pseudocódigo, primero declaramos una variable numérica n que puede tomar cualquier valor y que servirá para declarar cuántos espacios necesita el vector. Luego, se itera para leer cada elemento del vector. Finalmente, se implementa la estrategia de reordenamiento:En el ejemplo anterior hemos incorporado el uso de comentarios en el pseudocódigo para describir el objetivo de cada parte. Imitando lo que hacemos en R, señalamos la presencia de comentarios con el caracter # (podríamos usar otra cosa, pero adheriremos esta convención). Se usó la expresión ENTERO() para hacer referencia la parte entera del número indicado entre paréntesis, lo cual se puede indicar en R con la función floor(). Además, en R reemplazamos todas las instrucciones LEER por una asignación directa de valores:","code":"VARIABLE numérica x(5)\nx[1] <- -4.5\nx[2] <- 12\nx[3] <- 2.71\nx[4] <- -6\nx[5] <- 25\nx <- c(-4.5, 12, 2.71, -6, 25)\ny <- c(\"ARG\", \"correo@gmail.com\", \"Ok\", \"chau\")\nz <- c(TRUE, TRUE, FALSE)PARA i DESDE 1 HASTA 5 HACER\n    ESCRIBIR \"La posición \" i \"de x está ocupada por el valor \" x[i]\nFIN PARA\nfor (i in 1:5) {\n    cat(\"La posición\", i, \"de x está ocupada por el valor\", x[i], \"\\n\")\n}La posición 1 de x está ocupada por el valor -4.5 \nLa posición 2 de x está ocupada por el valor 12 \nLa posición 3 de x está ocupada por el valor 2.71 \nLa posición 4 de x está ocupada por el valor -6 \nLa posición 5 de x está ocupada por el valor 25 ESCRIBIR \"El vector x tiene \" LARGO(x) \" elementos.\"\nESCRIBIR \"El vector y tiene \" LARGO(y) \" elementos.\"\nESCRIBIR \"El vector z tiene \" LARGO(z) \" elementos.\"\ncat(\"El vector x tiene\", length(x), \"elementos.\")El vector x tiene 5 elementos.\ncat(\"El vector y tiene\", length(y), \"elementos.\")El vector y tiene 4 elementos.\ncat(\"El vector z tiene\", length(z), \"elementos.\")El vector z tiene 3 elementos.PARA i DESDE 1 HASTA LARGO(x) HACER\n    ESCRIBIR \"La posición \" i \"de x está ocupada por el valor \" x[i]\nFIN PARAtam <- LARGO(x)\nPARA i DESDE 1 HASTA tam HACER\n    ESCRIBIR \"La posición \" i \"de x está ocupada por el valor \" x[i]\nFIN PARA\na <- numeric(10)\nb <- character(7)\nd <- logical(2)\n\na [1] 0 0 0 0 0 0 0 0 0 0\nb[1] \"\" \"\" \"\" \"\" \"\" \"\" \"\"\nd[1] FALSE FALSEVARIABLE numérica a(10)\n...algunas acciones...\nPARA i DESDE 1 HASTA LARGO(a) HACER\n    SI i %% 3 == 0 ENTONCES  \n        a[i] <- i * 100\n    FIN SI\nFIN PARA\nMOSTRAR a\na <- numeric(10)\nfor (i in 1:length(a)) {\n    if (i %% 3 == 0) {\n        a[i] <- i * 100\n    }\n}\na       # También: cat(a) o print(a) [1]   0   0 300   0   0 600   0   0 900   0VARIABLE numérica tam\nLEER tam\nVARIABLE numérica mi_vector(tam)\nPARA i DESDE 1 HASTA tam HACER\n    LEER mi_vector[i]\nFIN PARA\nx <- 25\nlength(x)[1] 1\nis.vector(x) # Esta función lógica le pregunta a R si el objeto x es un vector[1] TRUEALGORITMO: \"Invertir (dar vuelta) los elementos de un vector\"\nCOMENZAR\n    \n  # Declarar variables\n  VARIABLE numérica n\n  VARIABLE caracter tmp\n  LEER n\n  VARIABLE caracter v(n)\n  \n  # Asignar valores al vector\n  PARA i DESDE 1 HASTA n HACER\n      LEER v[i]\n  FIN PARA\n  \n  # Reordenar\n  PARA i DESDE 1 HASTA ENTERO(n / 2) HACER\n      tmp <- v[i]                 # Paso 1\n      v[i] <- v[n - i + 1]        # Paso 2\n      v[n - i + 1] <- tmp         # Paso 3\n  FIN PARA\n  \n  # Mostrar el vector reodenado\n  MOSTRAR v\n    \nFIN\nv <- c(\"Estadística\", \"en\", \"Licenciatura\", \"la\", \"Aguante\")\nn <- length(v)\nfor (i in 1:floor(n / 2)) {\n    tmp <- v[i]\n    v[i] <- v[n - i + 1]\n    v[n - i + 1] <- tmp\n}\nv[1] \"Aguante\"      \"la\"           \"Licenciatura\" \"en\"           \"Estadística\" "},{"path":"estructuras-de-datos.html","id":"arreglos-bidimensionales-o-matrices","chapter":"1 Estructuras de Datos","heading":"1.1.2 Arreglos bidimensionales o matrices","text":"Un arreglo bidimensional representa lo que habitualmente conocemos en matemática como matriz y por eso también lo llamamos de esa forma. Podemos imaginar que en una matriz los elementos están organizados en filas y columnas formando una tabla. Por ejemplo, la siguiente es una matriz llamada x:\nFigura 1.8: Ejemplo de una matriz numérica\ndiferencia de los vectores, las matrices requieren dos índices para señalar la posición de cada elemento, el primero para indicar la fila y el segundo para indicar la columna. Los mismos se colocan entre corchetes, separados por una coma, al lado del identificador de la matriz. De esta forma, si hablamos de x[1, 3] hacemos referencia la posición ocupada por el valor 18, mientras que si mencionamos x[3, 1] nos referimos al valor 14.\nFigura 1.9: Ejemplo de una matriz numérica: índices para señalar cada posición\nAl tamaño de una matriz, es decir, cuántas filas y columnas tiene, se le dice dimensión. La matriz anterior es de dimension \\(3 \\times 4\\).Como hicimos con los vectores, debemos declarar las matrices que vamos usar en el pseudocódigo, indicando su identificador, tipo y dimensión: VARIABLE numérica x(3, 4). También vamos asumir que todas las posiciones de una matriz son iniciadas con el valor 0, \"\" o FALSO si la misma es numérica, caracter o lógica, respectivamente. La matriz x puede ser generada en pseudocódigo de esta forma:En R, es necesario declarar las matrices con anterioridad y las mismas pueden ser creadas de manera literal con la función matrix(). Su primer argumento, data, es un vector con todos los elementos que queremos guardar en la matriz. Luego, se indica la cantidad de filas para la misma con nrow y la cantidad de columnas con ncol:Notar que R ubicó los valores provistos llenando primero la columna 1, luego la 2, etc. Ese comportamiento puede ser modificado con el argumento byrow, que por default es FALSE. Si lo cambiamos TRUE los elementos son ubicados por fila. Además, podemos usar saltos de líneas (enter) para visualizar las diferentes filas de la matriz. Esto tiene ningún impacto en R, sólo sirve para que el código sea más fácil de leer. Dado que hemos provisto 12 valores e indicamos que queremos 3 filas, el argumento ncol es necesario (es obvio que quedarán 4 columnas). Por eso, las siguientes sentencias son equivalentes la anterior:Si colocamos un único valor como primer argumento en la función matrix(), el mismo se repetirá en todas las posiciones. En este caso sí o sí tenemos que indicar cuántas filas y columnas deseamos:Una vez que la matriz ya existe, en el pseudocódigo haremos referencia al número de filas y columnas de la misma con las expresiones NFILA(x) y NCOL(x). En R tenemos las siguientes funciones para analizar el tamaño de las matrices:Podemos recorrer todas las posiciones de una matriz con una estructura iterativa doble: nos situamos en la primera fila y recorremos cada columna, luego en la segunda fila y recorremos todas las columnas y así sucesivamente:\nFigura 1.10: Recorrer una matriz por fila\nTambién se puede recorrer la matriz por columna, si modificamos ligeramente las estructuras iterativas:\nFigura 1.11: Recorrer una matriz por columna\nSe puede usar cualquier letra o palabra como variables iteradoras, pero el uso de para las filas y de j para las columnas es bastante común.También podemos asignar valores en cada celda mientras recorremos la matriz. De hecho, la matriz x del ejemplo puede ser generada así, donde los índices y j sólo señalan una posición en particular dentro de la matriz, sino que además se usan para hacer el cálculo del valor asignar:Si queremos dejar que el valor en cada posición sea determinado por una fuente de información externa la hora de correr el programa, empleamos la sentencia LEER en el pseudocódigo:","code":"VARIABLE numérica x(3, 4)\nx[1, 1] <- 8\nx[1, 2] <- 13\nx[1, 3] <- 18\nx[1, 4] <- 23\nx[2, 1] <- 11\nx[2, 2] <- 16\nx[2, 3] <- 21\nx[2, 4] <- 26\nx[3, 1] <- 14\nx[3, 2] <- 19\nx[3, 3] <- 24\nx[3, 4] <- 29\nx <- matrix(data = c(8, 11, 14, 13, 16, 19, 18, 21, 24, 23, 26, 29),\n            nrow = 3, ncol = 4)\nx     [,1] [,2] [,3] [,4]\n[1,]    8   13   18   23\n[2,]   11   16   21   26\n[3,]   14   19   24   29\nx <- matrix(c( 8, 13, 18, 23, \n              11, 16, 21, 26, \n              14, 19, 24, 29), \n            nrow = 3, byrow = TRUE)\n\nx <- matrix(c( 8, 13, 18, 23, \n              11, 16, 21, 26, \n              14, 19, 24, 29), \n            ncol = 4, byrow = TRUE)\ny <- matrix(0, nrow = 2, ncol = 5)\ny     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    0    0    0    0\n[2,]    0    0    0    0    0\ndim(x)[1] 3 4\nnrow(x)[1] 3\nncol(x)[1] 4\ndim(y)[1] 2 5\nnrow(y)[1] 2\nncol(y)[1] 5VARIABLE numérica x(3, 4)\nPARA i DESDE 1 HASTA NFILA(x) HACER\n    PARA j DESDE 1 HASTA NCOL(x) HACER\n        x[i, j] <- 3 * i + 5 * j\n    FIN PARA\nFIN PARA\nMOSTRAR x\nx <- matrix(0, nrow = 3, ncol = 4)\nfor (i in 1:nrow(x)) {\n    for (j in 1:ncol(x)) {\n        x[i, j] <- 3 * i + 5 * j\n    }\n}\nx     [,1] [,2] [,3] [,4]\n[1,]    8   13   18   23\n[2,]   11   16   21   26\n[3,]   14   19   24   29VARIABLE numérica x(3, 4)\nPARA i DESDE 1 HASTA NFILA(x) HACER\n  PARA j DESDE 1 HASTA NCOL(x) HACER\n    LEER x[i, j]\n  FIN PARA\nFIN PARA"},{"path":"estructuras-de-datos.html","id":"ejemplo-trasponer-una-matriz","chapter":"1 Estructuras de Datos","heading":"1.1.2.1 Ejemplo: trasponer una matriz","text":"En Álgebra, trasponer una matriz de dimensión \\(m \\times n\\) significa generar una nueva matriz de dimensión \\(n \\times m\\), donde los elementos se intercambian de este modo:\nFigura 1.12: Matriz traspuesta\nPodemos formalizar el algoritmo que permite generar la matriz traspuesta, teniendo en cuenta que cada elemento que originalmente ocupa la posición [, j] en la matriz original, debe pasar ocupar la posición [j, ] en la matriz traspuesta:Dado que en R vamos asignar valores en la matriz de manera literal, primero la creamos y luego usamos nrow() y ncol() para obtener los correspondientes valores de nf y nc. En el siguiente ejemplo, además, todas las posiciones de la matriz traspuesta son iniciadas con el valor NA (valor lógico que significa Available o “disponible”).","code":"ALGORITMO: Trasponer matriz\nCOMENZAR\n    \n    # Declarar objetos\n    VARIABLE numérica nf, nc\n    LEER nf, nc\n    VARIABLE numérica x(nf, nc), traspuesta(nc, nf)\n    \n    # Leer los valores de la matriz\n    PARA i DESDE 1 HASTA nf HACER\n        PARA j DESDE 1 HASTA nc HACER\n            LEER x[i, j]\n        FIN PARA\n    FIN PARA\n    \n    # Trasponer\n    PARA i DESDE 1 HASTA nf HACER\n        PARA j DESDE 1 HASTA nc HACER\n            traspuesta[j, i] <- x[i, j]\n        FIN PARA\n    FIN PARA\n    \n    # Mostrar ambas matrices\n    ESCRIBIR \"Matriz original\"\n    MOSTRAR x\n    ESCRIBIR \"Matriz traspuesta\"\n    MOSTRAR traspuesta\n    \nFIN\nx <- matrix(c( 8, 13, 18, 23, \n              11, 16, 21, 26, \n              14, 19, 24, 29), \n            nrow = 3, byrow = TRUE)\nnf <- nrow(x)\nnc <- ncol(x)\ntraspuesta <- matrix(NA, nc, nf)\nfor (i in 1:nf) {\n    for (j in 1:nc) {\n        traspuesta[j, i] <- x[i, j]\n    }\n}\ncat(\"Matriz original\\n\")\nx\ncat(\"Matriz traspuesta\\n\")\ntraspuestaMatriz original\n     [,1] [,2] [,3] [,4]\n[1,]    8   13   18   23\n[2,]   11   16   21   26\n[3,]   14   19   24   29\nMatriz traspuesta\n     [,1] [,2] [,3]\n[1,]    8   11   14\n[2,]   13   16   19\n[3,]   18   21   24\n[4,]   23   26   29"},{"path":"estructuras-de-datos.html","id":"arreglos-multidimensionales","chapter":"1 Estructuras de Datos","heading":"1.1.3 Arreglos multidimensionales","text":"Un arreglo multidimensional contiene más de dos dimensiones, es decir, requiere más de dos índices para identificar cada uno de sus elementos. La representación matemática o visual ya es tan sencilla. Para interpretarlos o saber cuándo usarlos, pensamos que cada una de las dimensiones representa una característica de los elementos.Por ejemplo, imaginemos que en un local comercial se quiere registrar cuántos clientes se atendieron en cada una de las tres cajas disponibles (primer dimensión del arreglo: caja 1, caja 2 o caja 3), ya sea en el turno mañana o tarde (segunda dimensión: 1 para la mañana o 2 para la tarde) en cada día hábil de una semana (tercera dimensión: 1 lunes, 2 martes, 3 miércoles, 4 jueves o 5 viernes). Si queremos registrar, por ejemplo, que la caja 1 en el turno tarde del día jueves atendió 12 clientes, tenemos que guardar el valor 12 en la posición [1, 2, 4] del arreglo.Para situaciones como la anterior, resulta más útil guardar los valores en otros tipos de estructuras especializadas en conjuntos de datos, como veremos más adelante. Por esta razón, en esta asignatura profundizaremos en el estudio de arreglos multidimensionales y nos bastaremos con vectores y matrices. Sin embargo, debemos saber de su existencia porque son estructuras útiles para ciertas tareas de programación.Por lo tanto, lo siguiente es de lectura opcional. El arreglo de 3 dimensiones que permite acomodar toda la información del ejemplo en una sola estructura puede definirse en pseudocódigo así:Y en R:Luego, si queremos registrar que la caja 1 en el turno tarde del día jueves atendió 12 clientes, hacemos, tanto en R como en pseudocódigo:En R, podemos ponerle un nombre cada una de las dimensiones del arreglo (“caja”, “turno”, “dia”), para poder identificar mejor qué aspecto hace referencia y, su vez, un nombre cada una de sus modalidades (por ejemplo, “caja 1”, “caja 2” o “caja 3”). Esto se logra de la siguiente forma:En lo anterior hemos utilizado una lista, que se trata de otro tipo de estructura de datos definida continuación.","code":"VARIABLE numérica clientes(3, 2, 5)\nclientes <- array(0, dim = c(3, 2, 5))\nclientes, , 1\n\n     [,1] [,2]\n[1,]    0    0\n[2,]    0    0\n[3,]    0    0\n\n, , 2\n\n     [,1] [,2]\n[1,]    0    0\n[2,]    0    0\n[3,]    0    0\n\n, , 3\n\n     [,1] [,2]\n[1,]    0    0\n[2,]    0    0\n[3,]    0    0\n\n, , 4\n\n     [,1] [,2]\n[1,]    0    0\n[2,]    0    0\n[3,]    0    0\n\n, , 5\n\n     [,1] [,2]\n[1,]    0    0\n[2,]    0    0\n[3,]    0    0\nclientes[1, 2, 4] <- 12\nclientes, , 1\n\n     [,1] [,2]\n[1,]    0    0\n[2,]    0    0\n[3,]    0    0\n\n, , 2\n\n     [,1] [,2]\n[1,]    0    0\n[2,]    0    0\n[3,]    0    0\n\n, , 3\n\n     [,1] [,2]\n[1,]    0    0\n[2,]    0    0\n[3,]    0    0\n\n, , 4\n\n     [,1] [,2]\n[1,]    0   12\n[2,]    0    0\n[3,]    0    0\n\n, , 5\n\n     [,1] [,2]\n[1,]    0    0\n[2,]    0    0\n[3,]    0    0\ndimnames(clientes) <- list(caja = c(\"caja 1\", \"caja 2\", \"caja 3\"),\n                           turno = c(\"mañana\", \"tarde\"),\n                           dia = c(\"lun\", \"mar\", \"mie\", \"jue\", \"vie\"))\nclientes, , dia = lun\n\n        turno\ncaja     mañana tarde\n  caja 1      0     0\n  caja 2      0     0\n  caja 3      0     0\n\n, , dia = mar\n\n        turno\ncaja     mañana tarde\n  caja 1      0     0\n  caja 2      0     0\n  caja 3      0     0\n\n, , dia = mie\n\n        turno\ncaja     mañana tarde\n  caja 1      0     0\n  caja 2      0     0\n  caja 3      0     0\n\n, , dia = jue\n\n        turno\ncaja     mañana tarde\n  caja 1      0    12\n  caja 2      0     0\n  caja 3      0     0\n\n, , dia = vie\n\n        turno\ncaja     mañana tarde\n  caja 1      0     0\n  caja 2      0     0\n  caja 3      0     0"},{"path":"estructuras-de-datos.html","id":"listas","chapter":"1 Estructuras de Datos","heading":"1.2 Listas","text":"Una de las principales características de los arreglos es la homegeneidad: todos los elementos que contienen deben ser del mismo tipo. se puede, por ejemplo, mezclar en una matriz valores numéricos y lógicos. Sin embargo, en muchos problemas resulta útil contar con alguna estructura de datos que permita agrupar objetos de diversos tipos. Esa es, justamente, la definición de una lista. Podemos imaginarla como una bolsa en la cual podemos meter todo tipo de objetos, incluyendo vectores, matrices y, por qué , otras bolsas (es decir, bolsas dentro de una bolsa o listas dentro de una lista). Todos los lenguajes de programación proveen algún tipo de estructura con estas características, aunque todos las llaman igual. Otros posibles nombres con los que se conocen pueden ser tupla o agregado. En R se llaman listas o vectores recursivos. El siguiente diagrama presenta una lista (recuadro con puntas redondeadas) que contiene:Un vector numérico de largo 3.Un vector caracter de largo 2.Una matriz numérica de dimensión 2x2.Un valor lógico.\nFigura 1.13: Ejemplo de una lista\nEn R la creación de esta lista se realiza mediante la función list(), cuyos argumentos son los elementos que queremos guardar en la lista, separados por comas:Luego de correr la sentencia anterior, podemos ver que mi_lista es un nuevo objeto disponible en el ambiente global y como tal está listado en el panel Environment. Allí se nos indica que se trata de una lista y, además, podemos previsualizar su contenido al hacer clic en el círculo celeste que antecede su nombre:\nFigura 1.14: La lista en la pestaña Environment de RStudio\nUsamos dobles corchetes [[ ]] para referenciar cada objeto que forma parte de la lista. Además, si queremos indicar un elemento dentro de un objeto que forma parte de la lista, agregamos otro conjunto de corchetes como hacemos con vectores y matrices. Por ejemplo:\nFigura 1.15: Ejemplo de una lista\nPodemos asignar valor algún elemento usando los índices de esa misma forma:medida que las estructuras de datos se hacen más complejas, existen menos convenciones para su representación en pseudocódigo, siendo admisible cualquier expresión que logre comunicar sin ambigüedad las acciones que se deben realizar, incluso la descripción en palabras. La creación de la lista anterior podría ser expresada como:Para asignar valores, podemos usar en pseudocódigo el mismo tipo de notación que en R:Ejemplo: función que devuelve una listaEn el capítulo anterior, dijimos que las funciones son subalgoritmos que podían devolver exactamente un objeto como resultado. Esto puede ser una limitación, ya que en algunos casos tal vez necesitemos devolver varios elementos de distinto tipo\n2\n.\nLa solución consiste en devolver una lista que englobe todos los objetos que nos interese que la función le entregue como resultado al algoritmo principal que la invocó. Como una lista es un único objeto, ¡la función puede devolverla sin ningún problema!Para ejemplificar, recordemos el siguiente ejercicio de la práctica 3: escribir el algoritmo y el programa en R para la creación de la función triangulos(, b, c) que partir de la longitud de los tres lados de un triángulo , b y c (valores positivos) lo clasifica con los siguientes resultados posibles: forman un triángulo (un lado mayor que la suma de los otros dos), triángulo equilátero, isósceles o escaleno. Vamos modificar la función para que tenga el siguiente comportamiento: la función debe devolver el tipo de triángulo como cadena de texto y el valor numérico del perímetro del mismo (o un 0 si es triángulo). Es decir, la función debe devolver tanto un objeto de tipo caracter y otro de tipo numérico. Para lograrlo los encerraremos en una lista:Algoritmo:Código en R:Ejemplos del uso de esta función:","code":"\nmi_lista <- list(\n    c(-4.5, 12, 2.71),\n    c(\"hola\", \"chau\"),\n    matrix(c(8, 11, 13, 16), nrow = 2),\n    TRUE\n)\nmi_lista[[1]]\n[1] -4.50 12.00  2.71\n\n[[2]]\n[1] \"hola\" \"chau\"\n\n[[3]]\n     [,1] [,2]\n[1,]    8   13\n[2,]   11   16\n\n[[4]]\n[1] TRUE\nmi_lista[[1]][1] -4.50 12.00  2.71\nmi_lista[[1]][3][1] 2.71\nmi_lista[[2]][1] \"hola\" \"chau\"\nmi_lista[[2]][2][1] \"chau\"\nmi_lista[[3]]     [,1] [,2]\n[1,]    8   13\n[2,]   11   16\nmi_lista[[3]][2, 1][1] 11\nmi_lista[[4]][1] TRUE\nmi_lista[[4]][1][1] TRUE\nmi_lista[[1]][3] <- 0\nmi_lista[[1]]\n[1] -4.5 12.0  0.0\n\n[[2]]\n[1] \"hola\" \"chau\"\n\n[[3]]\n     [,1] [,2]\n[1,]    8   13\n[2,]   11   16\n\n[[4]]\n[1] TRUEVARIABLE numérica w(3), y(2, 2)\nVARIABLE caracter x(2)\nVARIABLE lógica z\nVARIABLE LISTA mi_lista\nmi_lista <- LISTA(x, w, y, z)mi_lista[[1]][1] <- -4.5\nmi_lista[[1]][2] <- 12\nmi_lista[[1]][3] <- 2.71\nmi_lista[[2]][1] <- \"hola\"\n...\nmi_lista[[4]] <- VERDADERO#-----------------------------------------------------\n# Función triangulos\n# Clasifica un triángulo según la longitud de sus lados\n# Entrada:\n#       - a, b, c, números reales positivos\n# Salida:\n#       - una lista cuyo primer elemento es un caracter que indica el tipo de\n#       triángulo y el segundo elemento es el perímetro del triángulo o el valor 0 si\n#       no los lados provistos no corresponden a un triángulo\n#-----------------------------------------------------\nFUNCIÓN triangulos(a: numérico, b: numérico, c: numérico): lista\nCOMENZAR\n    VARIABLE caracter tipo\n    VARIABLE numérica perimetro\n    SI a > b + c O b > a + c O c > a + b ENTONCES\n        tipo <- \"no es triángulo\"\n        perimetro <- 0\n    SI NO\n        perimetro <- a + b + c\n        SI a == b Y a == c ENTONCES\n            tipo <- \"equilátero\"\n        SI NO\n            SI a == b O a == c O b == c ENTONCES\n                tipo <- \"isósceles\"\n            SI NO\n                tipo <- \"escaleno\"\n            FIN SI\n        FIN SI\n    FIN SI\n    DEVOLVER LISTA(tipo, perimetro)\nFIN FUNCIÓN\n#-----------------------------------------------------\n# Función triangulos\n# Clasifica un triángulo según la longitud de sus lados\n# Entrada:\n#       - a, b, c, números reales positivos\n# Salida:\n#       - una lista cuyo primer elemento es un caracter que indica el tipo de\n#       triángulo y el segundo elemento es el perímetro del triángulo o el valor 0 si\n#       no los lados provistos no corresponden a un triángulo\n#-----------------------------------------------------\ntriangulos <- function(a, b, c) {\n    perimetro <- a + b + c\n    if (a > b + c || b > a + c || c > a + b) {\n        tipo <- \"no es triángulo\"\n        perimetro <- 0\n    } else if (a == b & a == c) {\n        tipo <- \"equilátero\"\n    } else if (a == b || a == c || b == c) {\n        tipo <- \"isósceles\"\n    } else {\n        tipo <- \"escaleno\"\n    }\n    return(list(tipo, perimetro))\n}\n# Guardamos el resultado devuelto (una lista) en el objeto resultado\nresultado <- triangulos(2, 3, 4)\n# Miramos el primer elemento de la lista (caracter que indica el tipo)\nresultado[[1]][1] \"escaleno\"\n# Miramos el primer elemento de la lista (perímetro)\nresultado[[2]][1] 9\n# Miramos todo junto\nresultado[[1]]\n[1] \"escaleno\"\n\n[[2]]\n[1] 9\n# Otro ejemplo:\nresultado2 <- triangulos(2, 3, 10)\nresultado2[[1]][1] \"no es triángulo\"\nresultado2[[2]][1] 0"},{"path":"estructuras-de-datos.html","id":"elementos-con-nombre-lectura-opcional","chapter":"1 Estructuras de Datos","heading":"1.3 Elementos con nombre (lectura opcional)","text":"La presente sección es de lectura opcional, lo cual significa que será necesaria para la resolución de la práctica ni será tenida en cuenta en las evaluaciones.Además de guardar información, los objetos de R pueden poseer ciertos atributos, que consisten en información adicional sobre el objeto. Uno de ellos es el atributo names, que permite que cada elemento dentro de un vector o una lista pueda tener su propio nombre, así como también que cada fila o columna de una matriz tenga su propio nombre, independientemente del nombre general del objeto.","code":""},{"path":"estructuras-de-datos.html","id":"vectores","chapter":"1 Estructuras de Datos","heading":"1.3.1 Vectores","text":"cada elemento de un vector se le puede, opcionalmente, asignar un nombre. Esto se realiza de alguna de estas formas:Opción 1: después de crear el vector\n\n# El vector se llama \"frutas\" y tiene 4 elementos\nfrutas <- c(3, 7, 2, 1)\nfrutas\n[1] 3 7 2 1\n\n# Cada uno de estos elementos tienen nombres\nnames(frutas)\nNULL\n\n# Le doy un nombre cada elemento\nnames(frutas) <- c(\"manzanas\", \"naranjas\", \"bananas\", \"peras\")\nfrutas\nmanzanas naranjas  bananas    peras \n       3        7        2        1 Opción 1: después de crear el vectorOpción 2: en el momento de crear el vector\n\nfrutas <- c(manzanas = 3, naranjas = 7, bananas = 2, peras = 1)\nfrutas\nmanzanas naranjas  bananas    peras \n       3        7        2        1 Opción 2: en el momento de crear el vectorLos nombres son útiles porque permiten indexar al vector, sin necesidad de usar como índice la posición del elemento:todos los elementos de un vector tienen que tener nombre:","code":"\n# El vector se llama \"frutas\" y tiene 4 elementos\nfrutas <- c(3, 7, 2, 1)\nfrutas[1] 3 7 2 1\n# Cada uno de estos elementos no tienen nombres\nnames(frutas)NULL\n# Le doy un nombre a cada elemento\nnames(frutas) <- c(\"manzanas\", \"naranjas\", \"bananas\", \"peras\")\nfrutasmanzanas naranjas  bananas    peras \n       3        7        2        1 \nfrutas <- c(manzanas = 3, naranjas = 7, bananas = 2, peras = 1)\nfrutasmanzanas naranjas  bananas    peras \n       3        7        2        1 \nfrutas[2]naranjas \n       7 \nfrutas[\"naranjas\"]naranjas \n       7 \nfrutas <- c(manzanas = 3, 7, bananas = 2, 1)\nfrutasmanzanas           bananas          \n       3        7        2        1 \nnames(frutas)[1] \"manzanas\" \"\"         \"bananas\"  \"\"        "},{"path":"estructuras-de-datos.html","id":"matrices","chapter":"1 Estructuras de Datos","heading":"1.3.2 Matrices","text":"En el caso de las matrices, se le puede asignar nombres sus filas y columnas:Opción 1: después de crear la matriz\n\nx <- matrix(c( 8, 13, 18, 23, \n              11, 16, 21, 26, \n              14, 19, 24, 29), \n              nrow = 3, byrow = TRUE)\nrownames(x) <- c(\"\", \"B\", \"C\")\ncolnames(x) <- c(\"col1\", \"grupo2\", \"grupo3\", \"grupo4\")\nx\n  col1 grupo2 grupo3 grupo4\n   8     13     18     23\nB   11     16     21     26\nC   14     19     24     29Opción 1: después de crear la matrizOpción 2: al crear la matrizOpción 2: al crear la matrizAl igual que con los vectores, podemos usar los nombres de filas y columnas para indexar:En el caso de los arreglos multidimensionales, ya se indicó en el ejemplo del local comercial el uso de nombres para las distintas dimensiones.","code":"\nx <- matrix(c( 8, 13, 18, 23, \n              11, 16, 21, 26, \n              14, 19, 24, 29), \n              nrow = 3, byrow = TRUE)\nrownames(x) <- c(\"A\", \"B\", \"C\")\ncolnames(x) <- c(\"col1\", \"grupo2\", \"grupo3\", \"grupo4\")\nx  col1 grupo2 grupo3 grupo4\nA    8     13     18     23\nB   11     16     21     26\nC   14     19     24     29\nx <- matrix(c( 8, 13, 18, 23, \n              11, 16, 21, 26, \n              14, 19, 24, 29), \n            nrow = 3, byrow = TRUE,\n            dimnames = list(Categorias = c(\"A\", \"B\", \"C\"), \n                            Grupos = c(\"grupo1\", \"grupo2\", \"grupo3\", \"grupo4\")))\nx          Grupos\nCategorias grupo1 grupo2 grupo3 grupo4\n         A      8     13     18     23\n         B     11     16     21     26\n         C     14     19     24     29En este último ejemplo, se han elegido arbitrariamente los nombres `Categorias` y `Grupos` para llamar al conjunto completo de las filas y de las columnas, respectivamente. Esos nombres pueden ser cambiados por otros.\nx[\"B\", \"grupo2\"][1] 16"},{"path":"estructuras-de-datos.html","id":"listas-1","chapter":"1 Estructuras de Datos","heading":"1.3.3 Listas","text":"Podemos asignarle un nombre uno, algunos o todos los integrantes en una lista:Esto amplía las opciones para hacer referencia cada objeto y elemento allí contenido. Las siguientes sentencias son todas equivalentes y sirven para acceder al tercer elemento de la lista, cuyo nombre es y:","code":"\nmi_lista <- list(\n    w = c(-4.5, 12, 2.71),\n    x = c(\"hola\", \"chau\"),\n    y = matrix(c(8, 11, 13, 16), nrow = 2),\n    z = TRUE\n)\nmi_lista$w\n[1] -4.50 12.00  2.71\n\n$x\n[1] \"hola\" \"chau\"\n\n$y\n     [,1] [,2]\n[1,]    8   13\n[2,]   11   16\n\n$z\n[1] TRUE\nmi_lista[[3]]     [,1] [,2]\n[1,]    8   13\n[2,]   11   16\nmi_lista[[\"y\"]]     [,1] [,2]\n[1,]    8   13\n[2,]   11   16\nmi_lista$y     [,1] [,2]\n[1,]    8   13\n[2,]   11   16"},{"path":"estructuras-de-datos.html","id":"otras-consideraciones-lectura-opcional","chapter":"1 Estructuras de Datos","heading":"1.4 Otras consideraciones (lectura opcional)","text":"Dependiendo de cómo se almacenan los datos que componen una estructura en el hardware de la computadora, las mismas se pueden clasificar en contiguas o enlazadas. En las estructuras contiguas, los datos se sitúan en áreas adyacentes de memoria y cada uno de ellos se puede localizar partiendo de la posición en memoria del primer elemento de la estructura. En las estructuras enlazadas, los datos se sitúan necesariamente de forma continua en la memoria sino que existen punteros (otro tipo de dato que apunta hacia determinada posición de memoria) que permite identificar cuál es el orden de los elementos dentro de la estructura.Por otro lado, las estructuras también se pueden clasificar en dinámicas o estáticas, según si su tamaño puede cambiar o durante la ejecución de un programa, respectivamente. Cuando se emplea una estructura estática, se declara con anterioridad el tamaño que ocupará en memoria y su dimensión podrá variar, aún cuando se ocupen todas las posiciones reservadas. En contraposición, una estructura dinámica puede cambiar en tamaño.Antes se mencionó que las listas de R pueden contener objetos de distintos tipos. Para ser más rigurosos, una lista es un tipo especial de vector que agrupa punteros hacia distintos objetos. Técnicamente, todos los elementos de una lista son del mismo tipo (punteros), pero hacen referencia distintos objetos, dándonos la impresión de que en una lista de R, sencillamente, podemos meter cualquier tipo de objeto.","code":""}]

# Uso de archivos de datos

## Introducción

Como hemos visto, los programas usan variables para guardar información: datos de entrada, resultados calculados, valores intermedios, etc. Sin embargo, la información guardada en las variables es efímera. Cuando los programas paran de correr, el valor almacenado en las variables se pierde. En muchas ocasiones, es necesario guardar información de una forma más permanente.

En estos casos, el enfoque usual es recolectar la información en un todo lógicamente cohesivo y guardarlo en un medio permanente que generalmente se graba en el disco rígido de la máquina, es decir, en un archivo. Un **archivo** o **fichero** es un conjunto de información sobre un mismo tema tratado como una unidad de almacenamiento y organizado de forma estructurada para la búsqueda de un dato individual. Los archivos pueden contener instrucciones de programas o información creada o usada por un programa. Todos los objetos de datos permanentes que guardamos en nuestra computadora (documentos, juegos, programas ejecutables, código, etc.) son guardados en la forma de archivos.

Un archivo se identifica con un **nombre**, seguido por un *punto* y una **extensión**, la cual es un sufijo empleado para indicar características de su contenido, el uso pretendido o el software con el cual puede ser empleado. Por ejemplo, un archivo que se llama *planilla.xlsx* es una hoja de cálculo de Excel o un archivo llamado *codigo.R* es un script de código de R.

### Registros, campos, claves y bases de datos

En esta asignatura nos limitaremos a trabajar con archivos que guardan información de forma tabular, en los que la unidad elemental que los compone es un **registro**, es decir, una colección de información relativa a una misma entidad. En general, cada registro de un mismo archivo tiene la misma estructura que los demás. Los datos individuales sobre dicha entidad se organizan en **campos**. Un **campo** es la mínima unidad de información de un registro. 

Para ejemplificar, trabajaremos con un archivo llamado *mundiales.txt* que tiene datos sobre todos los mundiales de fútbol de la FIFA, incluyendo el del año 2022, en el cual nuestra selección argentina conquistó su tercer título. Cada fila del conjunto de datos corresponde a un país y cada columna hace referencia a las siguientes variables^[Los partidos definidos en tiempo complementario se cuentan como victorias y derrotas, mientras que los partidos definidos por tandas de penales se cuentan como empates.]: 

```
ARCHIVO: mundiales.txt
Campo 1 - seleccion: nombre del país, tipo carácter
Campo 2 - continente: continente al que pertenece el país, tipo carácter
Campo 3 - participaciones: cantidad de mundiales jugados, tipo numérico
Campo 4 - pg: cantidad de partidos ganados, tipo numérico
Campo 5 - pe: cantidad de partidos empatados, tipo numérico
Campo 6 - pp: cantidad de partidos perdidos, tipo numérico
Campo 7 - gf: cantidad de goles a favor, tipo numérico
Campo 8 - gf: cantidad de goles en contra, tipo numérico
Campo 9 - titulo: cantidad de mundiales ganados, tipo numérico
```

Este archivo tiene 80 registros, ya que son 80 países los que han disputado algún mundial a lo largo de la historia. Los primeros registros lucen así:

| seleccion | continente | participaciones | pg | pe | pp |  gf |  gc | titulos |
|:---------:|:----------:|:---------------:|:--:|:--:|:--:|:---:|:---:|:-------:|
| Brasil    | América    |              22 | 76 | 19 | 19 | 237 | 108 |       5 |
| Alemania  | Europa     |              20 | 68 | 21 | 23 | 232 | 130 |       4 |
| Argentina | América    |              18 | 47 | 17 | 24 | 152 | 101 |       3 |
| Italia    | Europa     |              18 | 45 | 21 | 17 | 128 |  77 |       4 |
| Francia   | Europe     |              16 | 39 | 14 | 20 | 136 |  85 |       2 |

<br>

Un campo está caracterizado por el tipo de datos que almacena (carácter, numérico, lógico) y en algunos contextos es necesario precisar su longitud (por ejemplo, cantidad de caracteres admitidos como máximo en los datos del campo). Algunos lenguajes, como R, admiten trabajar con campos de longitud variable (sin necesidad de que sea especificada con anticipación).

En el contexto del análisis de datos, cada columna o *campo* en este tipo de archivos puede representar una variable observada sobre los individuos o unidades de interés, los cuales se encuentran dispuestos en las sucesivas filas. 

Generalmente suele ser necesario identificar de manera única a cada registro de un archivo. Para esto suele considerarse a uno de los campos del archivo como el **campo clave** o, más sencillamente, **clave**. La **clave** o *key* es el campo que identifica inequívocamente a cada registro, permitiendo diferenciarlo del resto, como podría ser el nombre de la selección en el ejemplo anterior. En ocasiones donde no hay un campo *clave* es posible identificar un registro a través de la combinación de los valores presentes en más de uno de los campos.

Por último, cabe mencionar que llamamos **base de datos** a un conjunto de archivos que contienen datos relacionados entre sí, vinculados mediante sistemas complejos que enlazan las claves de uno y otro archivo y que pueden ser consultados mediante el uso de software especializado. Por eso, cuando trabajamos con los datos almacenados en un único archivo, es conveniente referirse a los mismos como "conjunto de datos" y no como "base de datos".

### Organización de archivos

Existen distintos tipos de organización de los archivos según la forma en la que se pueda acceder a cada uno de sus registros:

- **Organización secuencial**

  Los registros se encuentran en cierto orden que debe ser respetado para la lectura de los mismos. Para leer el registro situado en la posición *n*, el programa previamente tiene que pasar por los *n-1* registros que ocupan las posiciones anteriores. 
  
   Los archivos de tipo secuencial en general ocupan menos memoria y suelen ser utilizados para guardar contenidos que sufren pocas modificaciones. Los registros se graban consecutivamente en el soporte que los aloja (por ejemplo, en el disco). El orden físico con el que fueron escritos los registros coincide con el orden de lectura de los mismos.
   
   Los registros pueden leerse uno por uno hasta llegar al final del archivo, donde se indica de alguna manera el fin del mismo, muchas veces a través de un caracter especial como un asterisco o de una línea en blanco. Esta marca generalmente se conoce como *EOF* (*end of file*). La mayoría de los lenguajes de programación disponen de una función lógica que devuelve un valor `VERDADERO` cuando se alcanza el final del archivo. 
   
  <!-- Los archivos de tipo secuencial en general ocupan menos memoria, su uso no requiere establecer con anterioridad la cantidad de registros a almacenar y suelen ser utilizados para guardar contenidos que sufren pocas modificaciones. -->

- **Organización directa**

  Son archivos que están organizados de manera que se pueda acceder de forma directa a cada registro mediante su posición en el soporte físico que lo contiene, sin tener que pasar secuencialmente por los registros anteriores. Poseen la ventaja de brindar un acceso rápido a la información y la posibilidad de leer y escribir registros en cualquier posición y orden.
  
  Se puede mencionar como desventaja de este tipo de organización el hecho de que requiere la programación de la forma de identificar la posición de un registro a partir de alguno de los valores de sus campos, generalmente, la *clave*. Esto se hace mediante un algoritmo de transformación de la clave (llamado *hash function*) que a partir de la misma devuelve la dirección del registro en el soporte físico. El archivo debe diseñarse teniendo en cuenta de antemano una cantidad total de registros fija.
  
- **Organización indexada**

  Los archivos están estructurados de manera que los registros se pueden localizar sin pasar por los anteriores, consultando en una tabla adicional de índices la zona del archivo donde se encuentra el registro buscado. Esto permite localizar un registro por medio de su clave o del valor de algún campo en particular.
  
  Para imaginarnos esto, podemos pensar que un diccionario es un ejemplo de un archivo indexado, ya que podemos encontrar la región donde se encuentra un registro (palabra) mediante el índice de letras. Si queremos buscar el término "programación" en un diccionario, no recorremos todas las palabras del mismo desde la "A" hasta encontrar el término de interés, sino que buscamos en el índice en qué página del diccionario se encuentra la "P" y comenzamos una búsqueda secuencial desde la misma.
  
  Un archivo indexado, entonces, cuenta en realidad con dos archivos, uno de índices (que se recorre de forma secuencial) y otro con los registros propiamente dichos. Posee la ventaja de brindar un rápido acceso a los registros, pero con el costo de utilizar espacio adicional para la tabla de índices.

La organización más sencilla y más comúnmente empleada es la **secuencial**, aunque en algunos casos puede no ser la más eficiente. Si bien no todos los lenguajes de programación permiten el trabajo con archivos indexados o de organización directa, todos pueden manejar archivos secuenciales. 

En este curso no profundizaremos en esta distinción y trabajaremos  con archivos guardados como documentos de Excel (extensión *.xlsx*) o archivos de texto (extensión *.txt* o *.csv*), los cuales siguen una organización secuencial.

Un **archivo de texto** (también conocido como *texto llano* o *texto simple*) es un archivo informático que contiene únicamente texto formado por una secuencia ordenada de caracteres. El texto almacenado en este tipo de archivo carece de cualquier tipo de formato tipográfico (negrita, cursiva, colores, subrayado, fuente, etc.), lo cual permite que una gran variedad de programas pueda leer y editar el contenido. Cada renglón en el archivo de texto es un registro y los distintos campos suelen estar señalizados con tabulaciones (archivos *.txt*, como el que usaremos de ejemplo, *mundiales.txt*) o separados por comas o punto y comas (archivos *.csv*).

Los archivos de texto están compuestos por caracteres ordinarios, como las letras, números y signos de puntuación, y por caracteres especiales que indican, por ejemplo, saltos de línea (`\n`) y tabulaciones (`\t`). Pero como en realidad las computadoras solamente entienden números, cada carácter es codificado internamente con una representación numérica binaria, que nosotros nunca llegamos a ver. Distintas maneras de hacer esta representación dan lugar a diferentes formatos de codificación de caracteres (como *ASCII*, *ISO-8859-1* o *UTF-8*). Si en alguna oportunidad abrimos un archivo y nos percatamos que caracteres como la "ñ" o las tildes han sido reemplazadas por otros produciendo un aspecto "raro", significa que el archivo ha sido abierto empleando una codificación diferente de la que se utilizó al crear el archivo. La solución para este problema es muy sencilla, sólo hay que cambiar la opción de codificación a la hora de guardar o de abrir el archivo.

### Operaciones sobre archivos

El uso de archivos en programación es muy importante ya que nos permite leer datos para hacer algún tipo de procesamiento y también guardar resultados obtenidos. El sistema operativo de la computadora es el que se encarga de manipular los archivos para que podamos leerlos o escribir en ellos, pero debemos aprender las sentencias que el lenguaje de programación elegido utiliza para encargarle esas tareas al sistema operativo. Los procedimientos básicos que los programas pueden llevar a cabo sobre los distintos tipos de archivos son:

- **Creación de un archivo**: para que un archivo pueda ser utilizado, antes tiene que existir, obviamente. Una vez que el archivo de datos fue creado y existe, se pueden hacer con él las restantes operaciones. En la mayoría de las aplicaciones que veremos, tendremos archivos que han sido creados con anterioridad y ya tienen registros, por lo cual usaremos pocas veces esta acción, pero eventualmente crearemos nuevos archivos para guardar nuevas versiones del conjunto de datos o para guardar resultados en otro tipo de documento. 

- **Apertura de un archivo**: para que un programa pueda operar sobre un archivo, la primera acción que debe realizar es la **apertura** del mismo, que incluye la identificación del archivo a utilizar y el modo (lectura o escritura). Esto hace que el sistema operativo establezca una *conexión* con el archivo que mientras se mantenga activa permitirá la lectura y escritura de registros en el mismo. Dependiendo del lenguaje de programación o de las subsiguientes operaciones a realizar, en algunos casos la apertura tiene que ser indicada con alguna instrucción de manera explícita y en otros, no.
	
- **Lectura de registros en un archivo**: la **lectura** consiste en transferir información del archivo a la memoria principal usada por el programa. En los archivos de organización secuencial, los registros se leen uno por uno, es decir, línea por línea, hasta llegar al final del archivo. Sin embargo, en la aplicaciones que nos interesan, el software se encarga de leer automáticamente todos los registros y almacenarlos en alguna estructura de datos especializada que definamos en el ambiente de trabajo.

- **Escritura en un archivo**: la **escritura** es la transferencia de información guardada en las variables del programa al archivo.

- **Cierre de un archivo**: cuando un programa no vaya a acceder más a un archivo, es necesario indicarlo a través del **cierre** del mismo, para que se interrumpa la conexión establecida por el sistema operativo. Esto hace que se liberen memoria y recursos del sistema, se prevenga la corrupción de los datos y se exprese explícitamente que ya no se hará más uso del mismo. En algunos lenguajes o para determinadas tareas, esto puede no ser necesario.

- **Otras operaciones**: ptras operaciones que se pueden realizar sobre los archivos, en base a combinaciones de las anteriores, incluyen a las acciones de:

	- *Actualización*: añadir (dar de alta), modificar o eliminar (dar de baja) algún registro.
	- *Clasificación*: reubicar los registros de tal forma que queden ordenados por algún campo determinado.
	- *Fusión o mezcla*: combinar dos o más archivos para formar uno nuevo.
	- *Partición*: subdividir los registros por el valor que toman en algún campo para generar más de un archivo.

## Lectura de los registros del archivo

- Llegó el momento de cargar los datos sobre las ventas en R a partir del archivo `insumos.xlsx`.
- RStudio provee ayuda para importar datos en el botón `Import Dataset` en el panel superior derecho.

```{r, fig.show='hold', echo=FALSE, fig.align="center", out.width='30%'}
knitr::include_graphics('Plots/importar1.png')
```

- RStudio nos despliega una batería de opciones para la importación: tenemos opciones para importar archivos de Excel y otros programas (SAS, SPSS, Stata), y también desde archivos de texto.

```{r, fig.show='hold', echo=FALSE, fig.align="center", out.width='100%', eval=F}
knitr::include_graphics('Plots/importar2.png')
```

- La primera vez que se realiza esto, puede que RStudio pida permiso para instalar o actualizar algunos paquetes. Si es así, le damos permiso.

- Vamos a mostrar en clase cómo trabajar con este panel, pero tené en cuenta lo siguiente: este modo de importar datos nos muestra cuáles son las líneas de código que podríamos ejecutar en la consola para obtener el mismo resultado.

- Es bueno que las copiemos y guardemos en nuestro script, para que este paso también quede documentado. *Un script sin las sentencias de importación de datos está incompleto...*

- Al tener dichas líneas guardadas en el script, la próxima vez que necesitemos importar este archivo podemos hacerlo automáticamente al ejecutarlas.

- Las sentencias generadas para este caso son:

	```{r, eval=FALSE}
	library(readxl)
	datos <- read_excel("C:/Usuario/Datos/insumos.xlsx")
	```

- Una vez que los datos fueron importados, aparecerán bajo el nombre elegido en el panel `Environment` y podemos visualizarlos haciendo clic sobre el mismo. 


En [este enlace](https://github.com/mpru/introprog/tree/master/archivos) o en el aula virtual podrás encontrar el archivo de datos. 


Ya hemos mencionado que R se organiza mediante un sistema de paquetes, algunos de los cuales vienen instalados con la distribución básica de R, mientras que otros deben ser instalados si tenés el particular interés de usarlos. R Base trae muchas funciones útiles para la importación de datos, así como para las subsiguientes tareas de manejo, transformación y resumen. Sin embargo, en este curso aprenderemos a emplear una familia de paquetes conocida como [**tidyverse**](https://www.tidyverse.org), creados para la manipulación, exploración y visualización de datos con un diseño, estructuras y reglas de uso en común, que resultan muy amigables para programar. 
  
```{r, echo=FALSE, out.width = "70%"}
knitr::include_graphics('images/06_archivos/tidyverse.png')
```

Instalamos esta colección de paquetes con:

```{r, eval=FALSE}
install.packages("tidyverse")
```

Lo anterior se realiza una sola vez. Luego, cada vez que queramos usar este sistema, usamos `library()` para que queden a nuestra disposición las funciones provistas por los paquetes más importantes de esta gran familia:

```{r}
library(tidyverse)
```

El *tidyverse* provee una función de uso muy sencillo para leer datos guardados en un archivo de texto con campos separados por tabulaciones, como es el caso de `mundiales.txt`. 

```{r, eval=FALSE}
datos <- read_delim("/home/marcos/GitProjects/introprog/archivos/mundiales.txt")
```

En la instrucción anterior se informó la ruta completa hasta la ubicación del archivo en la computadora. Si el *working directory* está seteado en la carpeta donde reside el archivo, no es necesario proveer la ruta completa, como ya sabemos.

```{r EVAL = TRUE, echo = FALSE}
datos <- read.delim("archivos/mundiales.txt")
```

Si tenemos que importar otro tipo de archivo (por ejemplo, de Excel o de texto separado con comas) y no nos acordamos cuál es la función que permite hacerlo, podemos recurrir al menú de importación de datos mediante el botón `Import Dataset` en el panel `Environment` de RStudio (arriba a la derecha). Ahí podremos elegir distintas opciones para la importación y automáticamente se generará y ejecutará el código de R necesario, el cual debemos copiar y pegar en nuestro *script* para dejar sentado cómo se realizó la importación.

```{r, fig.show='hold', echo=FALSE, fig.align="center", out.width='30%'}
knitr::include_graphics('images/06_archivos/importar1.png')
```

Una vez completado este paso, en el ambiente podremos ver listado un nuevo objeto llamado `datos`, ya que ese es el nombre que elegimos como identificador para el conjunto de datos devuelto por la función `read_delim()`. Allí también vemos una breve descripción que nos dice que `datos` tiene 80 observaciones (registros) de 9 variables (campos). Si hacemos clic sobre el nombre del objeto se abrirá una pestaña para que podamos explorar su contenido. Entonces... ¿qué tipo de objeto es `datos`?:

```{r}
class(datos)
```

Hasta ahora habíamos trabajado con tres tipos de datos básicos: numérico, carácter y lógico, y habíamos visto que con los mismos podíamos crear estructuras de datos como vectores, matrices o listas. Como indica la salida anterior, el objeto `datos` es de tipo `data.frame`, lo cual significa que es una estructura de datos bidimensional (como una matriz) en la cual cada fila representa a un registro y cada columna representa a uno de los campos del archivo, pudiendo entonces almacenar valores de distinto tipo en cada una de ellas (a diferencia de los arreglos, cuyos valores son todos homogéneos)^[Internamente, un `data.frame` es sencillamente una lista, compuesta por vectores de distinto tipo que tienen todos el mismo largo y que se organizan como columnas. Además, esta lista es almacenada junto con cierta información adicional (*atributos*) que nos permiten manipularla como una estructura tabular.].

Existen algunas funciones de R que nos permiten explorar el contenido de un `data.frame`:

```{r}
# Muestra los nombres de las columnas (campos del archivo)
names(datos)

# Muestra la "estructura" interna del dataset
str(datos)

# Muestra la cantidad de filas y columnas
dim(datos)

# Muestra la cantidad de filas
nrow(datos)

# Muestra la cantidad de columnas
ncol(datos)

# Muestra los primeros registros
head(datos)

# Muestra los últimos registros
tail(datos)

# Muestra un resumen de cada campo
summary(datos)
```

## Manejo de datos

## Resumen de datos

## Creación de archivos para la escritura de resultados


# PENDIENTE

Inventamos un pequeño conjunto de datos de ejemplo con la estructura de los `data.frames` de R:

```{r}
mis_datos <- data.frame(
    altura = c(181, 165, 149, 178),
    peso = c(85, 65, 52, 72),
    edad = c(29, 27, 21, 32)
)
mis_datos
```

Un `data.frame` puede ser indexado de la misma forma empleada con matrices, por ejemplo:

```{r}
mis_datos[3:4, c(1, 3)]
mis_datos[3:4, c("altura", "edad")]
```

Para hacer referencia a una variable dentro del `data.frame`, empleamos la estructura `dataset$variable`. Por ejemplo:

```{r}
mis_datos$altura
```

Lo anterior resulta en un vector, con el que se pueden hacer operaciones como buscar el valor mínimo:

```{r}
min(mis_datos$altura)
```


Una vez que los registros fueron leídos y almacenados en el dataset, podemos hacer referencia a cada uno de ellos utilizando *índices* como lo hacemos con las matrices. Por ejemplo, `datos[3, 4]` hace referencia al valor correspondiente al cuarto campo en el tercer registro.


Detalles de lectura opcional:


- Importar un archivo no es la única forma de crear un `data.frame`, también se puede crear uno de forma "manual", por ejemplo:

	```{r}
	mis_datos <- data.frame(
		nombre = c("Ale", "Marti", "Edu"),
		edad = c(21, 20, 22)
	)
	mis_datos
	```


## Creación de archivos y escritura de resultados

Anteriormente hemos mencionado que cuando trabajamos con archivos podemos realizar acciones tanto de lectura como de escritura, aunque hasta el momento nos hemos limitado a leer registros de un archivo. En este apartado presentamos cómo crear un archivo de texto desde R, de manera que pueda utilizarse para escribir y guardar allí los resultados obtenidos.

### Crear un archivo para guardar resultados

Imaginemos que en el problema del hotel, en lugar de mostrar los resultados en la consola, queremos volcarlos en un archivo de texto llamado `resultados.txt`.

En R, la función `sink()` permite escribir en un archivo de texto todos los resultados que habitualmente vemos en la consola. Sus argumentos son:

- `file`: nombre del archivo, si no existe será creado. Se guarda en el directorio de trabajo actual, a menos que indiquemos aquí la ruta completa hacia otra carpeta.
- `append`: si el archivo ya existía, por default lo sobreescribe (borra lo anterior), a menos que indiquemos `append = TRUE` para que agregue nuevas línea sin borrar nada.
- `split`: por default mientras la conexión al archivo está activa, los resultados que enviamos al mismo no se muestran en la consola de R, a menos que indiquemos `split = TRUE`, en cuyo caso sucederán ambas cosas: los resultados serán escritos en el archivo y se verán en la consola.

Cuando se desea cerrar la conexión al archivo, se debe correr `sink()` sin ningún argumento. Todo lo que *imprimamos* con `cat()` entre ambos llamados a `sink()` se guardará en el archivo. La última parte del código en el problema anterior debe ser:

```{r, eval=FALSE}
# Crear conexión al archivo de resultados y poner un encabezado
sink(file = "salida.txt", append = TRUE, split = TRUE)
cat("==========================================\n")
cat("            ARCHIVO DE RESULTADOS         \n")
cat("==========================================\n\n")

# a) Mostrar la tabla
cat("Número de reservas durante el 2021 según mes y tipo de habitación\n")
cuadro

# b) Determinar el total de pernoctaciones en el hotel durante el 2021
cat("\nEl número total de pernoctaciones en el hotel durante el 2021 fue", pernoc, "\n\n")

# c) Determinar cuál fue el mes de mayor cantidad de reservas
res <- maximo(total_fila)
cat("El mes de mayor cantidad de reservas fue", meses[res[2]], "con", 
    res[1], "reservas.\n\n")

# d) Determinar para cada tipo de habitación el mes con menor número de reservas
for (j in 1:3) {
	res <- minimo_matriz_col(tabla, j)
	cat("Para las habitaciones de tipo", tipos[j], 
	    "el mes con menor\n     número de reservas fue", 
	    meses[res[2]], "con", res[1], "reservas.\n")
}

# Cerrar conexión al archivo
sink()
```

### Crear un archivo para guardar conjuntos de datos, todos los registros juntos

Si bien lo anterior sigue la estructura planteada en el pseudocódigo, R provee una gran variedad de funciones para guardar todo el contenido de un objeto de tipo `data.frame` en un archivo de una sola vez, como se muestra en los ejemplos que siguen, en los cuales suponemos que deseamos guardar el contenido de un `data.frame` llamado `mis_datos` en un archivo llamado `mi_archivo`:

```{r, eval=FALSE}
# Guardarlo en un archivo de texto separado por tabulaciones
write.table(mis_datos, "mi_archivo.txt", quote = FALSE, row.names = FALSE, sep = "\t")

# Guardarlo en un archivo de texto separado por comas
write.csv(mis_datos, "mi_archivo.txt", quote = FALSE, row.names = FALSE)

# Guardarlo en un archivo de Excel
# install.packages("writexl")
library(writexl)
write_xlsx(mis_datos, "mi_archivo.xlsx")
```

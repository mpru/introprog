[{"path":"index.html","id":"bienvenida","chapter":"Bienvenida","heading":"Bienvenida","text":"¡Les damos la bienvenida la asignatura Introducción la Programación en la Facultad de Ciencias Económicas y Estadística, Universidad Nacional de Rosario! La presente guía resume los conceptos más importantes que vamos desarrollar. La misma irá siendo revisada, completada y actualizada lo largo del cuatrimestre y está exenta de presentar errores o expresar ideas que puedan ser mejoradas. Avisanos si encontrás algo que deba ser cambiado. ¡Esperamos que juntos podamos pasarla bien al dar nuestros primeros pasos en la programación!Este material fue escrito por el Mgs. Lic. Marcos Prunello (profesor titular) y revisado por los integrantes de la cátedra, Tec. César Mignoni y Lic. Maite San Martín.","code":""},{"path":"introducción-a-la-programación.html","id":"introducción-a-la-programación","chapter":"1 Introducción a la Programación","heading":"1 Introducción a la Programación","text":"","code":""},{"path":"introducción-a-la-programación.html","id":"qué-es-la-programación","chapter":"1 Introducción a la Programación","heading":"1.1 Qué es la programación","text":"Las computadoras son una parte esencial de nuestra vida cotidiana. Casi todos los aparatos que usamos tienen algún tipo de computadora capaz de ejecutar ciertas tareas: lavarropas con distintos modos de lavado, consolas de juegos para momentos de entretenimiento, calculadoras súper potentes, computadoras personales que se usan para un montón de propósitos, teléfonos celulares con un sinfín de aplicaciones y miles de cosas más.Todos estos dispositivos con computadoras de distinto tipo tienen algo en común: alguien “les dice” cómo funcionar, es decir, les indica cuáles son los pasos que deben seguir para cumplir una tarea. De eso se trata la programación: es la actividad mediante la cual las personas le entregan una computadora un conjunto de instrucciones para que, al ejecutarlas, ésta pueda resolver un problema. Quienes realizan esta actividad reciben el nombre de programadores. Sin las personas que las programen, las computadoras dejan de ser útiles, por más complejos que sean estos aparatos. Los conjuntos de instrucciones que reciben las computadoras reciben el nombre de programas.La programación es un proceso creativo: en muchas ocasiones la tarea en cuestión puede cumplirse siguiendo distintos caminos y el programador es el que debe imaginar cuáles son y elegir uno. Algunos de estos caminos pueden ser mejores que otros, pero en cualquier caso la computadora se limitará seguir las instrucciones ideadas por el programador.Desafortunadamente, las computadoras entienden español ni otro idioma humano. Hay que pasarles las instrucciones en un lenguaje que sean capaces de entender. Para eso debemos aprender algún lenguaje de programación, que es más que un lenguaje artificial compuesto por una serie de expresiones que la computadora puede interpretar. Las computadoras interpretan nuestras instrucciones de forma muy literal, por lo tanto la hora de programar hay que ser muy específicos. Es necesario respetar las reglas del lenguaje de programación y ser claros en las indicaciones provistas.Ahora bien, ¿por qué debemos estudiar programación en la Licenciatura en Estadística? La actividad de los profesionales estadísticos está atravesada en su totalidad por la necesidad de manejar con soltura herramientas informáticas que nos asisten en las distintas etapas de nuestra labor, desde la recolección y depuración de conjuntos de datos, pasando por la aplicación de distintas metodologías de análisis, hasta la comunicación efectiva de los resultados. Por eso, en la asignatura Introducción la Programación estudiaremos los conceptos básicos de esta disciplina, fomentando la ejercitación del pensamiento abstracto y lógico necesario para poder entendernos hábilmente con la computadora y lograr que la misma realice las tareas que necesitamos.Para poner en práctica los conceptos sobre Programación que aprenderemos, vamos emplear un lenguaje que ha sido desarrollado específicamente para realizar tareas estadísticas, llamado R. Sin embargo, debemos resaltar que éste es un curso sobre R, es decir, nos dedicaremos aprender las herramientas que este lenguaje brinda para el análisis de datos. De hecho, frente variados problemas vamos dedicarnos crear soluciones que ya existen y están disponibles en R, pero lo haremos con el fin de utilizar dicho lenguaje para aprender y ejercitar nociones básicas de programación.","code":""},{"path":"introducción-a-la-programación.html","id":"una-breve-reseña-histórica-sobre-la-programación","chapter":"1 Introducción a la Programación","heading":"1.2 Una breve reseña histórica sobre la programación","text":"La historia de la programación está vinculada directamente con la de la computación. Esta palabra proviene del latín computatio, que deriva del verbo computare, cuyo significado es “enumerar cantidades”. Computación, en este sentido, designa la acción y efecto de computar, realizar una cuenta, un cálculo matemático. De allí que antiguamente computación fuese un término usado para referirse los cálculos realizados por una persona con un instrumento expresamente utilizado para tal fin (como el ábaco, por ejemplo) o sin él. En este sentido, la computación ha estado presente desde tiempos ancestrales, sin embargo debemos remontarnos al siglo XVII para encontrar los primeros dispositivos diseñados para automatizar cómputos matemáticos.En 1617 el matemático escocés John Napier (el mismo que definió los logaritmos) inventó un sistema conocido como los huesos de Napier o huesos neperianos que facilitaba la tarea de multiplicar, dividir y tomar raíces cuadradas, usando unas barras de hueso o marfil que tenían dígitos grabados. Esta fue la base para otras ideas más avanzadas, entre ellas la que dio origen la primera calculadora mecánica, inventada por el alemán Wilhelm Schickard en 1623, capaz de realizar cómputos aritméticos sencillos funcionando base de ruedas y engranajes. Se componía de dos mecanismos diferenciados, un ábaco de Napier de forma cilíndrica en la parte superior y un mecanismo en la inferior para realizar sumas parciales de los resultados obtenidos con el aparato de la parte superior. Fue llamado reloj calculador. partir de aquí se fueron desarrollando otros modelos, todos ellos teniendo en común el hecho de ser puramente mecánicos, sin motores ni otras fuentes de energía. El operador ingresaba números ubicando ruedas de metal en posiciones particulares y al girarlas otras partes de la máquina se movían y mostraban el resultado. Algunos ejemplos son las calculadoras del inglés William Oughtred en 1624, de Blaise Pascal en 1645 (llamada pascalina), la de Samuel Morland en 1666 y las de Leibniz, en 1673 y 1694.\nFigura 1.1: De izquierda derecha: los huesos de Napier (Museo Arqueológico Nacional de España), el reloj calculador de Schickard (Museo de la Ciencia de la Universidad Pública de Navarra) y una pascalina del año 1952\nEl siglo XVIII trajo consigo algunos otros diseños, pero un gran salto se dio comienzos del siglo XIX de mano de un tejedor y comerciante francés, Joseph Jacquard. En 1801 creó un telar que tenía un sistema de tarjetas perforadas para controlar las puntadas del tejido, de forma que fuera posible programar una gran diversidad de tramas y figuras. Sin saberlo, Jacquard sentó una idea fundamental para la creación de las computadoras.\nFigura 1.2: Un telar de Jacquard y sus tarjetas perforadas en el Museo de la ciencia y la industria en Mánchester.\nEn 1822 el matemático británico Charles Babbage publicó un diseño para la construcción de una máquina diferencial, que podía calcular valores de funciones polinómicas mediante el método de las diferencias. Este complejo sistema de ruedas y engranajes era el primero que podía trabajar automáticamente utilizando resultados de operaciones previas. Si bien el diseño era viable, por motivos técnicos y económicos lo pudo concretar (sólo construyó un modelo de menor escala). Sin embargo, Babbage se dio por vencido y en 1837 presentó el diseño de una máquina analítica, un aparato capaz de ejecutar cualquier tipo de cálculo matemático y que, por lo tanto, se podría utilizar con cualquier propósito. Tal como el telar de Jacquard, la operación de esta máquina sería controlada por un patrón de perforaciones hechas sobre una tarjetas que la misma podría leer. Al cambiar el patrón de las perforaciones, se podría cambiar el comportamiento de la máquina para que resuelva diferentes tipos de cálculos. Para la salida de resultados, la máquina sería capaz de perforar tarjetas. Además, funcionaría con un motor vapor y su tamaño hubiese sido de 30 metros de largo por 10 de ancho. Si bien Babbage tampoco llegó concretar en vida este diseño que dejó plasmado en más de 300 dibujos y 2200 páginas por motivos políticos, se lo considera como la primera conceptualización de lo que hoy conocemos como computadora, por lo cual Babbage es conocido como el padre de la computación.En 1843 Lady Ada Lovelace, una matemática y escritora británica, publicó una serie de notas sobre la máquina analítica de Babbage, en las que resaltaba sus potenciales aplicaciones prácticas, incluyendo la descripción detallada de tarjetas perforadas para que sea capaz de calcular los números de Bernoulli. Al haber señalado los pasos para que la máquina pueda cumplir con estas y otras tareas, Ada es considerada actualmente como la primera programadora del mundo, pesar de que en la época fue tomada en serio por la comunidad científica, principalmente por su condición de mujer.\nFigura 1.3: Charles Babbage, Ada Lovelace y el algoritmo que publicó Ada para calcular los números de Bernoulli con la máquina analítica de Charles.\nLa utilidad de las tarjetas perforadas quedó confirmada en 1890, cuando Herman Hollerith las utilizó para automatizar la tabulación de datos en el censo de Estados Unidos. Las perforaciones en determinados lugares representaban información como el sexo o la edad de las personas, logrando que se pudieran lograr clasificaciones y conteos de forma muy veloz. Así, se tardaron sólo 3 años en procesar la información del censo, cinco años menos que en el anterior de 1880. Con el fin de comercializar esta tecnología, Hollerith fundó una compañía que terminaría siendo la famosa International Business Machine (IBM), empresa líder en informática hasta el día de hoy.Sin embargo, la visión de Babbage de una computadora programable se hizo realidad hasta los años 1940, cuando el advenimiento de la electrónica hizo posible superar los dispositivos mecánicos existentes. John Atanasoff y Clifford Barry (Iowa State College, Estados Unidos) terminaron en 1942 en Iowa State College (Estados Unidos) una computadora electrónica capaz de resolver sistemas de ecuaciones lineales simultáneas, llamada ABC (por “Atanasoff Berry Computer”). La misma contaba con 300 tubos de vacío, unas bombillas de vidrio con ciertos componentes que podían recibir y modificar una señal eléctrica mediante el control del movimiento de los electrones produciendo una respuesta, que habían sido presentados por primera vez en 1906 por el estadounidense Lee De Forest. La ABC dio comienzo la conocida como la primera generación de computadoras basadas en el empleo de tubos de vacío.La primera computadora electrónica de propósito general fue la ENIAC, Electronic Numerical Integrator Computer, completada por Presper Eckert y John Mauchly en la Universidad de Pensilvania. Podía realizar cinco mil operaciones aritmética por segundo y tenía más de 18000 tubos de vacío, ocupando una sala de 9x15 metros en un sótano de la universidad donde se montó un sistema de aire acondicionado especial.Ni la ABC ni la ENIAC eran reprogramables: la ABC servía el propósito específico de resolver sistemas de ecuaciones y la ENIAC era controlada conectando ciertos cables en un panel, lo que hacía muy compleja su programación. El siguiente gran avance se produjo en 1945, cuando el matemático húngaro-estadounidense John von Neumann (Universidad de Princeton) propuso que los programas, es decir, las instrucciones para que la máquina opere, y también los datos necesarios, podrían ser representados y guardados en una memoria electrónica interna. Así nació el concepto de programa almacenado (o stored-program), en contraposición con el uso de tableros de conexiones y mecanismos similares de los modelos vigentes. Los creadores de la ENIAC, bajo la consultoría de von Neumann, implementaron esto en el diseño de su sucesora, la EDVAC, terminada en 1949.\nTambién ya había experimentado con esta idea el alemán Konrad Zuse, quien entre 1937 y 1941 desarrolló la Z3, por lo cual es considerada por algunos como la primera máquina completamente automática y programable. En lugar de usar tubos de vacíos, empleaba un conjunto de 2600 relés, unos dispositivos electromagnéticos inventados en 1835 y empleados, por ejemplo, en telegrafía.\n\nEl modelo original de la Z3 fue destruido en Berlín por un bombardeo durante la segunda guerra mundial.\nFigura 1.4: De izquierda derecha: las computadoras ABC, ENIAC y Z3\nEste nuevo paradigma cambió la historia de la computación, como también lo hizo la invención del transistor en 1947 en los Laboratorios Bell. Un transistor es un dispositivo electrónico semiconductor que entrega una señal de salida en respuesta una señal de entrada, mucho más pequeño que los tubos de vacío y que consumen menos energía eléctrica. Así, una computadora podía tener cientos de miles de transistores, obstante ocupando mucho espacio.Desde entonces, la computación ha evolucionado muy rápidamente, con la introducción de nuevos sistemas y conceptos, que llegan los complejos y poderosos diseños electrónicos que caracterizan la vida actual. En un intento de caracterizar y resumir esta impactante evolución, algunos historiadores dividen al desarrollo de las computadoras modernas en “generaciones” (esta clasificación es única y existen diversas versiones de la misma):Primera generación (aprox. 1940-1958): se trata de las computadoras electrónicas que usaban tubos de vacío para su circuito interno. Los equipos eran enormes y ocupan habitaciones enteras. Consumían mucha electricidad y generaban demasiado calor. Podía llevar días o semanas modificar las conexiones para hacer que la computadora resuelva un problema diferente. Usaban tarjetas perforadas y cinta de papel para la lectura de datos e impresiones para mostrar las salidas.Segunda generación (aprox. 1958-1964): se caracteriza por el uso de transistores (inventados en 1947) en lugar de tubos de vacío, permitiendo que las computadoras tengan un consumo eléctrico más eficiente, sean más baratas, más pequeñas y más rápidas.Tercera generación (aprox. 1964-1971): se inició en 1959 con el desarrollo de un circuito integrado (“chip”) que se trata de una pequeña placa de silicio sobre el cual se imprime un gran número de transistores conectados. La primera computadora de este estilo fue de IBM en 1960. Al ser más pequeñas y baratas, su uso llegó una mayor audiencia. Se pudo interactuar con la máquina mediante teclados, monitores y un sistema operativo, que posibilitaba ejecutar múltiples acciones la vez bajo el monitoreo de un programa central.Cuarta generación (aprox. 1971-presente): los avances tecnológicos permitieron construir la unidad entera de procesamiento de una computadora sobre un único chip de silicio (microprocesador), incluyendo la memoria y los controles de entrada y salida de datos. Todo lo que en una computadora de la primera generación ocupaba una habitación entera, fue capaz de entrar en la palma de una mano. El primer microprocesador fue el Intel 4004 de 1971, mientras que la primera computadora de uso doméstico fue desarrollada por IBM en 1981. Surgieron también en esta generación el ratón (mouse) y las interfaces gráficas de usuario (como Windows, en 1985).\nFigura 1.5: De derecha izquierda: un tubo de vacío, un transistor y un chip.\n","code":""},{"path":"introducción-a-la-programación.html","id":"software-y-hardware","chapter":"1 Introducción a la Programación","heading":"1.3 Software y hardware","text":"Como podemos ver, en la historia de la computación hubo dos aspectos que fueron evolucionando: las máquinas y los programas que las dirigen. Hacemos referencia estos elementos como hardware y software respectivamente, y es la conjunción de ambos la que le da vida la computación y hace posible la programación.\nFigura 1.6: Representación de la diferencia entre hardware y software.\nEl hardware es el conjunto de piezas físicas y tangibles de la computadora. Existen diversas formas de clasificar los elementos que componene al hardware, según distintos criterios:\nTabla 1.1:  Clasificación del hardware\n\\(~\\)Por otro lado tenemos al software, que es el conjunto de todos los programas (es decir, todas las instrucciones que recibe la computadora) que permiten que el hardware funcione y que se pueda concretar la ejecución de las tareas. tiene una existencia física, sino que es intangible. El software se puede clasificar de la siguiente forma:\nTabla 1.2:  Clasificación del software\n","code":""},{"path":"introducción-a-la-programación.html","id":"problemas-algoritmos-y-lenguajes-de-programación","chapter":"1 Introducción a la Programación","heading":"1.4 Problemas, algoritmos y lenguajes de programación","text":"Mencionamos anteriormente que la programación consistía en instruir una computadora para que resuelva un problema y que la comunicación de esas instrucciones debe ser realizada de forma clara. Es por eso que, ante un problema que debe ser resuelto computacionalmente, el primer paso es pensar detalladamente cuál puede ser una forma de resolverlo, es decir, crear un algoritmo. Un algoritmo es una estrategia consistente de un conjunto ordenado de pasos que nos lleva la solución de un problema o alcance de un objetivo. Luego, hay que traducir el algoritmo elegido al idioma de la computadora.Entonces, podemos decir que la resolución computacional de un problema consiste de dos etapas básicas:Diseño algorítmico: desarrollar un algoritmo, o elegir uno existente, que resuelva el problema.Codificación: expresar un algoritmo en un lenguaje de programación para que la computadora lo pueda interpretar y ejecutar.Al aprender sobre programación, comenzamos enfrentándonos problemas simples para los cuales la primera etapa parece sencilla, mientras que la codificación se torna dificultosa ya que hay que aprender las reglas del lenguaje de programación. Sin embargo, mientras que con práctica rápidamente podemos ganar facilidad para la escritura de código, el diseño algorítmico se torna cada vez más desafiante al encarar problemas más complejos. Es por eso que haremos hincapié en el planteo y desarrollo de algoritmos como una etapa fundamental en la programación.","code":""},{"path":"introducción-a-la-programación.html","id":"el-diseño-algorítmico","chapter":"1 Introducción a la Programación","heading":"1.4.1 El diseño algorítmico","text":"Cotidianamente, hacemos uso de algoritmos para llevar adelante casi todas las actividades que realizamos: preparar el desayuno, sacar pasear la mascota, poner en la tele un servicio de streaming para ver una película, etc. Cada una de estas tareas requiere llevar adelante algunas acciones de forma ordenada, aunque hagamos un listado de las mismas y procedamos casi sin pensar.Sin embargo, cuando estamos pensando la solución para un problema que va resolver una computadora, debemos ser claros y concretos, para asegurarnos de que al seguir los pasos del algoritmo se llegue la solución y para que quien tenga que codificarlo, nosotros mismos u otras personas, lo pueda entender sin problemas. Por eso, el primer paso es idear un algoritmo para su solución y expresarlo por escrito, por ejemplo, en español, pero adaptando el lenguaje humano formas lógicas que se acerquen las tareas que puede realizar una computadora. En programación, el lenguaje artificial e informal que usan los desarrolladores en la confección de algoritmos recibe el nombre de pseudocódigo. Es la herramienta que utilizamos para describir los algoritmos mezclando el lenguaje común con instrucciones de programación. es en sí mismo un lenguaje de programación, es decir, la computadora es capaz de entenderlo, sino que el objetivo del mismo es que el programador se centre en la solución lógica y luego lo utilice como guía al escribir el programa.El pseudocódigo, como cualquier otro lenguaje, está compuesto por:Un léxico: conjunto de palabras o frases válidas para escribir las instrucciones.Una sintaxis: reglas que establecen cómo se pueden combinar las distintas partes.Una semántica: significado que se les da las palabras o frases.El pseudocódigo sigue una estructura secuencial: define una acción o instrucción que sigue otra en secuencia. Esta estructura puede representarse de la siguiente forma:Se comienza con un título que describa el problema que el algoritmo resuelve, seguido por la palabra COMENZAR. Luego se detallan las acciones o instrucciones seguir y se concluye con la palabra FIN. Por ejemplo, si nuestro problema es poner en marcha un auto, el algoritmo para resolverlo puede ser expresado mediante el siguiente pseudocódigo:Es importante destacar la presencia de sangrías (sangrado) en el ejemplo anterior, que facilitan la lectura.Los algoritmos suelen ser representados también mediante diagramas de flujo, como el que se muestra en la siguiente figura1.\nFigura 1.7: Ejemplo del algoritmo “Arrancar el auto” representado gráficamente con un diagrama de flujo.\n","code":"ALGORITMO: \"Ejemplo\"\nCOMENZAR\n    Acción 1\n    Acción 2\n    ...\n    Acción N\nFINALGORITMO: \"Arrancar el auto\"\nCOMENZAR\n    INSERTAR la llave de contacto\n    UBICAR el cambio en punto muerto\n    GIRAR la llave hasta la posición de arranque\n    SI el motor arranca \n        ENTONCES\n            DEJAR la llave en posición \"encendido\"\n        SI NO\n            LLAMAR al mecánico\n    FINSI\nFIN"},{"path":"introducción-a-la-programación.html","id":"codificación","chapter":"1 Introducción a la Programación","heading":"1.4.2 Codificación","text":"El algoritmo anterior está presentado en pseudocódigo utilizando el lenguaje español, una opción razonable para compartir esta estrategia entre personas que se comuniquen con este idioma. Claramente, si queremos presentarle nuestro algoritmo alguien que sólo habla francés, el español ya sería una buena elección, y mucho menos si queremos presentarle el algoritmo una computadora. Para que una computadora pueda entender nuestro algoritmo, debemos traducirlo en un lenguaje de programación, que, como dijimos antes, es un idioma artificial diseñado para expresar cómputos que puedan ser llevados cabo por equipos electrónicos, es decir es un medio de comunicación entre el humano y la máquina.Si bien hay distintos lenguajes de programación, una computadora en definitiva es un aparato que sólo sabe hablar en binario, es decir, sólo interpreta señales eléctricas con dos estados posibles, los cuales son representados por los dígitos binarios 0 y 1. Toda instrucción que recibe la computadora se construye mediante una adecuada y larga combinación de ceros y unos2. Este sistema de código con ceros y unos que la computadora interpreta como instrucciones o conjuntos de datos se llama lenguaje de máquina (o código de máquina).Programar en lenguaje de máquina es muy complejo y lento, y es fácil cometer errores pero es difícil arreglarlos. Por eso principios de la década de 1950 se inventaron los lenguaje ensambladores, que usan palabras para representar simbólicamente las operaciones que debe realizar la computadora. Cada una de estas palabras reemplaza un código de máquina binario, siendo un poco más fácil programar. Imaginemos que deseamos crear un programa que permita sumar dos números elegidos por una persona. La computadora puede hacer esto si se lo comunicamos mediante un mensaje compuesto por una larga cadena de ceros y unos (lenguaje de máquina) que simple vista podríamos entender. Sin embargo, escrito en lenguaje de máquina, el programa se vería así (por ejemplo):\nFigura 1.8: Programa en lenguaje ensamblador para leer dos números, sumarlos y mostrar el resultado. Al final de cada línea hay una descripción de la operación realizada.\nEl programa que se encarga de traducir esto al código de máquina se llama ensamblador. pesar de que haya ceros y unos como en el lenguaje de máquina, probablemente el código anterior tampoco sea fácil de entender. Aparecen instrucciones que tal vez podemos interpretar, como add por sumar o sub por substraer, pero está lleno de cálculos hexadecimales, referencias posiciones en la memoria de la computadora y movimientos de valores que lo hacen muy amigable. Por eso, pesar de que la existencia de los lenguajes ensambladores simplificó mucho la comunicación con la computadora, se hizo necesario desarrollar lenguajes que sean aún más sencillos de usar.Por ejemplo, con el lenguaje que vamos aprender, R, el problema de pedirle dos números una persona y sumarlos se resumen en las siguientes líneas de código:En las dos primeras líneas con la sentencia scan() (que quiere decir “escanear”, “leer”) se le pide la persona que indique dos números y en la tercera línea se muestra el resultado de la suma, con la sentencia print() (“imprimir”, “mostrar”). Mucho más corto y entendible.Esta simplificación es posible porque nos permitimos ignorar ciertos aspectos del proceso que realiza la computadora. Todas esas acciones que se ven ejemplificadas en la imagen con el código ensamblador se llevan cabo de todas formas, pero lo vemos. Nosotros sólo tenemos que aprender esas últimas tres líneas de código, de forma que nos podemos concentrar en el problema resolver (ingresar dos números, sumarlos y mostrar el resultado) y en las complejas operaciones internas que tiene que hacer el microprocesador.En programación, la idea de simplificar un proceso complejo ignorando algunas de sus partes para comprender mejor lo que hay que realizar y así resolver un problema se conoce como abstracción3. Esto quiere decir que los lenguajes de programación pueden tener distintos niveles de abstracción:Lenguajes de bajo nivel de abstracción: permiten controlar directamente el hardware de la computadora, son específicos para cada tipo de máquina, y son más rígidos y complicados de entender para nosotros. El lenguaje ensamblador entra en esta categoría.Lenguajes de alto nivel de abstracción: diseñados para que sea fácil para los humanos expresar los algoritmos sin necesidad de entender en detalle cómo hace exactamente el hardware para ejecutarlos. El lenguaje que utilizaremos en este taller, R, es de alto nivel. Son independientes del tipo de máquina.Lenguajes de nivel medio de abstracción: son lenguajes con características mixtas entre ambos grupos anteriores.\nFigura 1.9: Distintos lenguajes de programación y sus logos.\nSi bien podemos programar usando un lenguaje de alto nivel para que nos resulte más sencillo, alguien o algo debe traducirlo lenguaje de máquina para que la computadora, que sólo entiende de ceros y unos, pueda realizar las tareas. Esto también es necesario incluso si programáramos en lenguaje ensamblador. Para estos procesos de traducción se crearon los compiladores e intérpretes.Un compilador es un programa que toma el código escrito en un lenguaje de alto nivel y lo traduce código de máquina, guardándolo en un archivo que la computadora ejecutará posteriormente (archivo ejecutable). Para ilustrar el rol del compilador, imaginemos que alguien que sólo habla español le quiere mandar una carta escrita en español alguien que vive en Alemania y sólo habla alemán. Cuando esta persona la reciba, la va entender. Se necesita de un intermediario que tome la carta en español, la traduzca y la escriba en alemán y luego se la mande al destinatario, quien ahora sí la podrá entender. Ese es el rol de un compilador en la computadora. Ahora bien, el resultado de la traducción, que es la carta escrita en alemán, sólo sive para gente que hable alemán. Si se quiere enviar el mismo mensaje personas que hablen otros idiomas, necesitaremos hacer la traducción que corresponda. De la misma forma, el código generado por un compilador es específico para cada máquina, depende de su arquitectura.Además de los compiladores, para realizar este pasaje también existen los intérpretes. Un intérprete es un programa que traduce el código escrito en lenguaje de alto nivel código de máquina, pero lo va haciendo medida que se necesita, es decir, su resultado reside en la memoria temporal de la computadora y se genera ningún archivo ejecutable. Siguiendo con el ejemplo anterior, es similar viajar Alemania con un intérprete que nos vaya traduciendo en vivo y en directo cada vez que le queramos decir algo alguien de ese país. En su implementación por defecto, el lenguaje R es interpretado, compilado.Concluyendo, gracias al concepto de la abstracción podemos escribir programas en un lenguaje que nos resulte fácil entender, y gracias al trabajo de los compiladores e intérpretes la computadora podrá llevar adelante las tareas necesarias.Cada una de las acciones que componen al algoritmo son codificadas con una o varias instrucciones o sentencias, expresadas en el lenguaje de programación elegido, y el conjunto de todas ellas constituye un programa. El programa se guarda en un archivo con un nombre generalmente dividido en dos partes por un punto, por ejemplo: mi_primer_programa.R. La primera parte es la raíz del nombre con la cual podemos describir el contenido del archivo. La segunda parte es indicativa del uso del archivo, por ejemplo, .R indica que contiene un programa escrito en el lenguaje R. El proceso general de ingresar o modificar el contenido de un archivo se denomina edición.","code":"n1 <- scan()\nn2 <- scan()\nprint(n1 + n2)"},{"path":"introducción-a-la-programación.html","id":"errores-de-programación","chapter":"1 Introducción a la Programación","heading":"1.5 Errores de programación","text":"Apenas iniciemos nuestro camino en el mundo de la programación nos daremos cuenta que tendremos siempre ciertos compañeros de viaje: los errores. Muchas veces nos pasará que queremos ejecutar nuestro código y el mismo anda o produce el resultado esperado. importa cuán cuidadosos seamos, ni cuánta experiencia tengamos, los errores están siempre presentes. Con el tiempo y práctica, vamos poder identificarlos y corregirlos con mayor facilidad, pero probablemente nunca dejemos de cometerlos.los errores en programación se los suele llamar bugs (insecto o bicho en inglés) y el proceso de la corrección de los mismos se conoce como debugging (depuración)4. Se dice que esta terminología proviene de 1947, cuando una computadora en la Universidad de Harvard (la Mark II) dejó de funcionar y finalmente se descubrió que la causa del problema era la presencia de una polilla en un relé electromagnético de la máquina. Sin embargo, otros historiadores sostienen que el término ya se usaba desde antes.\nFigura 1.10: La polilla (bug) encontrada por la científica de la computación Grace Hooper en la Mark II fue pegada con cinta en un reporte sobre el malfuncionamiento de la máquina.\ncontinuación se presenta una de las posibles clasificaciones de los errores que se pueden cometer en programación:Errores de sintaxis. Tal como el lenguaje humano, los lenguajes de programación tienen su propio vocabulario y su propia sintaxis, que es el conjunto de reglas gramaticales que establecen cómo se pueden combinar las distintas partes. Estas reglas sintácticas determinan que ciertas sentencias están correctamente construidas, mientras que otras . Cuando ejecutamos un programa, el compilador o el intérprete chequea si el mismo es sintácticamente correcto. Si hemos violado alguna regla, por ejemplo, nos faltó una coma o nos sobra un paréntesis, mostrará un mensaje de error y debemos editar nuestro programa para corregirlo. En estos casos, hay que interpretar el mensaje de error, revisar el código y corregir el error.Errores de sintaxis. Tal como el lenguaje humano, los lenguajes de programación tienen su propio vocabulario y su propia sintaxis, que es el conjunto de reglas gramaticales que establecen cómo se pueden combinar las distintas partes. Estas reglas sintácticas determinan que ciertas sentencias están correctamente construidas, mientras que otras . Cuando ejecutamos un programa, el compilador o el intérprete chequea si el mismo es sintácticamente correcto. Si hemos violado alguna regla, por ejemplo, nos faltó una coma o nos sobra un paréntesis, mostrará un mensaje de error y debemos editar nuestro programa para corregirlo. En estos casos, hay que interpretar el mensaje de error, revisar el código y corregir el error.Errores lógicos. Se presentan cuando el programa puede ser compilado sin errores pero arroja resultados incorrectos o ningún resultado. El software muestra mensajes de error, debido que, por supuesto, sabe cuál es el resultado deseado, sino que sólo se limita hacer lo que hemos programado. En estos casos hay que revisar el programa para encontrar algún error en su lógica. Este tipo de errores suelen ser los más problemáticos. Algunas ideas para enfrentarlos incluyen volver pensar paso por paso lo que se debería hacer para solucionar el problema y compararlo con lo que se ha programado, agregar pasos para mostrar resultados intermedios o emplear herramientas especializadas de debugging (llamadas debugger) para explorar el código paso paso hasta identificar el error.Errores lógicos. Se presentan cuando el programa puede ser compilado sin errores pero arroja resultados incorrectos o ningún resultado. El software muestra mensajes de error, debido que, por supuesto, sabe cuál es el resultado deseado, sino que sólo se limita hacer lo que hemos programado. En estos casos hay que revisar el programa para encontrar algún error en su lógica. Este tipo de errores suelen ser los más problemáticos. Algunas ideas para enfrentarlos incluyen volver pensar paso por paso lo que se debería hacer para solucionar el problema y compararlo con lo que se ha programado, agregar pasos para mostrar resultados intermedios o emplear herramientas especializadas de debugging (llamadas debugger) para explorar el código paso paso hasta identificar el error.Errores en la ejecución (runtime errors). Se presentan cuando el programa está bien escrito, sin errores lógicos ni sintácticos, pero igualmente se comporta de alguna forma incorrecta. Se dan pesar de que el programa ande bien en el entorno de desarrollo del programador, pero cuando algún usuario lo utiliza en algún contexto particular. Puede ser que se intente abrir un archivo que existe, que el proceso supere la memoria disponible, que tomen lugar operaciones aritméticas definidas como la división por cero, etc.Errores en la ejecución (runtime errors). Se presentan cuando el programa está bien escrito, sin errores lógicos ni sintácticos, pero igualmente se comporta de alguna forma incorrecta. Se dan pesar de que el programa ande bien en el entorno de desarrollo del programador, pero cuando algún usuario lo utiliza en algún contexto particular. Puede ser que se intente abrir un archivo que existe, que el proceso supere la memoria disponible, que tomen lugar operaciones aritméticas definidas como la división por cero, etc.Los errores en la programación son tan comunes, que un científico de la computación muy reconocido, Edsger Dijkstra, dijo una vez: “si la depuración es el proceso de eliminar errores, entonces la programación es el proceso de generarlos”. Ante la presencia de uno, hay más que respirar profundo y con paciencia revisar hasta encontrarlo y solucionarlo.\nFigura 1.11: Encontrando un bug en un programa.\n","code":""},{"path":"introducción-a-la-programación.html","id":"procesador-ambiente-y-acciones","chapter":"1 Introducción a la Programación","heading":"1.6 Procesador, ambiente y acciones","text":"Hemos definido un algoritmo como una lista de instrucciones para resolver un problema. En este contexto, se entiende por procesador todo agente capaz de comprender los pasos de un algoritmo y ejecutar el trabajo indicado por el mismo. Para cumplir con el objetivo, el procesador emplea ciertos recursos que tiene disposición. Todos los elementos disponibles para ser utilizados por el procesador constituyen su entorno o ambiente. Cada una de las instrucciones que componen el algoritmo modifican el entorno de alguna manera y se denominan acciones.Ejemplificaremos estos conceptos con los siguientes ejemplos:Ejemplo 1Problema: preparar una tortilla de 6 huevos.Entorno: una mesa, una hornalla, una sartén, un plato, un tenedor, aceite, una fuente con huevos, un tarro de basura.Procesador: una persona adulta.Acciones comprensibles por el procesador: agarrar un huevo, romper un huevo en un plato, batir huevos, poner aceite, poner en la sartén, poner al fuego, retirar del fuego, tirar las cáscaras, encender el fuego.¿Cuál es un algoritmo adecuado para solucionar este problema? Podría ser:Ejemplo 2Problema: calcular el factorial del número 5.Entorno: se dispone de una calculadora común.Procesador: una persona adulta.Acciones comprensibles por el procesador: pulsar teclas de la calculadora.¿Cuál es un algoritmo adecuado para solucionar este problema? Podría ser:Las acciones del algoritmo pueden clasificarse en función de su complejidad:Acción primitiva: acción sencilla directamente realizable por el procesador sin necesidad de contar con mayor información.Acción compuesta: acción integrada por una sucesión de acciones primitivas.La descripción de un algoritmo en términos de acciones compuestas puede facilitar su comprensión, pero al desarrollar el programa será necesario descomponerlas en acciones primitivas que son las que realmente ejecuta el procesador. Por ejemplo, la acción compuesta en el ejemplo de la tortilla de “romper seis huevos en un plato” puede descomponerse en acciones más simples:En el contexto de la resolución de un problema computacional, el procesador será la computadora; las acciones estarán dadas por las sentencias disponibles en el lenguaje de programación utilizado o las que podamos crear en base al mismo; y el ambiente estará constituido por un conjunto de variables, estructuras de datos, funciones y otros elementos que serán de utilidad en la programación.","code":"ALGORITMO: \"Preparar una tortilla de 6 huevos\"\nCOMENZAR\n    ROMPER seis huevos en un plato\n    TIRAR las cáscaras en el tacho\n    BATIR los huevos\n    CALENTAR aceite en la sartén\n    PONER el contenido del plato en la sartén\n    ESPERAR diez minutos\n    RETIRAR la tortilla del fuego\n    APAGAR el fuego\nFINALGORITMO: \"Calcular 5!\"\nCOMENZAR\n    PULSAR [ON]\n    PULSAR [1]\n    PULSAR [X]\n    PULSAR [2]\n    PULSAR [X]\n    PULSAR [3]\n    PULSAR [X]\n    PULSAR [4]\n    PULSAR [X]\n    PULSAR [5]\n    PULSAR [=]\n    MOSTRAR la pantalla\nFINREPETIR 6 VECES\n    TOMAR un huevo\n    GOLPEAR el huevo para generar una fractura en la cáscara\n    EJERCER presión sobre la cáscara\n    DERRAMAR la clara y la yema sobre el plato"},{"path":"introducción-a-la-programación.html","id":"r-y-rstudio","chapter":"1 Introducción a la Programación","heading":"1.7 R y RStudio","text":"Como dijimos anteriormente, pondremos en práctica los conceptos sobre programación utilizando R, un lenguaje orientado la realización de procesos estadísticos y gráficos. diferencia de muchos otros, este es un software libre y gratuito: se distribuye bajo la licencia GNU GPLv2 que establece la libertad de usarlo con cualquier propósito, de ver cómo fue hecho, cómo funciona y modificarlo, de distribuir copias y crear contribuciones y agregados para que estén disponibles para otros 5.Si bien R será nuestro medio de comunicación con la computadora, vamos usar otro programa que brinda algunas herramientas para facilitar nuestro trabajo de programación, es decir, vamos usar un entorno de desarrollo integrado (o IDE, por integrated development environment). Un IDE es un programa que hace que la codificación sea más sencilla porque permite manejar varios archivos de código, visualizar el ambiente de trabajo, utilizar resaltado con colores para distintas partes del código, emplear autocompletado para escribir más rápido, explorar páginas de ayuda, implementar estrategias de depuración e incluso intercalar la ejecución de sentencias con la visualización de los resultados mientras avanzamos en el análisis o solución del problema. El IDE más popularmente empleado para programar con R es RStudio y será el programa que estaremos usando todo el tiempo.Para instalar estos programas, se debe visitar las páginas oficiales de R y de RStudio, descargar los instaladores y ejecutarlos. En este enlace se presenta un video con la instalación completa.","code":""},{"path":"introducción-a-la-programación.html","id":"organización-de-rstudio","chapter":"1 Introducción a la Programación","heading":"1.7.1 Organización de RStudio","text":"Cuando se abre RStudio se pueden visualizar cuatro paneles:\nFigura 1.12: Captura de pantalla de RStudio\nla izquierda:\nArriba está el editor de archivos. Es el lugar donde escribiremos y editaremos nuestros programas, para luego guardarlos (una especie de Bloc de Notas* o de un Word muy simple). La primera vez que se abre RStudio después de su instalación puede ser que este panel esté presente, pero aparece si vamos File > New File > R Script, con el atajo Ctrl + Shift + N o haciendo clic en el primer ícono de la barra de herramientas. Podemos abrir varios archivos la vez.\nAbajo está la consola. Es la ventana que se comunica con R. través de ella se envían las instrucciones o sentencias R para que las evalúe (también decimos, que las ejecute o corra) y se visualizan los resultados.\nla izquierda:Arriba está el editor de archivos. Es el lugar donde escribiremos y editaremos nuestros programas, para luego guardarlos (una especie de Bloc de Notas* o de un Word muy simple). La primera vez que se abre RStudio después de su instalación puede ser que este panel esté presente, pero aparece si vamos File > New File > R Script, con el atajo Ctrl + Shift + N o haciendo clic en el primer ícono de la barra de herramientas. Podemos abrir varios archivos la vez.Abajo está la consola. Es la ventana que se comunica con R. través de ella se envían las instrucciones o sentencias R para que las evalúe (también decimos, que las ejecute o corra) y se visualizan los resultados.Arriba la derecha hay un panel con algunas pestañas:\nEnvironment (ambiente): muestra todos los elementos que componen al ambiente o entorno.\nHistory (historial): lista todas las instrucciones que R ha corrido anteriormente.\nOtras más que nos interesan por ahora\nArriba la derecha hay un panel con algunas pestañas:Environment (ambiente): muestra todos los elementos que componen al ambiente o entorno.History (historial): lista todas las instrucciones que R ha corrido anteriormente.Otras más que nos interesan por ahoraAbajo la derecha hay otro panel con más pestañas:\nFiles: explorador de archivos de la computadora\nPlots: ventana donde aparecen los gráficos si es que nuestro código produce alguno\nPackages: listado de los “paquetes” que tenemos instalados (ver más adelante)\nHelp: manual de ayuda sobre todas las funciones de R\nViewer: espacio para ver salidas de los programas con algún componente dinámico o interactivo.\nAbajo la derecha hay otro panel con más pestañas:Files: explorador de archivos de la computadoraPlots: ventana donde aparecen los gráficos si es que nuestro código produce algunoPackages: listado de los “paquetes” que tenemos instalados (ver más adelante)Help: manual de ayuda sobre todas las funciones de RViewer: espacio para ver salidas de los programas con algún componente dinámico o interactivo.","code":""},{"path":"introducción-a-la-programación.html","id":"uso-de-rstudio","chapter":"1 Introducción a la Programación","heading":"1.7.2 Uso de RStudio","text":"Podemos usar la consola de R que encontramos en el panel de la izquierda para introducir allí nuestras sentencias y al hacer Enter serán evaluadas, produciendo algún resultado. Por ejemplo, podemos hacer algunos cálculos matemáticos como dividir, multiplicar, sumar, restar, calcular potencias, logaritmos, raíces y mucho más:Si bien podemos escribir nuestras sentencias en la consola y dar Enter para que se ejecuten, en general queremos que queden escritas y guardadas en el archivo de código, por eso vamos escribir nuestros programas en el panel de arriba la izquierda. Una vez que escribimos una sentencia en el script, podemos correrla (es decir, enviarla la consola para que se ejecute) haciendo clic en el ícono Run o con el atajo Ctrl + Enter. De esta forma, se corre la línea en la cual está el cursor o las líneas que hayamos seleccionado.En todo lenguaje de programación existe un caracter especial que, al ser colocado al comienzo de una línea de código, le indica al software que dicha línea debe ser evaluada. Esto se utiliza para incluir comentarios, es decir, líneas que expresan en español explicaciones o aclaraciones para nosotros mismos u otros que puedan utilizar nuestro código. También se utiliza para añadir encabezados con descripciones sobre el script, o indicar distintas secciones o partes en el programa. En R, este caracter especial es el símbolo numera (#). Si corremos líneas que empiezan con #, R hará nada con ellas, las salteará. Por ejemplo","code":"\n1 + 2[1] 3\n5 * 3[1] 15\nexp(2)[1] 7.389056\nsqrt(100)[1] 10\n1 / 0[1] Inf\n(2 + 3i) * (3 + 6i)[1] -12+21i\n1i ^ 2[1] -1+0i\n5^1[1] 5\n# 5^2\n5^3[1] 125"},{"path":"introducción-a-la-programación.html","id":"diseño-del-sistema-r","chapter":"1 Introducción a la Programación","heading":"1.7.3 Diseño del sistema R","text":"R Se divide en dos partes:La base (R Base), que se instala cuando descargamos el programa desde CRAN (“Comprehensive R Archive Network”). Contiene, entre otras cosas, una serie de herramientas básicas y fundamentales de R.La base (R Base), que se instala cuando descargamos el programa desde CRAN (“Comprehensive R Archive Network”). Contiene, entre otras cosas, una serie de herramientas básicas y fundamentales de R.Paquetes adicionales. Un paquete es un conjunto de archivos que se descarga de forma opcional desde CRAN u otros repositorios y que sirven para hacer alguna tarea especial. Por ejemplo, para poder hacer gráficos lindos, se puede usar un paquete que se llama ggplot2.Paquetes adicionales. Un paquete es un conjunto de archivos que se descarga de forma opcional desde CRAN u otros repositorios y que sirven para hacer alguna tarea especial. Por ejemplo, para poder hacer gráficos lindos, se puede usar un paquete que se llama ggplot2.Como dijimos antes, en la pestaña Packages del panel de abajo la derecha tiene el listado de todos los paquetes que ya están instalados (muchos vienen con R Base). Allí también hay un botón para instalar nuevos, aunque otra opción es correr la sentencia install.packages(\"nombredelpaquete\"), por ejemplo, install.packages(\"ggplot2\"). Un paquete se instala una sola vez, pero cada vez que lo queramos usar debemos cargarlo para que las herramientas que trae queden nuestra disposición. Eso se hace con la sentencia library(\"nombredelpaquete\"), por ejemplo, library(\"ggplot2\").","code":""},{"path":"introducción-a-la-programación.html","id":"guía-de-estilo","chapter":"1 Introducción a la Programación","heading":"1.8 Guía de estilo","text":"Es sumamente importante mantener la prolijidad en la escritura tanto del pseudocódigo como de los programas, para facilitar la lectura de los mismos, especialmente cuando estamos trabajando con problemas largos. Siempre hay que tener en cuenta de que cuando escribimos un programa, tenemos dos públicos potenciales: integrantes de nuestro equipo de trabajo que tienen leer el código y hacer sus propios aportes y nosotros mismos en el futuro, cuando retomemos código hecho en el pasado y necesitemos interpretar qué es lo que hicimos hacer.Es por eso que se establecen conjuntos de reglas para controlar y unificar la forma de escribir programas, que se conocen como guía de estilo. Estas reglas cubren aspectos como, por ejemplo, la forma de escribir comentarios en el código, la utilización de espacios o renglones en blanco, el formato de los nombres para los elementos que creamos nosotros mismos (como las funciones) y para los archivos que generamos, etc. Una guía de estilo indica la única forma de escribir código, ni siquiera la forma correcta de hacerlo, sino que establece una convención para que todos trabajen de la misma forma, basándose en costumbres que sí se ha visto que pueden tener más ventajas que otras.Por ejemplo, para programar en R, existe una guía de estilo llamada tidyverse style guide, que es la que utilizan la gente de Google y de RStudio. En este curso vamos adherir sus recomendaciones. Si bien es una lectura muy interesante, particularmente si tenés intenciones de profundizar tus conocimientos sobre programación en R, es necesario que lean dicha guía completa. Por ahora es suficiente con que imiten con atención el estilo que usamos en los ejemplos provistos en esta guía.Recordemos siempre que seguir un buen estilo para programar es como hacer uso de una correcta puntuación cuando escribimos, podemos entendernos sin ella, peroesmuchomasdificilleerloqueescribimossinolarespetamosno?","code":""},{"path":"objetos-y-operadores.html","id":"objetos-y-operadores","chapter":"2 Objetos y operadores","heading":"2 Objetos y operadores","text":"Hemos mencionado que para resolver un problema computacional se necesita de un procesador, capaz de entender y ejecutar ciertas acciones partir de ciertos elementos disponibles en el ambiente o entorno. En este capítulo vamos aprender acerca de dichos elementos, los que llamamos objetos.","code":""},{"path":"objetos-y-operadores.html","id":"objetos","chapter":"2 Objetos y operadores","heading":"2.1 Objetos","text":"Los objetos son las distintas piezas de información, o más sencillamente, datos, que componen al entorno y que el procesador debe manipular para resolver una tarea. Las distintas acciones del algoritmo van creando o modificando los objetos del entorno. medida que avancemos, veremos que hay distintas clases de objetos, algunos con estructuras más simples y otros más complejos. Es más, cada lenguaje de programación propone su propio catálogo de clases de objetos y cada programador puede crear otras nuevas. Sin embargo, en general todos los lenguajes tienen en común el hecho de que sus objetos pueden almacenar los siguientes tres tipos de datos básicos, conocidos como tipos de datos primitivos:Datos de tipo numérico: representan valores escalares de forma numérica y permiten realizar operaciones aritméticas comunes. Ejemplo: 230, 2.Datos de tipo caracter: representan texto y es posible hacer operaciones matemáticas con ellos. Representamos estos valores entre comillas. Ejemplo: “hola”, “chau123”Datos de tipo lógico: pueden tomar dos valores (VERDADERO o FALSO), ya que representan el resultado de alguna comparación entre otros objetos. En R, estos valores son TRUE y FALSE, escritos sin comillas.De manera general, al nombre de un objeto se le dice identificador, el cual es una secuencia de caracteres alfanuméricos que sirve para identificarlo lo largo del algoritmo. Nombrar los objetos hace posible referirse los mismos. La elección de los identificadores es una tarea del programador, pero cada lenguaje tiene sus propias reglas. Por ejemplo, en R los nombres de los objetos:Deben empezar con una letra o un punto (pueden empezar con un número).Sólo pueden contener letras, números, guiones bajos y puntos (se puede forzar R para que acepte nombres con otros caracteres, pero es aconsejable).se pueden usar las siguientes palabras como nombres, ya que son palabras claves reservadas para R: break, else, FALSE, , function, , Inf, NA, NaN, next, repeat, return, TRUE, .Es aconsejable elegir un nombre que sea representativo de la información que va guardar el objeto, ya que esto facilita la lectura y la comprensión tanto del algoritmo como del programa. Por ejemplo, si se necesita un objeto para guardar el valor numérico del precio de algún producto, el identificador p sería una mala elección, mientras que precio sería mejor. Si se necesitan varios identificadores para distinguir los precios de diversos productos, podríamos usar algo como precio_manzana, precio_banana, etc. Otra opción podría ser preciomanzana o precioManzana, pero en este curso seguiremos la convención de usar guiones bajos para facilitar la lectura de los nombres elegidos. sería posible usar como identificador precio manazana, puesto que un nombre puede tener espacios.Ciertos objetos almacenan temporalmente un valor durante la ejecución de un proceso y su contenido puede cambiar mientras corre el programa. Este tipo de objetos reciben el nombre de variables. Por ejemplo, en un programa creado para un comercio puede existir un objeto llamado stock (identificador) de tipo numérico que representa la cantidad de artículos disponibles y cuyo valor se modifica cada vez que se registra una nueva venta. Podemos pensar una variable como una caja etiquetada con un nombre (su identificador) y que guarda un valor (numérico, lógico o de caracter).\nFigura 2.1: La variable contiene al valor 5.\nSi un objeto tiene siempre necesariamente un valor fijo, se dice que es una constante. El valor es siempre el mismo para cualquier ejecución del programa, es decir, puede cambiar de una ejecución otra. Son ejemplos de constantes el número de meses del año, las constantes matemáticas tales como el número \\(\\pi\\), los factores de conversión de unidades de medida, etc. Las constantes pueden usarse literalmente, es decir, usando explícitamente el valor, o también través de un objeto que asocie un identificador al valor constante (por ejemplo, asociar el nombre pi la constante 3.14159265).","code":""},{"path":"objetos-y-operadores.html","id":"declaración-de-variables-y-constantes","chapter":"2 Objetos y operadores","heading":"2.1.1 Declaración de variables y constantes","text":"Al expresar nuestros algoritmos en pseudocódigo tomaremos la costumbre de declarar al inicio del mismo las variables y constantes necesarias para resolver el problema, explicitando su identificador y determinando el tipo de valor que guarda. Muchos lenguajes de programación utilizan esta declaración para reservar en la memoria de la computadora un espacio para almacenar la información correspondiente de manera adecuada.Veamos un ejemplo:Una vez que una variable o constante ha sido definida con un tipo particular, es incorrecto intentar asignarle un valor de otro tipo, por ejemplo, asignarle la variable radio del ejemplo anterior un valor de tipo caracter. Esto generaría ambigüedad, además de que en ciertos lenguajes de programación produciría un error.R es un lenguaje dinámico que requiere la declaración previa de las variables que serán utilizadas, sino que estas pueden definirse dinámicamente lo largo del programa. Por eso, incluiremos declaración de variables y constantes sólo en los algoritmos y cuando estos sean traducidos R. Al necesitar una declaración previa, en R es posible asignar, por ejemplo, un valor de tipo caracter un identificador que anteriormente contenía un valor de tipo numérico, pero trataremos de evitar esto.","code":"ALGORITMO: \"Calcular área de un círculo\"\nCOMENZAR\n    CONSTANTE numérica pi\n    VARIABLE numérica radio, area\n        ...restantes acciones del algoritmo...\nFIN"},{"path":"objetos-y-operadores.html","id":"acción-de-asignación","chapter":"2 Objetos y operadores","heading":"2.1.2 Acción de asignación","text":"Para hacer que una variable guarde un determinado valor se recurre una acción de asignación. Mediante asignaciones podemos dar valores iniciales las variables, modificar el valor que tenían hasta el momento o guardar en ellas resultados intermedios o finales del algoritmo.En pseudocódigo expresaremos la asignación como se muestra en estos ejemplos:Si intervienen variables o constantes en la expresión la derecha de una acción de asignación, se usará el valor que tengan las mismas en ese momento. Por ejemplo, la siguiente secuencia de acciones en un algoritmo:resultará en que las variables var1, var2 y var3 tengan almacenados los valores 7, 2 y 7 respectivamente. Un caso particular se da cuando una variable se le asigna el valor de una operación de la que forma parte la misma variable. Por ejemplo:","code":"ALGORITMO: \"Calcular área de un círculo\"\nCOMENZAR\n    CONSTANTE numérica pi\n    VARIABLE numérica radio, area\n    pi <- 3.14159265358979\n    radio <- 3\n    ...restantes acciones del algoritmo...\nFINvar1 <- 2\nvar2 <- var1\nvar1 <- 7\nvar3 <- var1stock <- 43\nventas <- 29\ncompras <- 12\nstock <- stock - ventas + compras"},{"path":"objetos-y-operadores.html","id":"creación-y-manejo-de-objetos-en-r","chapter":"2 Objetos y operadores","heading":"2.1.3 Creación y manejo de objetos en R","text":"En R también se usa el operador “flechita” para asignar valores variables. Como lo vamos usar muchísimas veces, es conveniente recordar su shortcut: Alt + - (teclas Alt y guión medio). Como ya mencionamos antes, R es un lenguaje dinámico, lo cual significa que tenemos que declarar las variables antes de asignarles un valor. Por ejemplo, si necesitamos registrar el peso y lugar de nacimiento de una persona, solamente tenemos que hacer:En este caso, lugar_nacimiento es un objeto de tipo carácter, ya que la información que contiene es \"Bombal\", y peso_nacimiento es un objeto numérico. Vale aclarar que en R el punto decimal se representa con el punto . y con la coma , como solemos escribir habitualmente, por lo que el número indicado se lee “tres coma cuatrocientos veintitrés” y “tres mil cuatrocientos veintitrés”. Asimismo, se usan separadores de miles al escribir los números.Por otro lado, R provee algunas funciones para poder averiguar en cualquier momento qué tipo de dato está almacenado en alguna variable. Todavía hemos definido formalmente las funciones, pero por ahora nos alcanza con saber que son otro tipo de objetos que cuando las usamos se encargan de cumplir con alguna tarea específica. Las funciones también tienen un nombre (identificador) y están seguidas por un par de paréntesis, dentro de los cuales se escriben opciones para que ellas operen. La función class() es la que nos dice qué tipo de dato hay en una variable:También hay algunas funciones que devuelven TRUE o FALSE modo de respuesta cuando le preguntamos R si una variable tiene un dato de tipo numérico, caracter o lógico:Todos los objetos que vamos definiendo en nuestro algoritmo y, posteriormente, en nuestro programa, forman parte del ambiente. En Rstudio podemos ver listados todos los objetos presentes en el ambiente en la pestaña Environment del panel superior derecho. También podemos ver en la consola un listado de todos los nombres de los objetos que existen en el ambiente con la función ls(), por ejemplo:Es probable que mientras estamos escribiendo el código, necesitemos probar si algunas partes funcionan y para eso corremos algunas líneas de código, creando objetos en el ambiente. Entre intento e intento, probablemnte necesitemos borrar alguno o todos esos objetos que se crearon, para poder comenzar con un ambiente libre. Si deseamos borrar todos los objetos del ambiente podemos correr la sentencia rm(list = ls()) o hacer clic en el ícono de la escoba en el panel Environment. Si queremos eliminar sólo un objeto debemos ejecutar la función rm(), indicando entre paréntesis el identificador del objeto que deseamos borrar, por ejemplo:Todos los objetos generados viven temporalmente en la memoria de la computadora mientras dure la sesión de R en la que estamos trabajando. Si cerramos R, toda esa información desaparecerá. Muchas veces eso es algo deseable: una vez finalizado el programa, guardamos algún resultado que nos interese (por ejemplo, un conjunto de datos en un archivo de Excel) y todos los objetos del ambiente que fuimos necesitando en el camino son descartados. Sin embargo, en otras oportunidades nos interesa guardar de forma permanente en la computadora una copia de todo lo que se encuentra en el ambiente en un archivo dentro de alguna carpeta. Los archivos que contienen los objetos creados en R tienen extensión .RData. Estos archivos se generan con el ícono de guardar en la pestaña Environment o usando la función save.image(), que necesita que escribamos entre los paréntesis la carpeta donde guardaremos el archivo y el nombre elegido para el mismo, por ejemplo:Si por el contrario necesitamos importar al ambiente objetos que estén guardados en algún lugar de nuestra compu en un archivo .RData, podemos usar el ícono de abrir en la pestaña Environment o la función load(), por ejemplo:","code":"lugar_nacimiento <- \"Bombal\"\npeso_nacimiento <- 3.423\nvar1 <- 2\nvar2 <- \"Hola Mundo\"\nvar3 <- TRUE\nclass(var1)[1] \"numeric\"\nclass(var2)[1] \"character\"\nclass(var3)[1] \"logical\"\nis.numeric(var1)[1] TRUE\nis.numeric(var2)[1] FALSE\nis.character(var3)[1] FALSE\nis.logical(var3)[1] TRUE\nls()[1] \"var1\" \"var2\" \"var3\"\nrm(var1)\nsave.image(\"C:/Users/Ana/Documentos/Facultad/objetos.RData\")\nload(\"C:/Users/Ana/Documentos/Facultad/objetos.RData\")"},{"path":"objetos-y-operadores.html","id":"operadores","chapter":"2 Objetos y operadores","heading":"2.2 Operadores","text":"El desarrollo de un algoritmo involucra la necesidad de efectuar operaciones de distinto tipo entre los valores guardados en los objetos: suma, resta, concatenación de caracteres, comparaciones, etc. Los elementos que describen el tipo de operación realizar entre dos objetos se denominan operadores.","code":""},{"path":"objetos-y-operadores.html","id":"operadores-aritméticos","chapter":"2 Objetos y operadores","heading":"2.2.1 Operadores aritméticos","text":"Los operadores aritméticos permiten realizar operaciones matemáticas con datos de tipo numérico. continuación presentamos su simbología más comúnmente empleada la hora de expresarlos en pseudocódigo, junto con sus equivalentes en el lenguaje R:Tabla 2.1:  Operadores aritméticos.Los operadores aritméticos actúan con un orden de prioridad establecido, también conocido como orden de evaluación u orden de precedencia, tal como estamos acostumbrados en matemática. Las expresiones entre paréntesis se evalúan primero. Si hay paréntesis anidados se evalúan desde adentro hacia afuera. Dentro de una misma expresión, en R los operadores se evalúan en este orden:Potenciación (^)División entera y módulo (%/%, %%, y cualquier otro operador especial del tipo %...%)Multiplicación y división (*, /)Suma y resta (+, -)Si la expresión presenta operadores con igual nivel de prioridad, se evalúan de izquierda derecha. Veamos algunos ejemplos:Tabla 2.2:  Ejemplos de operaciones aritméticas según el orden de precedencia de R.","code":""},{"path":"objetos-y-operadores.html","id":"operadores-relacionales-o-de-comparación","chapter":"2 Objetos y operadores","heading":"2.2.2 Operadores relacionales o de comparación","text":"Los operadores relacionales sirven para comparar dos valores de cualquier tipo y dan como resultado un valor lógico: VERDADERO (T o TRUE en R) o FALSO (F o FALSE en R).Tabla 2.3:  Operadores relacionales o de comparación.Otros ejemplos:Es interesante notar que primero se evalúan las operaciones cada lado de los operadores relacionales y luego se hace la comparación. Es decir, los operadores aritméticos preceden los relacionales en el orden de prioridad. Por eso, en los ejemplos anteriores eran necesarios los paréntesis y podríamos poner directamente:Si bien en pseudocódigo podemos usar tanto = o == para probar la igualdad entre dos elementos, en R debemos usar = para este fin, puesto que = es un operador de comparación sino de asignación, parecido al <-.","code":"\na <- 3\nb <- 4\nd <- 2\ne <- 10\nf <- 15\n(a * b) == (d + e)[1] TRUE\n(a * b) != (f - b)[1] TRUE\na * b == d + e[1] TRUE\na * b != f - b[1] TRUE"},{"path":"objetos-y-operadores.html","id":"operadores-lógicos","chapter":"2 Objetos y operadores","heading":"2.2.3 Operadores lógicos","text":"Mientras que los operadores relacionales comparan cualquier tipo de valores, los operadores lógicos sólo toman operandos de tipo lógico y producen también un resultado lógico. Los operadores lógicos que utilizaremos son:Tabla 2.4:  Operadores lógicos.La operación de conjunción (Y) devuelve un valor VERDADERO sólo si son verdaderas ambas expresiones que vincula. Ejemplo: (3 > 2) Y (3 > 5) resulta en VERDADERO Y FALSO y esto es FALSO.La operación de disyunción (O) devuelve un valor VERDADERO si al menos una de las dos expresiones que vincula es verdadera. Ejemplo: (3 > 2) O (3 > 5) resulta en VERDADERO O FALSO y esto es VERDADERO.La operación de negación () niega un valor lógico, es decir, devuelve el opuesto. Ejemplo: (3 > 2) resulta en VERDADERO y esto es FALSO.Tanto para la conjunción como para la disyunción, R provee dos operadores, repitiendo o el símbolo correspondiente: && vs &; || vs |. Hay una diferencia entre ellos que por ahora viene al caso, pero vamos señalar que por ahora estaremos usando las versiones presentadas anteriormente: && y ||.La tabla de verdad o tabla de valores de verdad se utiliza para mostrar los resultados de estas operaciones lógicas:Tabla 2.5:  Operadores relacionales o de comparación.Con estos operadores es posible construir evaluaciones lógicas más elaboradas como los siguientes ejemplos:Evaluar si el valor de ancho está entre 5 y 7: (ancho > 5) Y (ancho < 7).\n\nancho <- 6.4\n(ancho > 5) && (ancho < 7)\n[1] TRUEEvaluar si el valor de ancho está entre 5 y 7: (ancho > 5) Y (ancho < 7).Establecer si una persona estudia Estadística o Economía: (carrera == \"Estadística\") O (carrera == \"Economía\").\n\ncarrera <- \"Administración\"\n(carrera == \"Estadística\") || (carrera == \"Economía\")\n[1] FALSEEstablecer si una persona estudia Estadística o Economía: (carrera == \"Estadística\") O (carrera == \"Economía\").Determinar si una persona estudia Estadística: (carrera == \"Estadística\").\n\ncarrera <- \"Administración\"\n!(carrera == \"Estadística\")\n[1] TRUEDeterminar si una persona estudia Estadística: (carrera == \"Estadística\").Verificar que el valor guardado en x sea igual 2 ni 3:\nOpción correcta 1: (x != 2) Y (x != 3)\n\n# Da verdadero porque x es ni 2 ni 3\nx <- 10\n(x != 2) && (x != 3)\n[1] TRUE\n\n# Da falso porque x es igual 3\nx <- 3\n(x != 2) && (x != 3)\n[1] FALSE\nOpción correcta 2: ((x == 2) O (x == 3))\n\n# Da verdadero porque x es ni 2 ni 3\nx <- 10\n!(x == 2 || x == 3)\n[1] TRUE\n\n# Da falso porque x es igual 3\nx <- 3\n!(x == 2 || x == 3)\n[1] FALSE\nOpción incorrecta: (x != 2) O (x != 3)\n\n# Da verdadero, porque al ser x igual 3, es distinto de 2,\n# haciendo que la primera parte sea verdadera \nx <- 3\n(x != 2) || (x != 3)\n[1] TRUEVerificar que el valor guardado en x sea igual 2 ni 3:Opción correcta 1: (x != 2) Y (x != 3)Opción correcta 2: ((x == 2) O (x == 3))Opción incorrecta: (x != 2) O (x != 3)Este último ejemplo se relaciona con las Leyes de Morgan: siendo b y c valores lógicos, se tiene:(b O c) es equivalente b Y c.(b Y c) es equivalente b O c.Es importante notar que todos los paréntesis usados en el código de R del ejemplo 4 son innecesarios, puesto que los operadores relacionales preceden los lógicos en el orden de prioridad. Sin embargo, veces preferimos usar paréntesis para que la lectura sea más sencilla. En el siguiente ejemplo, ambas expresiones son equivalentes:Para pensar: predecir el resultado de las siguientes operaciones y luego verificar:","code":"\nancho <- 6.4\n(ancho > 5) && (ancho < 7)[1] TRUE\ncarrera <- \"Administración\"\n(carrera == \"Estadística\") || (carrera == \"Economía\")[1] FALSE\ncarrera <- \"Administración\"\n!(carrera == \"Estadística\")[1] TRUE\n# Da verdadero porque x no es ni 2 ni 3\nx <- 10\n(x != 2) && (x != 3)[1] TRUE\n# Da falso porque x es igual a 3\nx <- 3\n(x != 2) && (x != 3)[1] FALSE\n# Da verdadero porque x no es ni 2 ni 3\nx <- 10\n!(x == 2 || x == 3)[1] TRUE\n# Da falso porque x es igual a 3\nx <- 3\n!(x == 2 || x == 3)[1] FALSE\n# Da verdadero, porque al ser x igual a 3, es distinto de 2,\n# haciendo que la primera parte sea verdadera \nx <- 3\n(x != 2) || (x != 3)[1] TRUE\nancho <- 6.4\n(ancho > 5) && (ancho < 7)[1] TRUE\nancho > 5 && ancho < 7[1] TRUE\nx <- 2\ny <- -2\nx > 0 && y < 0\nx > 0 || y < 0\n!(x > 0 && y < 0)"},{"path":"objetos-y-operadores.html","id":"evaluación-en-cortocircuito","chapter":"2 Objetos y operadores","heading":"2.2.3.1 Evaluación en cortocircuito","text":"Para evaluar la operación de conjunción x && y, en R se comienza por evaluar la expresión del primer operando x y si su resultado es FALSE ya se evalúa la expresión y del segundo operando. Esto es porque si x es FALSE, el resultado de x && y ya depende de y, será siempre FALSE. Por este motivo se dice que el operador && se evalúa en cortocircuito. La evaluación en cortocircuito evita realizar operaciones innecesarias6Por ejemplo:La operación de disyunción también se evalúa en cortocircuito, es decir, si se encuentra que uno de los operandos es TRUE, hace falta evaluar los restantes, puesto que el resultado general será TRUE:","code":"\nx <- 1\ny <- 2\n\n# La primera parte da TRUE, se continúa con la segunda, pero da error porque no\n# existe un objeto llamado z\n(y > x) && (x > z)Error in eval(expr, envir, enclos): object 'z' not found\n# La primera parte da FALSE, entonces toda la operación será FALSE, no se\n# continúa con la segunda parte, con lo cual no se intenta usar el objeto\n# inexistente z y no hay error\n(y < x) && (x > z)[1] FALSE\n# Es TRUE porque la primera parte es TRUE, sin evaluar la segunda, que daría\n# error\n(y > x) || (x > z)[1] TRUE\n# Como la primera parte es FALSE, debe evaluar la segunda, no encuentra a z y da\n# error\n(x > y) || (x > z)Error in eval(expr, envir, enclos): object 'z' not found"},{"path":"objetos-y-operadores.html","id":"orden-de-precedencia-completo-en-r","chapter":"2 Objetos y operadores","heading":"2.2.3.2 Orden de precedencia completo en R","text":"Resumiendo la información anterior, continuación se presenta el orden completo de precedencia de los operadores en R que utilizaremos (hay algunos más que pueden ver en ?Syntax):Tabla 2.6:  Orden de precedencia de los operadores en R.Dentro de una misma expresión, operadores con igual prioridad se evalúan de izquierda derecha.","code":""},{"path":"objetos-y-operadores.html","id":"entrada-y-salida-de-información","chapter":"2 Objetos y operadores","heading":"2.3 Entrada y salida de información","text":"En la resolución de problemas puede ser necesario que alguna fuente externa (como un usuario del programa) provea información. En estos casos se debe registrar dicha información como un valor que debe ser asignado una variable. Cuando escribamos nuestros algoritmos en pseudocódigo, para esto utilizaremos la acción LEER. Cuando deseamos mostrar un resultado en un mensaje empleamos la acción ESCRIBIR. Las palabras o frases literales que se desean mostrar en el mensaje deben estar encerradas entre comillas porque son cadenas de texto, mientras que si se desea mostrar el valor de una variable se debe escribir su identificador sin comillas.Por ahora, en R ejecutaremos la acción LEER mediante la asignación directa de un valor una variable través del operador <-. La acción ESCRIBIR puede ser ejecutada través de la función cat() si se quiere mostrar una frase compuesta. En los casos en los que sólo interesa mostrar un valor (sin escribir una frase) será necesario usar cat(), ya que sencillamente al correr el nombre de un objeto, su valor es mostrado en la consola. En otros casos usaremos la función print(). Ya iremos viendo la utilidad de cada una de estas opciones.Vamos completar el ejemplo del algoritmo para el cálculo del área de un círculo, integrando todo lo mencionado anteriormente:Pseudocódigo:En R:Nota: pi ya es una constante incorporada en R Base, en realidad es necesario crear esta constante y asignarle valor.","code":"ALGORITMO: \"Calcular área de un círculo\"\nCOMENZAR\n    CONSTANTE numérica pi\n    VARIABLE numérica radio, area\n    pi <- 3.14159265358979\n    LEER radio\n    area <- pi * radio^2\n    ESCRIBIR \"El área del círculo es \" area\nFIN\n# PROGRAMA: \"Calcular área de un círculo\" ---------------------------\n\npi <-  3.14159265358979\nradio <- 5\narea <- pi * radio^2\ncat(\"El área del círculo es\", area)El área del círculo es 78.53982"},{"path":"estructuras-de-control.html","id":"estructuras-de-control","chapter":"3 Estructuras de control","heading":"3 Estructuras de control","text":"Como mencionamos anteriormente, un algoritmo está compuesto por una sucesión ordenada de comandos que se ejecutan uno detrás de otro. Sin embargo, con frecuencia es necesario recurrir comandos especiales que alteran o controlan el orden en el que se ejecutan las acciones. Llamamos estructuras de control del flujo de las acciones al conjunto de reglas que permiten controlar el flujo de las acciones de un algoritmo o programa. Las mismas pueden clasificarse en secuenciales, condicionales e iterativas.","code":""},{"path":"estructuras-de-control.html","id":"estructuras-de-control-secuenciales","chapter":"3 Estructuras de control","heading":"3.1 Estructuras de control secuenciales","text":"Las estructuras secuenciales están compuestas por un número definido de acciones que se ubican en un orden específico y se suceden una tras otra. Los ejemplos que hemos discutido anteriormente están conformados por este tipo de estructura.","code":""},{"path":"estructuras-de-control.html","id":"estructuras-de-control-condicionales","chapter":"3 Estructuras de control","heading":"3.2 Estructuras de control condicionales","text":"En algunas partes de un algoritmo puede ser útil detenerse hacer una pregunta porque se llegó una situación en la que puede haber una o más opciones disponibles para continuar. Dependiendo de la respuesta la pregunta, que siempre deberá ser VERDADERO (TRUE) o FALSO (FALSE), el algoritmo seguirá ciertas acciones e ignorará otras. Estas preguntas y respuestas representan procesos de toma de decisión que conducen diferentes caminos dentro del algoritmo, permitiéndonos que la solución para el problema en cuestión sea flexible y se adapte distintas situaciones. Este tipo de estructuras de control de las acciones reciben el nombre de condicionales (o estructuras de selección) y pueden ser simples, dobles y múltiples.","code":""},{"path":"estructuras-de-control.html","id":"estructuras-condicionales-simples","chapter":"3 Estructuras de control","heading":"3.2.1 Estructuras condicionales simples","text":"Postulan una evaluación lógica y, si su resultado es VERDADERO, se procede ejecutar las acciones encerradas por esta estructura. Se describen en pseudocódigo con la siguiente sintaxis:La palabra SI indica el comando de evaluación lógica, <condición> indica la condición evaluar y Acción/es son las instrucciones que se realizarán sólo si se cumple la condición, es decir, si la evalución resulta en VERDADERO. Si la condición se verifica, se ejecuta ninguna acción y el algoritmo sigue su estructura secuencial continuación del FIN SI.En R, la estructura que nos permite realizar esto es:Por ejemplo, el siguiente algoritmo registra la edad de una persona y, en el caso de que sea mayor de edad, avisa que puede votar en las elecciones provinciales de Santa Fe:Notar que si bien el uso de sangrías en el código es opcional, decidimos emplearlo para facilitar su lectura. Mantener la prolijidad en nuestros programas es esencial.","code":"SI <condición> ENTONCES\n    Acción/es\nFIN SIif (condición) {\n    ...código para ejecutar acciones...\n}ALGORITMO: \"Analizar edad para votar\"\nCOMENZAR\n    VARIABLE numérica edad\n    LEER edad\n    SI edad >= 18 ENTONCES\n        ESCRIBIR \"Edad = \" edad \" años: puede votar\"\n    FIN SI\nFIN\n# Programa: \"Analizar edad para votar\" -------------------------------\nedad <- 21\nif (edad >= 18) {\n    cat(\"Edad =\", edad, \"años: puede votar\")\n}Edad = 21 años: puede votar"},{"path":"estructuras-de-control.html","id":"estructuras-condicionales-dobles","chapter":"3 Estructuras de control","heading":"3.2.2 Estructuras condicionales dobles","text":"Este tipo de estructura añade una acción ejecutarse en el caso de que la condición evaluada se verifique (es decir, devuelve el valor FALSO). La sintaxis es:La palabra ENTONCES antecede las acciones que se realizan si se cumple la condición y la expresión SI las que se realizan si se verifica la misma.En R se utiliza el comando else:Retomando el ejemplo anterior:","code":"SI <condición> ENTONCES\n  Acción/es\nSI NO\n  Acción/es\nFIN SIif (condición) {\n    ...código para ejecutar acciones...\n} else {\n    ...código para ejecutar acciones...\n}ALGORITMO: \"Analizar edad para votar\"\nCOMENZAR\n    VARIABLE numérica edad\n    LEER edad\n    SI edad >= 18 ENTONCES\n        ESCRIBIR \"Edad = \" edad \" años: puede votar\"\n    SI NO\n        ESCRIBIR \"Edad = \" edad \" años: no puede votar\"\n    FIN SI\nFIN\n# Programa: \"Analizar edad para votar\" -------------------------------\nedad <- 21\nif (edad >= 18) {\n    cat(\"Edad =\", edad, \"años: puede votar\")\n} else {\n    cat(\"Edad =\", edad, \"años: no puede votar\")\n}Edad = 21 años: puede votar"},{"path":"estructuras-de-control.html","id":"estructuras-condicionales-múltiples-o-anidadas","chapter":"3 Estructuras de control","heading":"3.2.3 Estructuras condicionales múltiples o anidadas","text":"Permiten combinar varias estructuras condicionales para establecer controles más complejos sobre el flujo de las acciones, representando una toma de decisión múltiple. Podemos ejemplificar la sintaxis de la siguiente forma:En la estructura anterior, hay una primera evaluación lógica en la cual si el resultado es VERDADERO, se ejecuta la Acción 1 y nada más. En cambio, si su resultado es FALSO, se procede realizar una segunda evaluación lógica, que da lugar la ejecución de la Acción 2 o de la Acción 3 si su resultado es VERDADERO o FALSO, respectivamente.Se debe notar que luego del primer SI comienza una nueva estructura completa de SI/ENTONCES/SI /FIN SI. Cada SI termina con su propio FIN SI. Al traducir esto R, se vuelve algo más sencillo:El último bloque de acciones (...Acción 3...) se evaluará si ninguna de las condiciones lógicas anteriores fue VERDADERO.En el ejemplo de la edad:","code":"SI <condición 1> ENTONCES\n  Acción 1\nSI NO\n  SI <condición 2> ENTONCES\n    Acción 2\n  SI NO\n    Acción 3\n  FIN SI\nFIN SIif (condición 1) {\n    ...Acción 1...\n} else if (condición 2) {\n    ...Acción 2...\n} else {\n    ...Acción 3...\n}ALGORITMO: \"Analizar edad para votar\"\nCOMENZAR\n    VARIABLE numérica edad\n    LEER edad\n    SI edad < 18 ENTONCES\n        ESCRIBIR \"Edad = \" edad \" años: no puede votar\"\n    SI NO\n        SI edad >= 70 ENTONCES\n            ESCRIBIR \"Edad = \" edad \" años: puede votar opcionalmente\"\n        SI NO\n            ESCRIBIR \"Edad = \" edad \" años: debe votar obligatoriamente\"\n        FIN SI\n    FIN SI\nFIN\n# Programa: \"Analizar edad para votar\" -------------------------------\nedad <- 21\nif (edad < 18) {\n    cat(\"Edad =\", edad, \"años: no puede votar\")\n} else if (edad >= 70) {\n    cat(\"Edad =\", edad, \"años: puede votar opcionalmente\")\n} else {\n    cat(\"Edad =\", edad, \"años: debe votar obligatoriamente\")\n}Edad = 21 años: debe votar obligatoriamente"},{"path":"estructuras-de-control.html","id":"estructuras-de-control-iterativas","chapter":"3 Estructuras de control","heading":"3.3 Estructuras de control iterativas","text":"Las estructuras de control iterativas son útiles cuando la solución de un problema requiere que se ejecute repetidamente un determinado conjunto de acciones. El número de veces que se debe repetir dicha secuencia de acciones puede ser fijo o puede variar dependiendo de algún dato o condición evaluar en el algoritmo.","code":""},{"path":"estructuras-de-control.html","id":"estructuras-de-control-iterativas-con-un-número-fijo-de-iteraciones","chapter":"3 Estructuras de control","heading":"3.3.1 Estructuras de control iterativas con un número fijo de iteraciones","text":"Se aplican cuando se conoce de antemano el número exacto de veces que se debe repetir una secuencia de acciones. También se conocen como bucles (loops) controlados por un conteo, ya que el algoritmo va contando la cantidad de repeticiones haciendo uso de una variable que recibe el nombre de variable de iteración, índice o conteo.Por ejemplo, imaginemos que queremos escribir un algoritmo que permita calcular la quinta potencia de cualquier número. Para esto, se debe tomar dicho número y multiplicarlo por sí mismo 5 veces. Por lo tanto, una posible solución es:Ya que sabemos que la multiplicación se debe repetir 5 veces, podemos resumir lo anterior con la siguiente estructura:La letra es la variable de iteración. Podríamos haber elegido otra letra u otra palabra en su lugar, pero emplear es una elección bastante común. En este ejemplo, su única función es ir contando la cantidad de veces que se repiten las acciones encerradas dentro de la estructura PARA/FIN PARA. El bloque de instrucciones se repite tantas veces como tarde en llegar 5 partiendo desde 1. Por convención, la variable de iteración la declaramos junto con las otras variables numéricas (como x y resultado).En R, el ejemplo anterior se implementa así:Dado que la variable de iteración toma un valor numérico que va cambiando en cada repetición del bloque, se puede aprovechar para hacer cuentas con el mismo. Por ejemplo, el siguiente algoritmo muestra la tabla del ocho:En lo anterior, \\n es un caracter especial que indica “salto de línea”. Si lo agregamos, los mensajes se imprimirían uno al lado del otro en el mismo renglón:De manera general, la sintaxis para este tipo de estructuras es:Dado un valor inicial <valor1> asignado la <variable>, esta se irá aumentando o disminuyendo según el paso <valor3> hasta llegar tomar el valor <valor2>. Si se indica el paso se asume que la variable de iteración aumenta de uno en uno. En R:Notar en el ejemplo de la quinta potencia que 1:5 es lo mismo que seq(1, 5, 1), pero podemos usar la función seq() en otros contextos más complejos, donde la variable de iteración puede pegar otros saltos en lugar de uno en uno.","code":"ALGORITMO: \"Calcular la quinta potencia\"\nCOMENZAR\n    VARIABLE numérica x, resultado\n    LEER x\n    resultado <- 1\n    resultado <- resultado * x\n    resultado <- resultado * x\n    resultado <- resultado * x\n    resultado <- resultado * x\n    resultado <- resultado * x\n    ESCRIBIR x \"elevado a la quinta es igual a\" resultado\nFINALGORITMO: \"Calcular la quinta potencia\"\nCOMENZAR\n    VARIABLE numérica x, resultado\n    LEER x\n    resultado <- 1\n    PARA i DESDE 1 HASTA 5 HACER\n        resultado <- resultado * x\n    FIN PARA\n    ESCRIBIR x \"elevado a la quinta es igual a\" resultado\nFIN\n# Programa: \"Calcular la quinta potencia\" ------------------------\nx <- 4\nresultado <- 1\nfor (i in 1:5) {\n    resultado <- resultado * x\n}\ncat(x, \"elevado a la quinta es igual a\", resultado)4 elevado a la quinta es igual a 1024ALGORITMO: \"Mostrar tabla del 8\"\nCOMENZAR\n    VARIABLE numérica resultado\n    PARA i DESDE 0 HASTA 10 HACER\n        resultado <- 8 * i\n        ESCRIBIR \"8 x\" i \"=\" resultado\n    FIN PARA\nFIN\n# Programa: \"Mostrar tabla del 8\" -------------------------------\nresultado <- 1\nfor (i in 0:10) {\n    resultado <- 8 * i\n    cat(\"8 x\", i, \"=\", resultado, \"\\n\")\n}8 x 0 = 0 \n8 x 1 = 8 \n8 x 2 = 16 \n8 x 3 = 24 \n8 x 4 = 32 \n8 x 5 = 40 \n8 x 6 = 48 \n8 x 7 = 56 \n8 x 8 = 64 \n8 x 9 = 72 \n8 x 10 = 80 \n# Programa: \"Mostrar tabla del 8\" -------------------------------\nfor (i in 0:10) {\n    resultado <- 8 * i\n    cat(\"8 x\", i, \"=\", resultado)\n}8 x 0 = 08 x 1 = 88 x 2 = 168 x 3 = 248 x 4 = 328 x 5 = 408 x 6 = 488 x 7 = 568 x 8 = 648 x 9 = 728 x 10 = 80PARA <variable> DESDE <valor1> HASTA <valor2> CON PASO <valor3> HACER\n    Acción/es\nFIN PARAfor (<variable> in seq(<valor1>, <valor2>, <valor3>)) {\n    ...Acción/es...\n}"},{"path":"estructuras-de-control.html","id":"estructuras-de-control-iterativas-con-un-número-indeterminado-de-iteraciones","chapter":"3 Estructuras de control","heading":"3.3.2 Estructuras de control iterativas con un número indeterminado de iteraciones","text":"En otras circunstancias se puede necesitar repetir un bloque de acciones sin conocer con exactitud cuántas veces, si que esto depende de algún otro aspecto del algoritmo. Las iteraciones pueden continuar mientras que o hasta que se verifique alguna condición, dando lugar dos tipos de estructuras. Estos casos también se conocen como bucles (loops) controlados por una condición.","code":""},{"path":"estructuras-de-control.html","id":"mientras-que","chapter":"3 Estructuras de control","heading":"3.3.2.1 Mientras que","text":"El conjunto de sentencias se repite mientras que se siga evaluando como VERDADERO una condición declarada al inicio del bloque. Cuando la condición ya se cumple, el proceso deja de ejecutarse. La sintaxis es:En R:Observaciones:La evaluación de la condición se lleva cabo antes de cada iteración, incluso antes de ejecutar el código dentro del bloque por primera vez. Si la condición es FALSO inicialmente, entonces las acciones en el cuerpo de la estructura se ejecutan nunca.La evaluación de la condición sólo se lleva cabo al inicio de cada iteración. Si la condición se vuelve FALSO en algún punto durante la ejecución de un bloque, el programa lo nota hasta que se termine de ejecutar el bloque y la condición sea evaluada antes de comenzar la próxima iteración.","code":"MIENTRAS QUE <condición> HACER\n   Acción/es a repetir\nFIN MIENTRASwhile(<condición>) {\n    ...Acción/es a repetir...\n}ALGORITMO: \"Dividir un número por 2 hasta encontrar un valor menor que 0.01\"\nCOMENZAR\n    VARIABLE numérica x\n    LEER x\n    MIENTRAS QUE x >= 0.01 HACER\n        x <- x / 2\n        ESCRIBIR x\n    FIN MIENTRAS\nFIN\nx <- 100\nwhile (x >= 0.01) {\n    x <- x / 2\n    cat(x, \"\\n\")\n}50 \n25 \n12.5 \n6.25 \n3.125 \n1.5625 \n0.78125 \n0.390625 \n0.1953125 \n0.09765625 \n0.04882812 \n0.02441406 \n0.01220703 \n0.006103516 "},{"path":"estructuras-de-control.html","id":"hasta-que","chapter":"3 Estructuras de control","heading":"3.3.2.2 Hasta que","text":"diferencia de la estructura MIENTRAS QUE, la estructura HASTA QUE repite el bloque de acciones hasta que se cumpla una condición, es decir, se ejecuta mientras que dicha condición sea evaluada como FALSA. La sintaxis es:Observación: con la estructura MIENTRAS QUE podría ser que el conjunto de sentencias nunca llegue ejecutarse si desde partida la condición evaluada ya es falsa. Por el contrario, en la estructura HASTA QUE el proceso se realiza al menos una vez, dado que la condición se evalúa al final.El ejemplo anterior empleando este tipo de estructura:En R este tipo de estructura se implementa con la sentencia repeat {}. Si bien continuación se muestra el correspondiente ejemplo, vamos utilizar esta estructura, debido que su escritura es más compleja y que generalmente es posible obtener el mismo resultado con un () {}.","code":"REPETIR\n   Acción/es\nHASTA QUE <condición>ALGORITMO: \"Dividir un número por 2 hasta encontrar un valor menor que 0.01\"\nCOMENZAR\n    VARIABLE numérica x\n    LEER x\n    REPETIR\n        x <- x / 2\n        ESCRIBIR x\n    HASTA QUE x < 0.01\nFIN\nx <- 100\nrepeat {\n    x <- x / 2\n    cat(x, \"\\n\")\n    if (x < 0.01) break\n}50 \n25 \n12.5 \n6.25 \n3.125 \n1.5625 \n0.78125 \n0.390625 \n0.1953125 \n0.09765625 \n0.04882812 \n0.02441406 \n0.01220703 \n0.006103516 "},{"path":"estructuras-de-control.html","id":"loops-infinitos","chapter":"3 Estructuras de control","heading":"3.3.2.3 Loops infinitos","text":"Con las sentencias de tipo MIENTRAS QUE se debe tener mucha precaución, puesto que si la evaluación lógica está bien especificada o nunca deja de ser evaluada como TRUE, se incurre en un loop infinito: el programa nunca deja de repetir el bloque (al menos hasta que la máquina se tilde o se produzca un error por desbordamiento de memoria, por ejemplo).La siguiente situación ilustra esto:","code":"var <- 9\nwhile (var < 10) {\n    var <- var - 1\n    cat(\"var =\", var, \"No puedo parar!!!\\n\")\n}\n\nvar = 8 No puedo parar!!!\nvar = 7 No puedo parar!!!\nvar = 6 No puedo parar!!!\nvar = 5 No puedo parar!!!\nvar = 4 No puedo parar!!!\nvar = 3 No puedo parar!!!\nvar = 2 No puedo parar!!!\nvar = 1 No puedo parar!!!\nvar = 0 No puedo parar!!!\nvar = -1 No puedo parar!!!\n..."},{"path":"estructuras-de-control.html","id":"ejemplos","chapter":"3 Estructuras de control","heading":"3.4 Ejemplos","text":"continuación se presentan algunos otros ejemplosNo necesariamente tiene que ser la variable iteradora, podemos darle cualquier nombre:\n\n(guau 1:5) {\n    print(guau)\n}\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\nLa sentencia print() también sirve para mostrar resultados. La ventaja con respecto cat() es que necesitamos agregar \\n para que el siguiente mensaje se escriba en un nuevo renglón, ya que lo agrega por sí sola sin que lo pidamos. La desventaja es que nos permite crear un mensaje combinando elementos separados entre comas, tal como se puede hacer con cat() (por ejemplo, cat(\"El valor de x es igual \", x)).necesariamente tiene que ser la variable iteradora, podemos darle cualquier nombre:La sentencia print() también sirve para mostrar resultados. La ventaja con respecto cat() es que necesitamos agregar \\n para que el siguiente mensaje se escriba en un nuevo renglón, ya que lo agrega por sí sola sin que lo pidamos. La desventaja es que nos permite crear un mensaje combinando elementos separados entre comas, tal como se puede hacer con cat() (por ejemplo, cat(\"El valor de x es igual \", x)).Acá tenemos un ejemplo de dos estructuras anidadas. En primer lugar, toma el valor 1, y entonces j varía de 1 2, generando las combinaciones = 1, j = 1; = 1, j = 2. Luego que j recorrió todo su campo de variación, se actualiza y pasa valer 2, generando las combinaciones = 2, j = 1; = 2, j = 2. Finalmente, se actualiza y pasa valer 3, generando las combinaciones = 3, j = 1; = 3, j = 2. Para cada combinación, se muestra el valor de la suma:\n\n(1:3) {\n    (j 1:2) {\n        suma <- + j\n        cat(\"vale\", , \"y j vale\", j, \". La suma es igual \", suma, \"\\n\") \n    }\n}\nvale 1 y j vale 1 . La suma es igual 2 \nvale 1 y j vale 2 . La suma es igual 3 \nvale 2 y j vale 1 . La suma es igual 3 \nvale 2 y j vale 2 . La suma es igual 4 \nvale 3 y j vale 1 . La suma es igual 4 \nvale 3 y j vale 2 . La suma es igual 5 Acá tenemos un ejemplo de dos estructuras anidadas. En primer lugar, toma el valor 1, y entonces j varía de 1 2, generando las combinaciones = 1, j = 1; = 1, j = 2. Luego que j recorrió todo su campo de variación, se actualiza y pasa valer 2, generando las combinaciones = 2, j = 1; = 2, j = 2. Finalmente, se actualiza y pasa valer 3, generando las combinaciones = 3, j = 1; = 3, j = 2. Para cada combinación, se muestra el valor de la suma:Sumar los números naturales del 1 al 5:\n\nsuma <- 0\n(1:5) {\n    suma <- suma + \n}\nsuma\n[1] 15Sumar los números naturales del 1 al 5:Sumar números naturales hasta que la suma pase el valor 100 y detenerse:\n\nsuma <- 0\n<- 1\n(suma < 100) {\n    suma <-  suma + \n    <- + 1\n}\nsuma\n[1] 105Sumar números naturales hasta que la suma pase el valor 100 y detenerse:Escribir todos los múltiplos de 8 menores que 150:\nALGORITMO: \"Múltiplos de 8 menores 150\"\nCOMENZAR\n    VARIABLE numérica multiplo\n    multiplo <- 8\n    MIENTRAS QUE multiplo < 150 HACER\n        ESCRIBIR multiplo\n        multiplo <- multiplo + 8\n    FIN MIENTRAS\nFIN\n\n# Programa: \"Múltiplos de 8 menores 150\" ------------------------\nmultiplo <- 8\n(multiplo < 150) {\n    print(multiplo)\n    multiplo <- multiplo + 8\n}\n[1] 8\n[1] 16\n[1] 24\n[1] 32\n[1] 40\n[1] 48\n[1] 56\n[1] 64\n[1] 72\n[1] 80\n[1] 88\n[1] 96\n[1] 104\n[1] 112\n[1] 120\n[1] 128\n[1] 136\n[1] 144Escribir todos los múltiplos de 8 menores que 150:","code":"\nfor (guau in 1:5) {\n    print(guau)\n}[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\nfor (i in 1:3) {\n    for (j in 1:2) {\n        suma <- i + j\n        cat(\"i vale\", i, \"y j vale\", j, \". La suma es igual a\", suma, \"\\n\") \n    }\n}i vale 1 y j vale 1 . La suma es igual a 2 \ni vale 1 y j vale 2 . La suma es igual a 3 \ni vale 2 y j vale 1 . La suma es igual a 3 \ni vale 2 y j vale 2 . La suma es igual a 4 \ni vale 3 y j vale 1 . La suma es igual a 4 \ni vale 3 y j vale 2 . La suma es igual a 5 \nsuma <- 0\nfor (i in 1:5) {\n    suma <- suma + i\n}\nsuma[1] 15\nsuma <- 0\ni <- 1\nwhile (suma < 100) {\n    suma <-  suma + i\n    i <- i + 1\n}\nsuma[1] 105ALGORITMO: \"Múltiplos de 8 menores a 150\"\nCOMENZAR\n    VARIABLE numérica multiplo\n    multiplo <- 8\n    MIENTRAS QUE multiplo < 150 HACER\n        ESCRIBIR multiplo\n        multiplo <- multiplo + 8\n    FIN MIENTRAS\nFIN\n# Programa: \"Múltiplos de 8 menores a 150\" ------------------------\nmultiplo <- 8\nwhile (multiplo < 150) {\n    print(multiplo)\n    multiplo <- multiplo + 8\n}[1] 8\n[1] 16\n[1] 24\n[1] 32\n[1] 40\n[1] 48\n[1] 56\n[1] 64\n[1] 72\n[1] 80\n[1] 88\n[1] 96\n[1] 104\n[1] 112\n[1] 120\n[1] 128\n[1] 136\n[1] 144"},{"path":"descomposición-algorítmica.html","id":"descomposición-algorítmica","chapter":"4 Descomposición algorítmica","heading":"4 Descomposición algorítmica","text":"Un principio fundamental en la resolución de un problema es intentar descomponerlo en partes más pequeñas, que puedan ser más fáciles de afrontar. Este concepto también se aplica en la programación. Nuestros algoritmos pueden descomponerse en subalgoritmos que den solución un aspecto del problema, de menor extensión. Este proceso se conoce como descomposición algorítmica o descomposición modular. Cada subalgoritmo debe ser independiente de los demás y su vez podría seguir descomponiéndose en partes más sencillas en lo que se conoce como refinamiento sucesivo. Si un programa es muy largo se corre el riesgo de que sea muy difícil de entender como un todo, pero siempre se lo puede dividir en secciones más simples y manejables. Un subalgoritmo se escribe una vez y luego es utilizado por todos aquellos algoritmos que lo necesiten.Cada vez que, como parte de la resolución de un problema, desde un algoritmo se solicita que se realicen las acciones establecidas por un subalgoritmo, se dice que se lo está invocando o llamando. Al algoritmo que invoca los subalgoritmos veces le decimos algoritmo principal para darle un mayor énfasis la idea que, desde el curso de acción principal, cada tanto se delega la ejecución de algunas al subalgoritmo.El empleo de subalgoritmos, desarrollando por separado ciertas partes del problema, resulta especialmente ventajoso en los casos siguientes:En algoritmos complejos: si el algoritmo, y luego el programa, se escribe todo seguido y en un único archivo de código, resulta muy complicado de entender, porque se pierde la visión de su estructura global dada la gran cantidad de operaciones que lo conforman. Aislando ciertas partes como subalgoritmos separados se reduce la complejidad.Cuando se repiten operaciones análogas: si la resolución de un problema requiere realizar una tarea que se repite varias veces en el algoritmo, podemos definir dicha tarea como un subalgoritmo por separado. De esta manera, su código se escribirá sólo una vez aunque se use en muchos puntos del programa.En este capítulo hay algunas secciones indicadas como “opcionales” y algunos comentarios agregados como notas al pie. Estas partes añaden información para quienes estén interesados en saber un poco más, pero su contenido será requerido en la práctica ni en las evaluaciones.","code":""},{"path":"descomposición-algorítmica.html","id":"tipos-de-subalgoritmos","chapter":"4 Descomposición algorítmica","heading":"4.1 Tipos de subalgoritmos","text":"En el mundo de la programación existen muchos términos para definir distintos tipos de subalgoritmos: subrutinas, funciones, procedimientos, métodos, subprogramas, etc. es posible obtener una definición que capture todas las variantes que existen en el uso de estos términos debido que el signficado de cada uno de ellos varía según el paradigma\n7\ny el lenguaje de programación escogidos. Qué se entiende por cada uno de ellos depende muchas veces del paradigma de programación empleado y del lenguaje escogido, por lo cual existe una definición lo suficientemente general para cada uno.Sin embargo, suele haber bastante consenso en distinguir, dentro de los subalgoritmos, las funciones y los procedimientos de esta forma:Una función es un subalgoritmo que al ser evaluado devuelve un único resultado (por ejemplo, un valor numérico) que es utilizado en el algoritmo principal que lo invoca.Un procedimiento es un subalgoritmo que al ser evaluado devuelve un valor, sino que produce efectos secundarios en el ambiente del algoritmo principal que lo invoca. Persigue el objetivo de ayudar en la modularidad del programa.","code":""},{"path":"descomposición-algorítmica.html","id":"funciones","chapter":"4 Descomposición algorítmica","heading":"4.2 Funciones","text":"Una función es un subalgoritmo que devuelve un único resultado partir de otros valores provistos. El valor que la función devuelve define su tipo, de modo que una función puede ser de tipo numérica, caracter o lógica 8.Para ejemplificar, podemos decir que la noción de función en programación se asemeja la idea matemática de función de una o más variables. Por ejemplo, podemos pensar en la función \\(f(x, y) = x^2 + 3y\\) (ejemplo 1). Si queremos saber cuál es el valor numérico de la función \\(f\\) cuando \\(x\\) toma el valor \\(4\\) e \\(y\\) toma el valor \\(5\\), reemplazamos en la expresión anterior las variables por los valores mencionados y obtenemos: \\(f(4, 5) = 4^2 + 3 \\times 5 = 31\\).Podemos definir dicha función en pseudocódigo de la siguiente manera:El primer renglón de la definición comienza con la palabra clave FUNCIÓN y termina, luego de los dos puntos, con la palabra numérico para indicar que esta función devuelve como resultado un valor numérico.En el medio se encuentra el nombre elegido para la función (f), seguido por la declaración entre paréntesis de los parámetros o argumentos que la función necesita para operar, es decir, el input o información de entrada con la cual se realizarán las operaciones. Se dice que \\(x\\) e \\(y\\) son los parámetros formales o ficticios, ya que tienen un valor asignado en sí mismos sino que permiten expresar de manera general las acciones que la función ejecuta. Describen lo que uno diría en palabras: “hay que tomar \\(x\\), elevarlo al cuadrado y sumarle la \\(y\\) multiplicada por 3”. Entre los paréntesis también se aclara que estos parámetros formales son de tipo numérico.Los valores en los cuales se quiere evaluar la función se llaman parámetros actuales o reales. Por ejemplo, si nos interesa calcular \\(f(4, 5)\\), los valores \\(4\\) y \\(5\\) son los parámetros actuales y se establece una correspondencia entre el parámetro formal \\(x\\) y el actual \\(4\\), así como entre la \\(y\\) y el \\(5\\). El resultado que se obtiene, como observamos antes, es \\(31\\) y este es el valor que la función devuelve.La definición anterior también puede ser expresada como:Aquí notamos que debemos declarar x e y puesto que son los parámetros de la función (quedan declarados entre los paréntesis en la primera línea). Sin embargo, sí declaramos cualquier otra nueva variable que sea creada dentro de la función, por ejemplo, la variable resultado.De manera general, la definición de una función es:La palabra clave DEVOLVER provoca la inmediata finalización de la ejecución de la función e indica cuál es el resultado de la misma, cuyo tipo debe coincidir con el tipo de función declarado en el encabezado. La acción DEVOLVER se puede insertar en cualquier punto del cuerpo de la función y, además, es posible utilizar más de una sentencia DEVOLVER en una misma función, aunque sólo una llegue ejecutarse. Esto puede verse en el siguiente ejemplo (ejemplo 2):Para usar una función en un algoritmo, se la invoca escribiendo su nombre seguido por los valores actuales entre paréntesis, separados por coma. Esta invocación representa un valor que puede ser usado como operando en otra expresión. Por ejemplo:Al invocar una función es obligatorio que los valores suministrados para los argumentos actuales entre los paréntesis correspondan en cantidad, tipo y orden con los argumentos formales de la definición de la función. Es por esto que los siguientes casos son ejemplos de un uso incorrecto de funciones en el algoritmo principal:Para motivar el uso de una buena práctica que ayude distinguir entre las acciones de los subalgoritmos y del algoritmo, vamos escribir los subalgoritmos antes y por fuera del algoritmo principal9. Consideremos el ejemplo 3 mostrado continuación. Primero definimos los subalgoritmos que necesitaremos (son los de los ejemplos 1 y 2) y luego escribiremos un algoritmo principal que hace uso de ellos para resolver un problema en particular:¿Qué mensaje escribe el algoritmo anterior?","code":"FUNCIÓN f(x: numérico, y: numérico): numérico\nCOMENZAR\n    DEVOLVER x^2 + 3 * y\nFIN FUNCIÓNFUNCIÓN f(x: numérico, y: numérico): numérico\nCOMENZAR\n    VARIABLE numérica resultado\n    resultado <- x^2 + 3 * y\n    DEVOLVER resultado\nFIN FUNCIÓNFUNCIÓN nombre(lista de parámetros formales): tipo de resultado\nCOMENZAR\n    Declaración de variables\n    Acciones\n    DEVOLVER valor\nFIN FUNCIÓNFUNCIÓN maximo(num1: numérico, num2: numérico): numérico\nCOMENZAR\n    SI num1 >= num2 ENTONCES\n        DEVOLVER num1\n    SI NO\n        DEVOLVER num2\n    FIN SI\nFIN FUNCIÓNALGORITMO: \"Hallar el máximo entre dos valores y restarle 100\"\nCOMENZAR\n    VARIABLE numérica x, y, rtdo\n    LEER x, y\n    rtdo <- maximo(x, y) - 100\n    ESCRIBIR \"El resultado es \" rtdo\nFINALGORITMO: \"Incorrecto por proveer pocos argumentos para la función\"\nCOMENZAR\n    VARIABLE numérica x, y, rtdo\n    LEER x, y\n    rtdo <- maximo(x) - 100\n    ESCRIBIR \"El resultado es \" rtdo\nFIN\n\nALGORITMO: \"Incorrecto por proveer valores de tipo caracter para la función\"\nCOMENZAR\n    VARIABLE numérica rtdo\n    VARIABLE caracter x, y\n    x <- \"chau\"\n    y <- \"hola\"\n    rtdo <- maximo(x, y) - 100\n    ESCRIBIR \"El resultado es \" rtdo\nFIN\n\nALGORITMO: \"Incorrecto por no proveer argumentos para la función\"\nCOMENZAR\n    VARIABLE numérica x, y, rtdo\n    LEER x, y\n    rtdo <- maximo - 100\n    ESCRIBIR \"El resultado es \" rtdo\nFIN---------------------------------------------------------------\nSUBALGORITMOS\n---------------------------------------------------------------\n\nFUNCIÓN f(x: numérico, y: numérico): numérico\nCOMENZAR\n    DEVOLVER x^2 + 3 * y\nFIN FUNCIÓN\n\nFUNCIÓN maximo(num1: numérico, num2: numérico): numérico\nCOMENZAR\n    SI num1 >= num2 ENTONCES\n        DEVOLVER num1\n    SI NO\n        DEVOLVER num2\n    FIN SI\nFIN FUNCIÓN\n\n--------------------------------------------------------------\nALGORITMO PRINCIPAL\n--------------------------------------------------------------\n\nALGORITMO: \"Realizar  operaciones matemáticas muy importantes\"\nCOMENZAR\n    VARIABLE numérica rtdo1, rtdo2, rtdo3\n    rtdo1 <- f(2, 5)\n    rtdo2 <- f(3, 10)\n    rtdo3 <- maximo(rtdo1, rtdo2) + 20\n    ESCRIBIR \"El resultado es \" rtdo3\nFIN"},{"path":"descomposición-algorítmica.html","id":"funciones-en-r","chapter":"4 Descomposición algorítmica","heading":"4.3 Funciones en R","text":"En la sección anterior vimos cómo definir funciones en pseudocódigo. Antes de pasar ver cómo programar nuestras funciones en R, vamos comentar algunas cuestiones acerca de las funciones que R ya trae disponibles como parte de su funcionalidad básica.","code":""},{"path":"descomposición-algorítmica.html","id":"funciones-predefinidas-de-r","chapter":"4 Descomposición algorítmica","heading":"4.3.1 Funciones predefinidas de R","text":"R, como todo lenguaje de programación, tiene funciones predefinidas, es decir, sentencias que se encargan de realizar alguna actividad. Ya estuvimos usando algunas de ellas, por ejemplo, cuando hemos necesitado mostrar algún mensaje usamos las funciones cat() o print()10. Además, existen muchas otras funciones predefinidas, como todas aquellas que se necesitan para realizar ciertas operaciones matemáticas:En los ejemplos anteriores, 100 representa un valor numérico que se pasa como argumento la función para que la misma opere. Algunas funciones predefinidas en R pueden trabajar con más de un argumento, en cuyo caso hay que enumerarlos dentro de los paréntesis, separados con comas. Por ejemplo, si en lugar de calcular el logaritmo natural (cuya base es la constante matemática \\(e\\)), queremos calcular un logaritmo en base 10, podemos hacer lo siguiente:¿Cómo sabemos que la función log() se puede usar de esa forma, cambiando el valor de la base con respecto la cual toma el logaritmo? Lo aprendemos al leer el manual de ayuda de R. Toda función predefinida de R viene con un instructivo que detalla cómo se usa, qué argumentos incluye y otras aclaraciones. Lo encontramos en la pestaña de Ayuda (Help) en el panel de abajo la derecha en RStudio. Otras formas de abrir la página de ayuda sobre una función es correr en la consola alguna de estas sentencias:Esa página de ayuda tiene bastante información, porque reúne información sobre muchas funciones relacionadas con logaritmos y exponenciales, pero podemos detenernos en la parte resaltada que se muestra continuación:\nFigura 4.1: Captura de pantalla de la ayuda sobre la función log()\nEn la sección Usage (“uso”) descubrimos que la función log() puede usarse con dos argumentos: x y base. En la sección Arguments entendemos que x es el número al cual le vamos sacar el logaritmo y base es la base con respecto la cual se toma el logaritmo. Por eso, al correr log(100, 10), estamos calculando el logaritmo de x = 100 con base = 10.Vemos, además, una diferencia en la forma en que x y base aparecen en la descripción: log(x, base = exp(1)). Cuando un argumento tiene un signo = significa que tiene asignado un valor por default y que es necesario usarlo. Por eso, cuando corremos log(100) estamos calculando el logaritmo de x = 100 con la base elegida por R por defecto: base = exp(1), que es la forma que tiene R de nombrar la constante \\(e = 2.718282...\\) (es el logaritmo natural). Si quiero cambiar la base, debo proveer un valor, por ejemplo, log(100, 10). Por el contrario, el argumento x tiene asignado un valor por default. Eso significa que obligatoriamente tenemos que proveer un valor para el mismo.R también permite usar una función escribiendo los nombres de los argumentos (es decir, detallando tanto los parámetros formales como los actuales), lo cual muchas veces es muy esclarecedor:Es más, si escribimos los nombres de los parámetros explícitamente, podemos cambiar su orden, sin alterar el resultado:Si escribimos los nombres, el orden importa:Al tener los nombres indicados explícitamente, R hace corresponder los parámetros formales x y base con los valores provistos en ese orden: en el primer caso x recibe el valor 100 y base, el valor 10, mientras que en el segundo caso es al revés.Finalmente, se debe observar que es necesario invocar la función escribiendo de forma directa los valores entre los paréntesis, sino que en su lugar pueden ir variables:","code":"\n# Raiz cuadrada\nsqrt(100)[1] 10\n# Valor absoluto\nabs(100)[1] 100\n# Función exponencial\nexp(100)[1] 2.688117e+43\n# Logaritmo natural\nlog(100)[1] 4.60517\n# Logaritmo de 100 en base 10\nlog(100, 10)[1] 2\nhelp(log)\n?log\nlog(x = 100, base = 10)[1] 2\nlog(base = 10, x = 100)[1] 2\nlog(100, 10)[1] 2\nlog(10, 100)[1] 0.5\nx <- 100\ny <- x / 2\nz <- 4\nlog(x - y, 4)       # Log en base 4 de x - y[1] 2.821928"},{"path":"descomposición-algorítmica.html","id":"definición-de-nuevas-funciones-en-r","chapter":"4 Descomposición algorítmica","heading":"4.3.2 Definición de nuevas funciones en R","text":"Ahora que ya hemos visto cómo se trabaja con funciones en R de manera general, vamos aprender definir nuestras propias funciones. Recordemos el subalgoritmo del ejemplo 1:En R, definimos esta función así:\nFigura 4.2: Estructura de una función en R\nLa estructura general es:Debemos:Elegir un nombreAl lado del nombre, colocar el operador de asignación (<-) para asociar ese nombre la definición de una función.Escribir la sentencia function(...) {...}, donde entre paréntesis se definen todos los parámetros formales separados con coma y entre llaves el conjunto de acciones englobar.El valor que la función debe arrojar como resultado se encierra dentro de la sentencia return(), que indica el fin de la ejecución.Una vez que la definición de la función es ejecutada, pasa formar parte de los elementos que conforman al ambiente, como se puede apreciar al verla listada como un objeto más en el panel Environment de RStudio 11. partir de este momento, podemos utilizarla, como parte de otro programa. Para invocarla, escribimos el nombre de la función y entre paréntesis los valores que nos interesan para el cálculo (parámetros actuales). Por ejemplo:Recordando lo discutido en la sección anterior, podemos apreciar que los siguientes usos de la función f() son equivalentes:Sin embargo, son equivalentes los siguientes:continuación, podemos ver casos que generan error por hacer un uso incorrecto de la función (¿por qué?):Retomemos ahora el ejemplo 3. Mencionamos que es importante distinguir entre la definición de los subalgoritmos y la de un algoritmo principal que los invoca:Esta distinción también es importante en R: la definición de las funciones debe ejecutarse antes de que las mismas sean llamadas desde el programa principal. Así, para traducir el pseudocódigo anterior R, podríamos crear un archivo de código (llamado, por ejemplo, ejemplo3.R) con el siguiente contenido:","code":"FUNCIÓN f(x: numérico, y: numérico): numérico\nCOMENZAR\n    VARIABLE numérica resultado\n    resultado <- x^2 + 3 * y\n    DEVOLVER resultado\nFIN FUNCIÓN\nf <- function(x, y) {\n    resultado <- x^2 + 3 * y\n    return(resultado)\n}nombre <- function(argumentos) {\n  ... sentencias de R ...\n}\n# Ejemplos de uso de la función f\nf(4, 5)[1] 31\nf(6, -5)[1] 21\nf(0, 0)[1] 0\nf(4, 5)[1] 31\nf(x = 4, y = 5)[1] 31\nf(y = 5, x = 4)[1] 31\n# Siguiendo el orden de definición, x recibe el valor 4, y recibe el 5:\nf(4, 5)[1] 31\n# Siguiendo el orden de definición, x recibe el valor 5, y recibe el 4:\nf(5, 4)[1] 37\n# Error por omitir un argumento de uso obligatorio (x recibe 4, falta y)\nf(4)Error in f(4): argument \"y\" is missing, with no default\n# Error por proveer más argumentos de los declarados en la definición\nf(4, 5, 6)Error in f(4, 5, 6): unused argument (6)---------------------------------------------------------------\nSUBALGORITMOS\n---------------------------------------------------------------\n\nFUNCIÓN f(x: numérico, y: numérico): numérico\nCOMENZAR\n    DEVOLVER x^2 + 3 * y\nFIN FUNCIÓN\n\nFUNCIÓN maximo(num1: numérico, num2: numérico): numérico\nCOMENZAR\n    SI num1 >= num2 ENTONCES\n        DEVOLVER num1\n    SI NO\n        DEVOLVER num2\n    FIN SI\nFIN FUNCIÓN\n\n--------------------------------------------------------------\nALGORITMO PRINCIPAL\n--------------------------------------------------------------\n\nALGORITMO: \"Realizar  operaciones matemáticas muy importantes\"\nCOMENZAR\n    VARIABLE numérica rtdo1, rtdo2, rtdo3\n    rtdo1 <- f(2, 5)\n    rtdo2 <- f(3, 10)\n    rtdo3 <- maximo(rtdo1, rtdo2) + 20\n    ESCRIBIR \"El resultado es \" rtdo3\nFIN\n# ---------------------------------------------------------------\n# DEFINICIÓN DE FUNCIONES\n# ---------------------------------------------------------------\n\nf <- function(x, y) {\n    resultado <- x^2 + 3 * y\n    return(resultado)\n}\n\nmaximo <- function(num1, num2) {\n    if (num1 > num2) {\n        return(num1)\n    } else {\n        return(num2)\n    }\n}\n\n# ---------------------------------------------------------------\n# PROGRAMA PRINCIPAL\n# ---------------------------------------------------------------\n\nrtdo1 <- f(2, 5)\nrtdo2 <- f(3, 10)\nrtdo3 <- maximo(rtdo1, rtdo2) + 20\ncat(\"El resultado es\", rtdo3)El resultado es 59"},{"path":"descomposición-algorítmica.html","id":"documentación-de-los-subalgoritmos","chapter":"4 Descomposición algorítmica","heading":"4.4 Documentación de los subalgoritmos","text":"En el contexto de la programación, documentar significa escribir indicaciones para que otras personas puedan entender lo que queremos hacer en nuestro código o para que sepan cómo usar nuestras funciones. Por ejemplo, como vimos antes todas funciones predefinidas de R están documentadas para que podamos buscar ayuda si la necesitamos. Cuando estamos creando nuestras propios subalgoritmos, es importante que también incluyamos comentarios para guiar otras personas (y nosotros mismos en el futuro si nos olvidamos) para qué y cómo se usa lo que estamos desarrollando.Para ilustrar esto, vamos recordar que en la práctica 2 escribimos un algoritmo para el cálculo de factoriales. Dado que los mismos son muy útiles en variadas aplicaciones, podemos escribir un subalgortimo que se encargue de obtenerlos. Luego, escribiremos un algoritmo para mostrar todos los factoriales de los números 1 10.En R:","code":"---------------------------------------------------------------\nSUBALGORITMOS\n---------------------------------------------------------------\n\n#-------------------------------------------------------\n# Función factorial\n# Calcula el factorial de números enteros no negativos\n# Entrada:\n#   - n, entero no negativo\n# Salida:\n#   - el factorial de n\n#-------------------------------------------------------\nFUNCIÓN factorial(n: numérico): numérico\n    VARIABLE numérica resultado\n    resultado <- 1\n    SI n > 0 ENTONCES\n        PARA i DESDE 1 HASTA n HACER\n            resultado <- resultado * i\n        FIN PARA\n    FIN SI\n    DEVOLVER resultado\nFIN FUNCIÓN\n\n---------------------------------------------------------------\nALGORITMO PRINCIPAL\n---------------------------------------------------------------\n\nALGORITMO: \"Mostrar los factoriales de los 10 primeros naturales\"\nCOMENZAR\n    PARA j DESDE 1 HASTA 10 HACER\n        ESCRIBIR \"El factorial de \" j \" es igual a \" factorial(j)\n    FIN PARA\nFIN\n# ---------------------------------------------------------------\n# DEFINICIÓN DE FUNCIONES\n# ---------------------------------------------------------------\n\n#-----------------------------------------------------\n# Función factorial\n# Calcula el factorial de números enteros no negativos\n# Entrada:\n#       - n, entero no negativo\n# Salida:\n#       - el factorial de n\n#-----------------------------------------------------\nfactorial <- function(n) {\n    resultado <- 1\n    if (n > 0) {\n        for (i in 1:n) {\n            resultado <- resultado * i\n        }\n    }\n    return(resultado)\n}\n\n# ---------------------------------------------------------------\n# PROGRAMA PRINCIPAL: Mostrar los factoriales de los 10 primeros naturales\n# ---------------------------------------------------------------\nfor (j in 1:10) {\n    cat(\"El factorial de\", j, \"es igual a\", factorial(j), \"\\n\")\n}El factorial de 1 es igual a 1 \nEl factorial de 2 es igual a 2 \nEl factorial de 3 es igual a 6 \nEl factorial de 4 es igual a 24 \nEl factorial de 5 es igual a 120 \nEl factorial de 6 es igual a 720 \nEl factorial de 7 es igual a 5040 \nEl factorial de 8 es igual a 40320 \nEl factorial de 9 es igual a 362880 \nEl factorial de 10 es igual a 3628800 "},{"path":"descomposición-algorítmica.html","id":"pasaje-de-parámetros","chapter":"4 Descomposición algorítmica","heading":"4.5 Pasaje de parámetros","text":"Los algoritmos y subalgoritmos comunican información entre sí través de los parámetros o argumentos. Esta comunicación recibe el nombre de pasaje de argumentos y se puede realizar de dos formas: por valor o por referencia. Algunos lenguajes de programación trabajan con uno u otro sistema, mientras que otros lenguajes permiten el uso de ambos.","code":""},{"path":"descomposición-algorítmica.html","id":"pasaje-por-valor","chapter":"4 Descomposición algorítmica","heading":"4.5.1 Pasaje por valor","text":"En este caso, los argumentos representan valores que se transmiten desde el algoritmo hacia el subalgoritmo. El pasaje por valor implica que los objetos del algoritmo provistos como argumentos en la llamada al subalgoritmo serán modificados por la ejecución del mismo. Este sistema funciona de la siguiente forma:Se evalúan los argumentos actuales usados en la invocación al subalgoritmo.Los valores obtenidos se copian en los argumentos formales dentro del subalgoritmo.Los argumentos formales se usan como variables dentro del subalgoritmo. Aunque los mismos sean modificados (por ejemplo, se les asignen nuevos valores), se modifican los argumentos actuales en el algoritmo, sólo sus copias dentro del subalgoritmo.Veamos un ejemplo:Si el pasaje de argumentos se hace por valor, los cambios producidos en el cuerpo de la función sobre los parámetros formales son transmitidos los parámetros actuales en el algoritmo principal. Esto significa que los formales son una “copia” de los actuales. Los pasos que sigue el algoritmo son:En el algoritmo principal, se asignan los valores: = 3, b = 5.Al invocar la función, se establece la correspondencia: x = 3, y = 5 - 3 = 2.Primera línea de la función: x = 3 + 1 = 4.La función devuelve el valor x + y = 4 + 2 = 6.De regreso en el algoritmo principal: c recibe el valor 6.El algoritmo escribe: 3 5 6.En R, el pasaje de argumentos es por valor. Por lo tanto, este tipo de comportamiento es lo que vemos cuando implementamos el ejemplo discutido12:","code":"---------------------------------------------------------------\nSUBALGORITMOS\n---------------------------------------------------------------\n\nFUNCIÓN fun(x: numérico, y: numérico): numérico\n    x <- x + 1\n    DEVOLVER x + y\nFIN FUNCIÓN\n\n---------------------------------------------------------------\nALGORITMO PRINCIPAL\n---------------------------------------------------------------\n\nALGORITMO: \"Ejemplo de pasaje de argumentos\"\nCOMENZAR\n    VARIABLE numérica a, b, c\n    a <- 3\n    b <- 5\n    c <- fun(a, b - a)\n    ESCRIBIR a b c\nFIN\n# ---------------------------------------------------------------\n# DEFINICIÓN DE FUNCIONES\n# ---------------------------------------------------------------\n\nfun <- function(x, y) {\n    x <- x + 1\n    return(x + y)\n}\n\n# ---------------------------------------------------------------\n# PROGRAMA PRINCIPAL\n# ---------------------------------------------------------------\n\na <- 3\nb <- 5\nc <- fun(a, b - a)\ncat(a, b, c)3 5 6"},{"path":"descomposición-algorítmica.html","id":"pasaje-por-referencia","chapter":"4 Descomposición algorítmica","heading":"4.5.2 Pasaje por referencia","text":"En este caso, los argumentos sólo representan valores que se transmiten desde el algoritmo hacia el subalgoritmo, sino también desde el subalgoritmo al algoritmo. Esto sirve en las situaciones en las que se quiere que el subalgoritmo pueda modificar las variables del algoritmo principal que se pasaron como argumentos. De esta manera, un subalgoritmo puede producir uno o varios efectos secundarios en el ambiente del algoritmo.Si un parámetro se pasa por referencia, todos los cambios que experimente dentro del subalgoritmo se producirán también en la variable externa pasada como argumento. Esto se debe que la información que es pasada desde el algoritmo al subalgoritmo es la dirección en la memoria de la computadora donde se halla almacenado el parámetro actual, es decir, se pasa una referencia la variable, el valor que contiene.Este sistema funciona de la siguiente forma:Se seleccionan las variables usadas como argumentos actuales.Se asocia cada variable con el argumento formal correspondiente.Los cambios que experimenten los argumentos formales se reflejan también en los argumentos actuales de origen.Retomemos el ejemplo anterior:Si el pasaje de argumentos se hace por referencia, los pasos que sigue el algoritmo son:En el algoritmo principal, se asignan los valores: = 3, b = 5.Al invocar la función, se establece la correspondencia: x = 3, y = 5 - 3 = 2.Primera línea de la función: x = 3 + 1 = 4. El parámetro actual asociado con x, , sufre el mismo cambio y recibe el valor 4 (= 4).La función devuelve el valor x + y = 4 + 2 = 6.De regreso en el algoritmo principal: c recibe el valor 6.El algoritmo escribe: 4 5 6.Debe notarse que los resultados difieren dependiendo del tipo de pasaje de argumentos empleado\n13 R trabaja con pasaje por referencia (aunque es posible forzar que haga algo similar, si así se lo desea).","code":"---------------------------------------------------------------\nSUBALGORITMOS\n---------------------------------------------------------------\n\nFUNCIÓN fun(x: numérico, y: numérico): numérico\n    x <- x + 1\n    DEVOLVER x + y\nFIN FUNCIÓN\n\n---------------------------------------------------------------\nALGORITMO PRINCIPAL\n---------------------------------------------------------------\n\nALGORITMO: \"Ejemplo de pasaje de argumentos\"\nCOMENZAR\n    VARIABLE numérica a, b, c\n    a <- 3\n    b <- 5\n    c <- fun(a, b - a)\n    ESCRIBIR a b c\nFIN"},{"path":"descomposición-algorítmica.html","id":"ámbito-de-las-variables","chapter":"4 Descomposición algorítmica","heading":"4.6 Ámbito de las variables","text":"En todo lenguaje de programación se le dice ámbito o scope la región del programa donde una variable definida existe y es visible, tal que fuera de dicha región se puede acceder la misma\n14. Según el ámbito en el que existen, las variables pueden considerarse locales o globales.","code":""},{"path":"descomposición-algorítmica.html","id":"variables-locales","chapter":"4 Descomposición algorítmica","heading":"4.6.1 Variables locales","text":"Las variables declaradas dentro de un subalgoritmo (por ejemplo, dentro de una función) se llaman variables locales. Sólo pueden ser usadas por las sentencias que están dentro de esa función, mientras que el programa principal u otros subalgoritmos desconocen su existencia y las pueden usar. Las variables locales residen en el ambiente local de un subalgortimo y tienen nada que ver con las variables que puedan ser declaradas con el mismo nombre en otros lugares15. En el siguiente ejemplo, las variables y b son locales la función f1 y se pueden usar desde el programa principal, porque dejan de existir una vez que termina la ejecución de f1:El error se genera porque el algoritmo principal quiere usar la variable , la cual es local la función f1() y sólo existe dentro de la misma.El uso de variables locales tiene muchas ventajas. Permiten independizar al subalgoritmo del algoritmo principal, ya que las variables definidas localmente en un subalgoritmo son reconocidas fuera de él. La comunicación entre el subalgoritmo y el algoritmo principal se da exclusivamente través de la lista de parámetros. Esta característica hace posible dividir grandes proyectos en piezas más pequeñas y que, por ejemplo, diferentes programadores puedan trabajar independientemente en un mismo proyecto.","code":"---------------------------------------------------------------\nSUBALGORITMOS\n---------------------------------------------------------------\n\nFUNCIÓN f1(x: numérico): numérico\n    VARIABLE numérica a, b\n    a <- x - 10\n    b <- x + 10\n    DEVOLVER a + b\nFIN FUNCIÓN\n\n---------------------------------------------------------------\nALGORITMO PRINCIPAL\n---------------------------------------------------------------\n\nALGORITMO: \"Ejemplo\"\nCOMENZAR\n    VARIABLE numérica z\n    z <- f1(50)\n    ESCRIBIR z\n    ESCRIBIR z + a   ---LÍNEA CON ERROR---\nFIN\n# ---------------------------------------------------------------\n# DEFINICIÓN DE FUNCIONES\n# ---------------------------------------------------------------\n\nf1 <- function(x) {\n    a <- x - 10\n    b <- x + 10\n    return(a + b)\n}\n\n# ---------------------------------------------------------------\n# PROGRAMA PRINCIPAL\n# ---------------------------------------------------------------\n\nz <- f1(50)\nz[1] 100\nz + aError in eval(expr, envir, enclos): object 'a' not found"},{"path":"descomposición-algorítmica.html","id":"variables-globales","chapter":"4 Descomposición algorítmica","heading":"4.6.2 Variables globales","text":"Las variables globales son las que se definen fuera de una función, mantienen su valor lo largo de todo el programa y pueden ser usadas dentro de las funciones, aún cuando se la pasemos como argumento. En el ejemplo anterior z es una variable global16. Las variables globales residen en el ambiente global del algoritmo.El siguiente ejemplo muestra cómo la función f2 puede hacer uso de una variable global y que fue definida fuera de ella, en el programa principal\n17:La función pudo hacer uso de la variable global y sin haberse comunicado con el programa principal través de los argumentos. Esta práctica es recomendable: si bien evaluemos f2(2) dos veces, el resultado fue el mismo, porque depende de cuánto vale y en el ambiente global en el momento que f2 es invocada. Además de ser confuso, esto es una violación al principio de transparencia referencial: un subalgoritmo sólo debe utilizar elementos mencionados en la lista de argumentos o definidos localmente, sin emplear variables globales. En particular, si hablamos de una función donde el pasaje de parámetros es por valor, esta práctica garantiza que la misma siempre devuelva el mismo resultado cada vez que sea invocada con los mismos valores en los argumentos de entrada, sin producir ningún efecto secundario en el algoritmo principal. El uso de variables globales permite escribir subalgoritmos que carecen de transparencia referencial.Un algoritmo puede usar el mismo nombre para variables locales y globales, pero dentro de una función toma precedencia la variable local. En el siguiente ejemplo, hay una variable global en el programa principal que recibe el valor 70. Y hay otra variable que es local la función f3. Cuando f3 calcula + b, lo hace con el valor de su variable local (x - 10) y con el valor de la variable global (70):Se debe prestar atención que con la sentencia ESCRIBIR o la función cat() en R se muestra en pantalla un mensaje en el momento en el que se ejecuta esa acción. Si el mensaje incluye mostrar valores guardados en objetos, se mostrarán los valores que los mismos tienen en ese momento. Por otro lado, lo devuelto por la sentencia DEVOLVER o la función return() es el resultado de la ejecución de la función: el valor que la función entrega puede ser asignado otro objeto en el algoritmo principal, como ocurre en la lína de z <- f3(50).","code":"---------------------------------------------------------------\nSUBALGORITMOS\n---------------------------------------------------------------\n\nFUNCIÓN f2(x: numérico): numérico\n    VARIABLE numérica a\n    a <- x * y\n    DEVOLVER a\nFIN FUNCIÓN\n\n---------------------------------------------------------------\nALGORITMO PRINCIPAL\n---------------------------------------------------------------\n\nALGORITMO: \"Ejemplo\"\nCOMENZAR\n    VARIABLE numérica y\n    y <- 20\n    ESCRIBIR f2(2)\n    y <- 18\n    ESCRIBIR f2(2)\nFIN\n# ---------------------------------------------------------------\n# DEFINICIÓN DE FUNCIONES\n# ---------------------------------------------------------------\n\nf2 <- function(x) {\n    a <- x * y\n    return(a)\n}\n\n# ---------------------------------------------------------------\n# PROGRAMA PRINCIPAL\n# ---------------------------------------------------------------\n\ny <- 20\nf2(2)[1] 40\ny <- 18\nf2(2)[1] 36---------------------------------------------------------------\nSUBALGORITMOS\n---------------------------------------------------------------\n\nFUNCIÓN f3(x: numérico): numérico\n    VARIABLE numérica a, b\n    a <- x - 10\n    b <- x + 10\n    ESCRIBIR \"Acá, dentro de la f3, el valor de a es\", a\n    DEVOLVER a + b\nFIN FUNCIÓN\n\n---------------------------------------------------------------\nALGORITMO PRINCIPAL\n---------------------------------------------------------------\n\nALGORITMO: \"Ejemplo\"\nCOMENZAR\n    VARIABLE numérica a, z\n    a <- 70\n    z <- f3(50)\n    ESCRIBIR z\n    ESCRIBIR \"Acá, en el programa principal, el valor de a es\", a\n    ESCRIBIR a + z\nFIN\n# ---------------------------------------------------------------\n# DEFINICIÓN DE FUNCIONES\n# ---------------------------------------------------------------\n\nf3 <- function(x) {\n    a <- x - 10\n    b <- x + 10\n    cat(\"Acá, dentro de la f3, el valor de a es\", a)\n    return(a + b)\n}\n\n# ---------------------------------------------------------------\n# PROGRAMA PRINCIPAL\n# ---------------------------------------------------------------\n\na <- 70\nz <- f3(50)Acá, dentro de la f3, el valor de a es 40\nz[1] 100\ncat(\"Acá, en el programa principal, el valor de a es\", a)Acá, en el programa principal, el valor de a es 70\na + z[1] 170"},{"path":"descomposición-algorítmica.html","id":"otros-tópicos-de-lectura-opcional","chapter":"4 Descomposición algorítmica","heading":"4.7 Otros tópicos de lectura opcional","text":"","code":""},{"path":"descomposición-algorítmica.html","id":"la-función-source","chapter":"4 Descomposición algorítmica","heading":"4.7.1 La función source()","text":"Cuanto más grande o complejo es el problema resolver, más funciones deben ser programadas y es necesario escribirlas todas en el mismo archivo de código del programa principal. Para ser más ordenados, podemos escribir nuestras funciones en uno o más archivos separados. Si hacemos esto, en el comienzo del script del programa principal debemos incluir una sentencia para que en primer lugar se ejecute el código guardado en esos otros archivos, de modo que las funciones sean definidas y formen parte del ambiente global.Consideremos otra vez el ejemplo de la función para el cálculo de factoriales. Podemos guardar el código de esta función (y otras si hubiese) en un archivo llamado funciones.R, con el siguiente contenido:Luego, en cualquier problema que requiera el cálculo de factoriales, vamos pedirle R que ejecute el código guardado en el archivo funciones.R con la sentencia source(), como paso inicial en el archivo donde estemos escribiendo el programa principal. Por ejemplo:Gracias source() todas las funciones definidas en el archivo funciones.R aparecerán en el entorno y hay necesidad ni siquiera de abrirlo. Notar que C:/Documentos/Facultad/IALP/ es la dirección o path de la carpeta en la computadora donde hayas guardado el archivo funciones.R.","code":"#-----------------------------------------------------\n# Función factorial\n# Calcula el factorial de números enteros no negativos\n# Entrada:\n#       - n, entero no negativo\n# Salida:\n#       - el factorial de n\n#-----------------------------------------------------\nfactorial <- function(n) {\n    resultado <- 1\n    if (n > 0) {\n        for (i in 1:n) {\n            resultado <- resultado * i\n        }\n    }\n    return(resultado)\n}\n# ---------------------------------------------------------------\n# PROGRAMA PRINCIPAL: Mostrar los factoriales de los 10 primeros naturales\n# ---------------------------------------------------------------\n\nsource(\"C:/Documentos/Facultad/IALP/funciones.R\")\n\nfor (j in 1:10) {\n    cat(\"El factorial de\", j, \"es igual a\", factorial(j), \"\\n\")\n}"},{"path":"descomposición-algorítmica.html","id":"sentencia-return","chapter":"4 Descomposición algorítmica","heading":"4.7.2 Sentencia return","text":"La sentencia return() puede omitirse. R devuelve el resultado de la última expresión analizada. Por eso, las siguientes funciones son equivalentes:De todos modos, es aconsejable usar return() para ganar en claridad. Además, en funciones más complejas, su uso puede ser indispensable para indicar el término de la evaluación de la función.","code":"\ng1 <- function(x, y) {\n    resultado <- x^2 + 3 * y\n    return(resultado)\n}\ng1(4, 5)[1] 31\ng2 <- function(x, y) {\n    x^2 + 3 * y\n}\ng2(4, 5)[1] 31"},{"path":"descomposición-algorítmica.html","id":"argumentos-con-valores-asignados-por-defecto","chapter":"4 Descomposición algorítmica","heading":"4.7.3 Argumentos con valores asignados por defecto","text":"Hemos visto que algunos argumentos de las funciones predefinidas de R tienen valores asignados por defecto, como es el caso de la función log(), que menos que indiquemos otra cosa opera con la base natural. Cuando definimos nuestras propias funciones, también es posible asignarle un valor por defecto uno o más de sus argumentos.\nTomemos el primer ejemplo de este capítulo:Esta función también podría ser definida así:Esto significa que si proveemos un valor para el argumento y, este se le asignará por default el valor 100. Luego:En el caso anterior, se hace corresponder el 4 al primer argumento de la función, x, y como hay ningún otro parámetro actual que le estemos pasando la función, la misma le asigna y el valor 100 y calcula: x^2 + 3 * y = 16 + 300 = 316. Sin embargo, podemos, como antes, proveer cualquier otro valor para y, de modo que se use el valor por default:Como x tiene valor asignado por default en la función nueva_f(), siempre debemos pasarle un valor. En caso contrario, recibiremos un error:","code":"\nf <- function(x, y) {\n    resultado <- x^2 + 3 * y\n    return(resultado)\n}\nf(4, 5)[1] 31\nnueva_f <- function(x, y = 100) {\n    resultado <- x^2 + 3 * y\n    return(resultado)\n}\nnueva_f(4)[1] 316\nnueva_f(4, 5)[1] 31\nnueva_f()Error in nueva_f(): argument \"x\" is missing, with no default\nnueva_f(y = 5)Error in nueva_f(y = 5): argument \"x\" is missing, with no default"},{"path":"descomposición-algorítmica.html","id":"modificar-una-variable-global-desde-el-cuerpo-de-una-función-en-r","chapter":"4 Descomposición algorítmica","heading":"4.7.4 Modificar una variable global desde el cuerpo de una función en R","text":"Hemos dicho que una función recibe información desde el programa principal través de sus parámetros, y envía información al mismo mediante el valor que devuelve. Sin embargo, es posible alterar el comportamiento para que sea capaz de producir efectos secundarios, por ejemplo, modificando el valor de una variable global, violando así el principio de transparencia referencial. Esto se lograLos siguientes ejemplos definen dos funciones con un único argumento, x, pero que en su cuerpo hacen uso de una variable global, y, definida el algoritmo principal (estos casos violan el principio de transparencia referencial, su práctica es recomendable). La diferencia entre ellas es que g1() modifica el valor de y dentro de la función, pero el valor de y en el ambiente global es alterado; mientras que g2() cambia el valor de y sólo localmente, sino también en el ambiente global. Esto se logra mediante el uso del operador <<-18.Nuevamente, esta forma de trabajo es aconsejable porque estamos produciendo efectos secundarios desde la función en el ambiente global que pueden pasar desapercibidos si estamos muy atentos. Así como la mejor práctica es pasar toda la información desde el programa principal hacia la función través de sus parámetros, también es recomendable que toda comunicación desde la función hacia el programa principal se realice través del valor (u objeto) que la función devuelve, sin producir efectos secundarios (transparencia referencial).","code":"\n# ---------------------------------------------------------------\n# DEFINICIÓN DE FUNCIONES\n# ---------------------------------------------------------------\n\ng1 <- function(x) {\n    y <- y + 100\n    return(x / y)\n}\n\ng2 <- function(x) {\n    y <<- y + 100\n    return(x / y)\n}\n\n# ---------------------------------------------------------------\n# PROGRAMA PRINCIPAL\n# ---------------------------------------------------------------\n\n# Caso 1: el valor de y en el ambiente global no es modificado por g1\nx <- 500\ny <- 50\nz <- g1(x)\ncat(x, y, z)500 50 3.333333\n# Caso 2: el valor de y en el ambiente global es modificado por g2\nx <- 500\ny <- 50\nz <- g2(x)\ncat(x, y, z)500 150 3.333333"},{"path":"descomposición-algorítmica.html","id":"procedimientos","chapter":"4 Descomposición algorítmica","heading":"4.7.5 Procedimientos","text":"Un procedimiento es un subalgoritmo que agrupa una acción o conjunto de acciones, dándoles un nombre por el que se las puede identificar posteriormente. Se diferencia de la función en que tiene como objetivo, en general, devolver un valor, sino sólo contribuir la descomposición o modularidad del programa. R trabaja con el concepto de procedimiento, sino que todo tipo de subalgoritmo se genera con la misma estructura de function(...){...}19.Como en las funciones, desde el algoritmo principal se pasan valores al procedimiento utilizando parámetros o argumentos, aunque también puede haber procedimientos que carezcan de los mismos. Para usar un procedimiento hay que invocarlo, escribiendo su nombre y continuación, si los hay, los valores de los argumentos actuales para esa llamada, separados por comas. Aquí también los argumentos actuales deben ser compatibles en cuanto la cantidad, tipo y orden que los argumentos formales declarados en la definición del procedimiento.En el siguiente ejemplo podemos identificar los argumentos actuales (con el valor 5), b (con el valor 2), c y d (sin valores asignados inicialmente). Cuando el procedimiento proced1 es invocado, se establece una correspondencia con los argumentos formales n1, n2, n3 y n4, respectivamente. n1 toma el valor 5, n2 toma el valor 2 y el procedimiento le asigna los valores 7 n3 y 1 n4. Al finalizar, este procedimiento habrá dejado sin cambios las variables y b, mientras que le habrá asignado los valores 7 c y 1 d. Como resultado, el algoritmo escribe “5 2 7 1”.En el siguiente ejemplo, el procedimiento proced2 modifica las variables que actúan como argumentos actuales. Al ser invocado, se establece una correspondencia entre los argumentos actuales (con el valor 5) y b (con el valor 2), y los argumentos formales n1 y n2, respectivamente. De esta forma, la primera acción del procedimiento le asigna el valor 7 n1 y 1 n2. De esta manera, al finalizar vale 7 y b vale 1 y el algoritmo escribe “7 1”.Analicemos ahora el tipo de pasaje de argumentos en el contexto de un procedimiento:Si el pasaje es por referencia, los pasos que sigue el algoritmo serían:En el algortimo se asignan los valores: = 8, b = 4.Al invocar la función: x = 8, y = 4.Primera línea de la función: x = 8 * 2 = 16. Lo mismo sucede con el parámetro actual : = 16.Segunda línea de la función: y = 16 - 4 = 12. Lo mismo sucede con el parámetro actual b: b = 12.Al regresar al algoritmo principal, la sentencia ESCRIBIR produce: 16 12.Si el pasaje hubiese sido por valor, y b hubiesen cambiado y la sentencia ESCRIBIR mostraría 8, 4. Como en un procedimiento los resultados regresan en los mismos parámetros, pueden ser todos pasados por valor, porque en ese caso el procedimiento nunca realizaría ninguna acción.Si el parámetro x se pasa por valor mientras que y se pasa por referencia, los pasos serían:= 8, b = 4.Al invocar la función: x = 8, y = 4.Primera línea de la función: x = 8 * 2 = 16.Segunda línea de la función: y = 16 - 4 = 12. Lo mismo sucede con el parámetro actual b: b = 12.Al regresar al algoritmo principal, la sentencia ESCRIBIR produce: 8 12.Dado que en R el pasaje de argumentos es siempre por valor y por referencia, existen los procedimientos. Por esta razón, esta sección se ejemplifica con código de R.","code":"---------------------------------------------------------------\nSUBALGORITMOS\n---------------------------------------------------------------\n\nPROCEDIMIENTO proced1(n1: numérico, n2: numérico, n3: numérico, n4: numérico)\n    n3 <- n1 + n2\n    n4 <- n2 - 1\nFIN PROCEDIMIENTO\n\n---------------------------------------------------------------\nALGORITMO PRINCIPAL\n---------------------------------------------------------------\n\nALGORITMO: Primer ejemplo de procedimiento\nCOMENZAR\n    VARIABLE numérica a, b, c, d\n    a <- 5\n    b <- 2\n    proced1(a, b, c, d)\n    ESCRIBIR a b c d\nFIN---------------------------------------------------------------\nSUBALGORITMOS\n---------------------------------------------------------------\n\nPROCEDIMIENTO proced2(n1: numérico, n2: numérico)\n    n1 <- n1 + n2\n    n2 <- n2 - 1\nFIN PROCEDIMIENTO\n\n---------------------------------------------------------------\nALGORITMO PRINCIPAL\n---------------------------------------------------------------\n\nALGORITMO: Segundo ejemplo de procedimiento\nCOMENZAR\n    VARIABLE numérica a, b\n    a <- 5\n    b <- 2\n    proced2(a, b)\n    ESCRIBIR a b\nFIN---------------------------------------------------------------\nSUBALGORITMOS\n---------------------------------------------------------------\n\nPROCEDIMIENTO miProc(x: numérico, y: numérico)\n    x <- x * 2\n    y <- x - y\nFIN PROCEDIMIENTO\n\n---------------------------------------------------------------\nALGORITMO PRINCIPAL\n---------------------------------------------------------------\n\nALGORITMO: Tercer ejemplo de procedimiento\nCOMENZAR\n    VARIABLE numérica a, b\n    a <- 8\n    b <- 4\n    miProc(a, b)\n    ESCRIBIR a b\nFIN"},{"path":"estructuras-de-datos.html","id":"estructuras-de-datos","chapter":"5 Estructuras de datos","heading":"5 Estructuras de datos","text":"Página en construcción.","code":""},{"path":"uso-de-archivos-de-datos.html","id":"uso-de-archivos-de-datos","chapter":"6 Uso de archivos de datos","heading":"6 Uso de archivos de datos","text":"Página en construcción.","code":""},{"path":"otros-tópicos.html","id":"otros-tópicos","chapter":"7 Otros tópicos","heading":"7 Otros tópicos","text":"","code":""},{"path":"bibliografía.html","id":"bibliografía","chapter":"Bibliografía","heading":"Bibliografía","text":"Bibliografía de la asignaturaCasale, Juan Carlos (2012). Introducción la Programación. Buenos Aires: Editorial Fox Andina.Cerrada Somolinos, José y Collado Machuca, Manuel (2015). Fundamentos De Programación. Madrid: Editorial Universitaria Ramón Areces.Martínez López, Pablo (2013). Las bases conceptuales de la Programación: una nueva forma de aprender programar. La Plata: Editorial de la Universidad Nacional de Quilmes.Quetglás, Gregorio; Toledo Lobo, Francisco; Cerverón Lleó, Vicente (1995). Fundamentos de informática y programación. Valencia: Editorial V.J.Wicham, Hadley (2019). Advanced R. Florida: Editorial Chapman Hall/CRC.Textos consultados para la reseña histórica de la programación:Ada Lovelace - Wikipedia. Consultado el 21/04/21.Difference engine - Wikipedia. Consultado el 21/04/21.Generaciones de las computadoras. Consultado el 21/04/21.Generaciones de ordenadores. Consultado el 21/04/21.Historia de la programación - Wikipedia. Consultado el 21/04/21.Konrad Zuse - people.idsia.ch. Consultado el 21/04/21.Los huesos de Napier, la multiplicación árabe y tú. Consultado el 21/04/21.Significado de computación. Consultado el 21/04/21.Otros artículos consultadosAprender programación - Curso de Java. Consultado el 25/04/21.Fundamentos de programación. Consultado el 25/04/21.Hardware y software: definiciones y conceptos. Consultado el 25/04/21.Introduction programming. Consultado el 25/04/21.Programación estructurada. Consultado el 25/04/21.7 Common Types Errors Programming Avoid . Consultado el 25/04/21.abstraction programming?. Consultado el 25/04/21.","code":""}]

% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
% \usepackage{booktabs}
% \usepackage{amsthm}
% \usepackage{amssymb}
\usepackage{booktabs}
\usepackage{multirow}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\spanishdecimal{.}
%\renewcommand{\contentsname}{Contenido}


% Encabezado
\usepackage[margin=2cm]{geometry}
\usepackage{fancyhdr}
\pagestyle{fancy}
\renewcommand{\footrulewidth}{0.4pt}
\renewcommand{\sectionmark}[1]{\markright{#1}}
\fancyhead[L]{IALP - Guía de Estudio}
\fancyhead[R] {\leftmark}

% Formato para el capítulo
% Para que diga Unidad en lugar de Capítulo
\makeatletter
\renewcommand{\@chapapp}{Unidad}
\makeatother
% Para que diga "Unidad" antes del nro y nombre de la unidad
%\usepackage{titlesec}
%\titleformat{\chapter}{
%	\normalfont\LARGE\bfseries
%}{Unidad \thechapter.  }{0em}{}

% Para que haya encabezado en la primera hoja de cada cap tmb
\usepackage{etoolbox}
\patchcmd{\chapter}{\thispagestyle{plain}}{\thispagestyle{fancy}}{}{}

% Pero lo anterior agrega encabezad en la tabla de contenidos, esto lo evita
\AtBeginDocument{%
	\addtocontents{toc}{\protect\thispagestyle{empty}}
}

% Agregar puntos en el TOC en el nivel de capitulo
\usepackage{tocloft}
\renewcommand{\cftchapleader}{\cftdotfill{\cftdotsep}} % for chapters

% Info para la portada
\newcommand{\horrule}[1]{\rule{\linewidth}{#1}}
\title{
	%\vspace{-1in} 	
	\usefont{OT1}{bch}{b}{n}
	\normalfont \normalsize
	\textsc{
		Universidad Nacional de Rosario \\
		Facultad de Ciencias Económicas y Estadística \\
		Licenciatura en Estadística
	} \\ [25pt]
	\horrule{2pt} \\[0.4cm]
	\huge \textbf{Introducción a la Programación} \\
	\bigbreak
	Guía de Estudio - Año 2022\\
	\horrule{2pt} \\[0.5cm]}

\author{
	\normalfont Mgs. Lic. Marcos Prunello (Prof. Tit. Ordenado)
}

% Esto es para que el cuadro sombreado donde sale el codigo sea mas chico y para que el espacio entre el codigo y el output sea menor
\usepackage{etoolbox,framed} 
\setlength{\parskip}{2pt}
\setlength{\OuterFrameSep}{2pt}
\makeatletter
\preto{\@verbatim}{\topsep=2pt \partopsep=2pt }
\makeatother

% Otros paquetes
\usepackage{xcolor}

% cosas para modificar espacios entre ecuaciones y otros
% Que haya menos espacio antes y dps de ecuaciones
% \usepackage{setspace}\onehalfspacing
% \AtBeginDocument{%
%   % estas dos 
%   %\addtolength\abovedisplayskip{-0.5\baselineskip}%
%   %\addtolength\belowdisplayskip{-0.5\baselineskip}
%   % o estas dos, probar cual me gusta mas
%   \setlength{\belowdisplayskip}{0pt} \setlength{\belowdisplayshortskip}{0pt}
%   \setlength{\abovedisplayskip}{0pt} \setlength{\abovedisplayshortskip}{0pt}
% }
% 
% \setlength{\intextsep}{0pt}
% 
% \makeatletter
% \def\thm@space@setup{%
%   \thm@preskip=8pt plus 2pt minus 4pt
%   \thm@postskip=\thm@preskip
% }
% \makeatother

% Columnas
\newenvironment{columns}[1][]{}{}

\newenvironment{column}[1]{\begin{minipage}{#1}\ignorespaces}{%
\end{minipage}
\ifhmode\unskip\fi
\aftergroup\useignorespacesandallpars}

\def\useignorespacesandallpars#1\ignorespaces\fi{%
#1\fi\ignorespacesandallpars}

\makeatletter
\def\ignorespacesandallpars{%
  \@ifnextchar\par
    {\expandafter\ignorespacesandallpars\@gobble}%
    {}%
}
\makeatother

% Para que en Latex las tables queden donde quiero
\usepackage{float}
% \floatplacement{table}{H}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{plainnat}
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={Introducción a la Programación},
  pdfauthor={Mgs. Lic. Marcos Prunello (Prof.~Tit. Ord.)},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{Introducción a la Programación}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{Guía de estudio - Lic. en Estadística - FCEyE - UNR}
\author{Mgs. Lic. Marcos Prunello (Prof.~Tit. Ord.)}
\date{2023-05-30}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\newpage

\textbf{BIENVENIDA}

\vspace{\baselineskip}

¡Les damos la bienvenida a la asignatura Introducción a la Programación en la Facultad de Ciencias Económicas y Estadística, Universidad Nacional de Rosario! La presente guía resume los conceptos más importantes que vamos a desarrollar. La misma irá siendo revisada, completada y actualizada a lo largo del cuatrimestre y no está exenta de presentar errores o expresar ideas que puedan ser mejoradas. Avisanos si encontrás algo que deba ser cambiado. ¡Esperamos que juntos podamos pasarla bien al dar nuestros primeros pasos en la programación!

\vspace{\baselineskip}

Este material fue escrito por el Mgs. Lic. Marcos Prunello (profesor titular) y revisado por los integrantes de la cátedra, Tec. César Mignoni y Lic. Maite San Martín.

\vspace{\baselineskip}

\textbf{NOTA: La versión en PDF no es revisada en cuanto a su configuración, por lo tanto es probable que se encuentren páginas con espacios en blanco, tablas con filas cortadas, figuras muy grandes, etc. El archivo PDF es generado sin revisar su estado final, pero el texto es el mismo que la versión online (\url{https://mpru.github.io/introprog})}

\hypertarget{introducciuxf3n-a-la-programaciuxf3n}{%
\chapter{Introducción a la Programación}\label{introducciuxf3n-a-la-programaciuxf3n}}

\hypertarget{quuxe9-es-la-programaciuxf3n}{%
\section{Qué es la programación}\label{quuxe9-es-la-programaciuxf3n}}

Las computadoras son una parte esencial de nuestra vida cotidiana. Casi todos los aparatos que usamos tienen algún tipo de computadora capaz de ejecutar ciertas tareas: lavarropas con distintos modos de lavado, consolas de juegos para momentos de entretenimiento, calculadoras súper potentes, computadoras personales que se usan para un montón de propósitos, teléfonos celulares con un sinfín de aplicaciones y miles de cosas más.

Todos estos dispositivos con computadoras de distinto tipo tienen algo en común: alguien ``les dice'' cómo funcionar, es decir, les indica cuáles son los pasos que deben seguir para cumplir una tarea. De eso se trata la \emph{programación}: es la actividad mediante la cual las \emph{personas} le entregan a una \emph{computadora} un conjunto de instrucciones para que, al ejecutarlas, ésta pueda \emph{resolver un problema}. Quienes realizan esta actividad reciben el nombre de \emph{programadores}. Sin las personas que las programen, las computadoras dejan de ser útiles, por más complejos que sean estos aparatos. Los conjuntos de instrucciones que reciben las computadoras reciben el nombre de \emph{programas}.

La programación es un proceso creativo: en muchas ocasiones la tarea en cuestión puede cumplirse siguiendo distintos caminos y el programador es el que debe imaginar cuáles son y elegir uno. Algunos de estos caminos pueden ser mejores que otros, pero en cualquier caso la computadora se limitará a seguir las instrucciones ideadas por el programador.

Desafortunadamente, las computadoras no entienden español ni otro idioma humano. Hay que pasarles las instrucciones en un lenguaje que sean capaces de entender. Para eso debemos aprender algún \emph{lenguaje de programación}, que no es más que un lenguaje artificial compuesto por una serie de expresiones que la computadora puede interpretar. Las computadoras interpretan nuestras instrucciones de forma muy literal, por lo tanto a la hora de programar hay que ser muy específicos. Es necesario respetar las reglas del lenguaje de programación y ser claros en las indicaciones provistas.

Ahora bien, ¿por qué debemos estudiar programación en la Licenciatura en Estadística? La actividad de los profesionales estadísticos está atravesada en su totalidad por la necesidad de manejar con soltura herramientas informáticas que nos asisten en las distintas etapas de nuestra labor, desde la recolección y depuración de conjuntos de datos, pasando por la aplicación de distintas metodologías de análisis, hasta la comunicación efectiva de los resultados. Por eso, en la asignatura \emph{Introducción a la Programación} estudiaremos los conceptos básicos de esta disciplina, fomentando la ejercitación del pensamiento abstracto y lógico necesario para poder entendernos hábilmente con la computadora y lograr que la misma realice las tareas que necesitamos.

Para poner en práctica los conceptos sobre Programación que aprenderemos, vamos a emplear un lenguaje que ha sido desarrollado específicamente para realizar tareas estadísticas, llamado \emph{R}. Sin embargo, debemos resaltar que éste no es un curso sobre R, es decir, no nos dedicaremos a aprender las herramientas que este lenguaje brinda para el análisis de datos. De hecho, frente a variados problemas vamos a dedicarnos a crear soluciones que ya existen y están disponibles en R, pero lo haremos con el fin de utilizar dicho lenguaje para aprender y ejercitar nociones básicas de programación.

\hypertarget{una-breve-reseuxf1a-histuxf3rica-sobre-la-programaciuxf3n}{%
\section{Una breve reseña histórica sobre la programación}\label{una-breve-reseuxf1a-histuxf3rica-sobre-la-programaciuxf3n}}

La historia de la programación está vinculada directamente con la de la computación. Esta palabra proviene del latín \emph{computatio}, que deriva del verbo \emph{computare}, cuyo significado es ``enumerar cantidades''. Computación, en este sentido, designa la acción y efecto de computar, realizar una cuenta, un cálculo matemático. De allí que antiguamente computación fuese un término usado para referirse a los cálculos realizados por una persona con un instrumento expresamente utilizado para tal fin (como el ábaco, por ejemplo) o sin él. En este sentido, la computación ha estado presente desde tiempos ancestrales, sin embargo debemos remontarnos al siglo XVII para encontrar los primeros dispositivos diseñados para automatizar cómputos matemáticos.

En 1617 el matemático escocés John Napier (el mismo que definió los logaritmos) inventó un sistema conocido como \emph{los huesos de Napier} o \emph{huesos neperianos} que facilitaba la tarea de multiplicar, dividir y tomar raíces cuadradas, usando unas barras de hueso o marfil que tenían dígitos grabados. Esta fue la base para otras ideas más avanzadas, entre ellas la que dio origen a la primera calculadora mecánica, inventada por el alemán Wilhelm Schickard en 1623, capaz de realizar cómputos aritméticos sencillos funcionando a base de ruedas y engranajes. Se componía de dos mecanismos diferenciados, un ábaco de Napier de forma cilíndrica en la parte superior y un mecanismo en la inferior para realizar sumas parciales de los resultados obtenidos con el aparato de la parte superior. Fue llamado \emph{reloj calculador}. A partir de aquí se fueron desarrollando otros modelos, todos ellos teniendo en común el hecho de ser puramente mecánicos, sin motores ni otras fuentes de energía. El operador ingresaba números ubicando ruedas de metal en posiciones particulares y al girarlas otras partes de la máquina se movían y mostraban el resultado. Algunos ejemplos son las calculadoras del inglés William Oughtred en 1624, de Blaise Pascal en 1645 (llamada \emph{pascalina}), la de Samuel Morland en 1666 y las de Leibniz, en 1673 y 1694.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{images/historia/calculadoras} 

}

\caption{De izquierda a derecha: los huesos de Napier (Museo Arqueológico Nacional de España), el reloj calculador de Schickard (Museo de la Ciencia de la Universidad Pública de Navarra) y una pascalina del año 1952}\label{fig:calculadora}
\end{figure}

El siglo XVIII trajo consigo algunos otros diseños, pero un gran salto se dio a comienzos del siglo XIX de mano de un tejedor y comerciante francés, Joseph Jacquard. En 1801 creó un telar que tenía un sistema de tarjetas perforadas para controlar las puntadas del tejido, de forma que fuera posible \emph{programar} una gran diversidad de tramas y figuras. Sin saberlo, Jacquard sentó una idea fundamental para la creación de las computadoras.

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{images/historia/telar} 

}

\caption{Un telar de Jacquard y sus tarjetas perforadas en el Museo de la ciencia y la industria en Mánchester.}\label{fig:unnamed-chunk-1}
\end{figure}

En 1822 el matemático británico Charles Babbage publicó un diseño para la construcción de una \emph{máquina diferencial}, que podía calcular valores de funciones polinómicas mediante el método de las diferencias. Este complejo sistema de ruedas y engranajes era el primero que podía trabajar automáticamente utilizando resultados de operaciones previas. Si bien el diseño era viable, por motivos técnicos y económicos no lo pudo concretar (sólo construyó un modelo de menor escala). Sin embargo, Babbage no se dio por vencido y en 1837 presentó el diseño de una \emph{máquina analítica}, un aparato capaz de ejecutar cualquier tipo de cálculo matemático y que, por lo tanto, se podría utilizar con cualquier propósito. Tal como el telar de Jacquard, la operación de esta máquina sería controlada por un patrón de perforaciones hechas sobre una tarjetas que la misma podría leer. Al cambiar el patrón de las perforaciones, se podría cambiar el comportamiento de la máquina para que resuelva diferentes tipos de cálculos. Para la salida de resultados, la máquina sería capaz de perforar tarjetas. Además, funcionaría con un motor a vapor y su tamaño hubiese sido de 30 metros de largo por 10 de ancho. Si bien Babbage tampoco llegó a concretar en vida este diseño que dejó plasmado en más de 300 dibujos y 2200 páginas por motivos políticos, se lo considera como la primera conceptualización de lo que hoy conocemos como computadora, por lo cual Babbage es conocido como \emph{el padre de la computación}.

En 1843 Lady Ada Lovelace, una matemática y escritora británica, publicó una serie de notas sobre la máquina analítica de Babbage, en las que resaltaba sus potenciales aplicaciones prácticas, incluyendo la descripción detallada de tarjetas perforadas para que sea capaz de calcular los números de Bernoulli. Al haber señalado los pasos para que la máquina pueda cumplir con estas y otras tareas, Ada es considerada actualmente como la primera programadora del mundo, a pesar de que en la época no fue tomada en serio por la comunidad científica, principalmente por su condición de mujer.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{images/historia/babbage_ada} 

}

\caption{Charles Babbage, Ada Lovelace y el algoritmo que publicó Ada para calcular los números de Bernoulli con la máquina analítica de Charles.}\label{fig:unnamed-chunk-2}
\end{figure}

La utilidad de las tarjetas perforadas quedó confirmada en 1890, cuando Herman Hollerith las utilizó para automatizar la tabulación de datos en el censo de Estados Unidos. Las perforaciones en determinados lugares representaban información como el sexo o la edad de las personas, logrando que se pudieran lograr clasificaciones y conteos de forma muy veloz. Así, se tardaron sólo 3 años en procesar la información del censo, cinco años menos que en el anterior de 1880. Con el fin de comercializar esta tecnología, Hollerith fundó una compañía que terminaría siendo la famosa International Business Machine (IBM), empresa líder en informática hasta el día de hoy.

Sin embargo, la visión de Babbage de una computadora programable no se hizo realidad hasta los años 1940, cuando el advenimiento de la electrónica hizo posible superar a los dispositivos mecánicos existentes. John Atanasoff y Clifford Berry (Iowa State College, Estados Unidos) terminaron en 1942 en Iowa State College (Estados Unidos) una computadora electrónica capaz de resolver sistemas de ecuaciones lineales simultáneas, llamada \emph{ABC} (por ``Atanasoff Berry Computer''). La misma contaba con 300 tubos de vacío, unas bombillas de vidrio con ciertos componentes que podían recibir y modificar una señal eléctrica mediante el control del movimiento de los electrones produciendo una respuesta, que habían sido presentados por primera vez en 1906 por el estadounidense Lee De Forest. La \emph{ABC} dio comienzo a la conocida como la \emph{primera generación de computadoras} basadas en el empleo de tubos de vacío.

La primera computadora electrónica de propósito general fue la \emph{ENIAC}, \emph{Electronic Numerical Integrator and Computer}, completada por Presper Eckert y John Mauchly en la Universidad de Pensilvania. Podía realizar cinco mil operaciones aritmética por segundo y tenía más de 18000 tubos de vacío, ocupando una sala de 9x15 metros en un sótano de la universidad donde se montó un sistema de aire acondicionado especial.

Ni la \emph{ABC} ni la \emph{ENIAC} eran reprogramables: la \emph{ABC} servía el propósito específico de resolver sistemas de ecuaciones y la \emph{ENIAC} era controlada conectando ciertos cables en un panel, lo que hacía muy compleja su programación. El siguiente gran avance se produjo en 1945, cuando el matemático húngaro-estadounidense John von Neumann (Universidad de Princeton) propuso que los programas, es decir, las instrucciones para que la máquina opere, y también los datos necesarios, podrían ser representados y guardados en una memoria electrónica interna. Así nació el concepto de \emph{programa almacenado} (o \emph{stored-program}), en contraposición con el uso de tableros de conexiones y mecanismos similares de los modelos vigentes. Los creadores de la ENIAC, bajo la consultoría de von Neumann, implementaron esto en el diseño de su sucesora, la \emph{EDVAC}, terminada en 1949.
También ya había experimentado con esta idea el alemán Konrad Zuse, quien entre 1937 y 1941 desarrolló la \emph{Z3}, por lo cual es considerada por algunos como la primera máquina completamente automática y programable. En lugar de usar tubos de vacíos, empleaba un conjunto de 2600 relés, unos dispositivos electromagnéticos inventados en 1835 y empleados, por ejemplo, en telegrafía.
El modelo original de la Z3 fue destruido en Berlín por un bombardeo durante la segunda guerra mundial.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{images/historia/berry_eniac_z3} 

}

\caption{De izquierda a derecha: las computadoras ABC, ENIAC y Z3}\label{fig:berry}
\end{figure}

Este nuevo paradigma cambió la historia de la computación, como también lo hizo la invención del \emph{transistor} en 1947 en los Laboratorios Bell. Un \emph{transistor} es un dispositivo electrónico semiconductor que entrega una señal de salida en respuesta a una señal de entrada, mucho más pequeño que los tubos de vacío y que consumen menos energía eléctrica. Así, una computadora podía tener cientos de miles de transistores, no obstante ocupando mucho espacio.

Desde entonces, la computación ha evolucionado muy rápidamente, con la introducción de nuevos sistemas y conceptos, que llegan a los complejos y poderosos diseños electrónicos que caracterizan la vida actual. En un intento de caracterizar y resumir esta impactante evolución, algunos historiadores dividen al desarrollo de las computadoras modernas en ``generaciones'' (esta clasificación no es única y existen diversas versiones de la misma):

\begin{itemize}
\tightlist
\item
  \emph{Primera generación} (aprox. 1940-1958): se trata de las computadoras electrónicas que usaban tubos de vacío para su circuito interno. Los equipos eran enormes y ocupan habitaciones enteras. Consumían mucha electricidad y generaban demasiado calor. Podía llevar días o semanas modificar las conexiones para hacer que la computadora resuelva un problema diferente. Usaban tarjetas perforadas y cinta de papel para la lectura de datos e impresiones para mostrar las salidas.
\item
  \emph{Segunda generación} (aprox. 1958-1964): se caracteriza por el uso de \emph{transistores} (inventados en 1947) en lugar de tubos de vacío, permitiendo que las computadoras tengan un consumo eléctrico más eficiente, sean más baratas, más pequeñas y más rápidas.
\item
  \emph{Tercera generación} (aprox. 1964-1971): se inició en 1959 con el desarrollo de un circuito integrado (``chip'') que se trata de una pequeña placa de silicio sobre el cual se imprime un gran número de transistores conectados. La primera computadora de este estilo fue de IBM en 1960. Al ser más pequeñas y baratas, su uso llegó a una mayor audiencia. Se pudo interactuar con la máquina mediante teclados, monitores y un sistema operativo, que posibilitaba ejecutar múltiples acciones a la vez bajo el monitoreo de un programa central.
\item
  \emph{Cuarta generación} (aprox. 1971-presente): los avances tecnológicos permitieron construir la unidad entera de procesamiento de una computadora sobre un único chip de silicio (\emph{microprocesador}), incluyendo la memoria y los controles de entrada y salida de datos. Todo lo que en una computadora de la primera generación ocupaba una habitación entera, fue capaz de entrar en la palma de una mano. El primer microprocesador fue el Intel 4004 de 1971, mientras que la primera computadora de uso doméstico fue desarrollada por IBM en 1981. Surgieron también en esta generación el ratón (\emph{mouse}) y las interfaces gráficas de usuario (como Windows, en 1985).
\end{itemize}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{images/historia/05_tubovacio_transistor_chip} 

}

\caption{De derecha a izquierda: un tubo de vacío, un transistor y un chip.}\label{fig:evolucion}
\end{figure}

\hypertarget{software-y-hardware}{%
\section{Software y hardware}\label{software-y-hardware}}

Como podemos ver, en la historia de la computación hubo dos aspectos que fueron evolucionando: las máquinas y los programas que las dirigen. Hacemos referencia a estos elementos como \emph{hardware} y \emph{software} respectivamente, y es la conjunción de ambos la que le da vida a la computación y hace posible la programación.

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{images/intro/06_hardsoft} 

}

\caption{Representación de la diferencia entre hardware y software.}\label{fig:hardvssoft}
\end{figure}

El \emph{hardware} es el conjunto de piezas físicas y tangibles de la computadora. Existen diversas formas de clasificar a los elementos que componene al hardware, según distintos criterios:

\begin{table}[H]
\caption{Clasificación del hardware.}
%\begin{tabular}{@{}cccc@{}}
\begin{tabular}{ p{3.5cm} p{2.5cm} p{6cm}p{4cm}}
\toprule
Critero                               & Clasificación                       & Descripción                                                                                                                                                                                    & Ejemplos                                                                                                        \\ \midrule
\multirow{4}{*}{Según su utilidad}    & Dispositivos de procesamiento       & Son los que reciben las instrucciones mediante señales eléctricas y usan cálculos y lógica para interpretarlas y emitir otras señales eléctricas como resultado.                               & microprocesador, tarjeta gráfica, tarjeta de sonido, etc.                                                       \\ \cmidrule(l){2-4} 
                                      & Dispositivos de almacenamiento      & Son capaces de guardar información para que esté disponible para el sistema.                                                                                                                   & disco duro, pen drive, DVD, etc.                                                                                \\ \cmidrule(l){2-4} 
                                      & Dispositivos de entrada             & Captan instrucciones por parte de los usuarios y las transforman en señales eléctricas interpretables por la máquina.                                                                          & teclado, mouse, touch pad, etc.                                                                                 \\ \cmidrule(l){2-4} 
                                      & Dispositivos de salida              & Transforman los resultados de los dispositivos de procesamiento para presentarlos de una forma fácilmente interpretable para el usuario.                                                       & monitor, impresora, etc                                                                                         \\ \midrule
\multirow{2}{*}{Según su ubicación}   & Dispositivos internos               & Generalmente se incluye dentro de la carcasa de la computadora.                                                                                                                                & microprocesador, disco rígido, ventiladores, módem, tarjeta gráfica, fuente de alimentación, puertos, etc.      \\ \cmidrule(l){2-4} 
                                      & Dispositivos externos o periféricos & No se incluye dentro de la carcasa de la computadora y está al alcance del usuario                                                                                                             & monitor, teclado, mouse, joystick, micrófono, impresora, escáner, pen drive, lectores de código de barras, etc. \\ \midrule
\multirow{2}{*}{Según su importancia} & Hardware principal                  & Dispositvos esenciales para el funcionamiento de la computadora                                                                                                                                & microprocesador, disco rígido, memoria RAM, fuente de alimentación, monitor, etc.                               \\ \cmidrule(l){2-4} 
                                      & Hardware complementario             & Aquellos elementos no indispensables (claramente, dependiendo del contexto, alguna pieza del hardware que en alguna situación podría considerarse complementaria, en otras resulta principal). &                                                                                                                 \\ \bottomrule
\end{tabular}
\end{table}

\(~\)

Por otro lado tenemos al \emph{software}, que es el conjunto de todos los programas (es decir, todas las instrucciones que recibe la computadora) que permiten que el hardware funcione y que se pueda concretar la ejecución de las tareas. No tiene una existencia física, sino que es intangible. El software se puede clasificar de la siguiente forma:

\begin{table}[H]
\caption{Clasificación del software.}
\begin{tabular}{ p{4cm} p{6cm} p{6cm}}
\toprule
Clasificación                            & Descripción                                                                                                                                                               & Ejemplos                                                                                                                                                                                                            \\ \midrule
Software de sistema o software base      & Son los programas informáticos que están escritos en lenguaje de bajo nivel como el de máquina o ensamblador y cuyas instrucciones controlan de forma directa el hardware & BIOS o UEFIs (sistemas que se encargan de operaciones básicas como el arranque del sistema, la configuración del hardware, etc), sistemas operativos (Linux, Windows, iOS, Android), controladores o *drivers*, etc. \\ \midrule
Software de aplicación o utilitario      & Son los programas o aplicaciones que usamos habitualmente para realizar alguna tarea específica.                                                                          & procesadores de texto como Word, reproductor de música, Whatsapp, Guaraní, navegadores web, juegos, etc.                                                                                                            \\ \midrule
Software de programación o de desarrollo & Son los programas y entornos que nos permiten desarrollar nuestras propias herramientas de software o nuevos programas. Aquí se incluyen los lenguajes de programación    & C++, Java, Python, R, etc.                                                                                                                                                                                          \\ \bottomrule
\end{tabular}
\end{table}

\hypertarget{problemas-algoritmos-y-lenguajes-de-programaciuxf3n}{%
\section{Problemas, algoritmos y lenguajes de programación}\label{problemas-algoritmos-y-lenguajes-de-programaciuxf3n}}

Mencionamos anteriormente que la \emph{programación} consistía en instruir a una computadora para que resuelva un problema y que la comunicación de esas instrucciones debe ser realizada de forma clara. Es por eso que, ante un problema que debe ser resuelto computacionalmente, el primer paso es pensar detalladamente cuál puede ser una forma de resolverlo, es decir, crear un \emph{algoritmo}. Un \emph{algoritmo} es una estrategia consistente de un conjunto ordenado de pasos que nos lleva a la solución de un problema o alcance de un objetivo. Luego, hay que traducir el algoritmo elegido al idioma de la computadora.

Entonces, podemos decir que la resolución computacional de un problema consiste de dos etapas básicas:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \emph{Diseño algorítmico}: desarrollar un algoritmo, o elegir uno existente, que resuelva el problema.
\item
  \emph{Codificación}: expresar un algoritmo en un lenguaje de programación para que la computadora lo pueda interpretar y ejecutar.
\end{enumerate}

Al aprender sobre programación, comenzamos enfrentándonos a problemas simples para los cuales la primera etapa parece sencilla, mientras que la codificación se torna dificultosa ya que hay que aprender las reglas del lenguaje de programación. Sin embargo, mientras que con práctica rápidamente podemos ganar facilidad para la escritura de código, el diseño algorítmico se torna cada vez más desafiante al encarar problemas más complejos. Es por eso que haremos hincapié en el planteo y desarrollo de algoritmos como una etapa fundamental en la programación.

\hypertarget{el-diseuxf1o-algoruxedtmico}{%
\subsection{El diseño algorítmico}\label{el-diseuxf1o-algoruxedtmico}}

Cotidianamente, hacemos uso de algoritmos para llevar adelante casi todas las actividades que realizamos: preparar el desayuno, sacar a pasear la mascota, poner en la tele un servicio de \emph{streaming} para ver una película, etc. Cada una de estas tareas requiere llevar adelante algunas acciones de forma ordenada, aunque no hagamos un listado de las mismas y procedamos casi sin pensar.

Sin embargo, cuando estamos pensando la solución para un problema que va a resolver una computadora, debemos ser claros y concretos, para asegurarnos de que al seguir los pasos del algoritmo se llegue a la solución y para que quien tenga que codificarlo, nosotros mismos u otras personas, lo pueda entender sin problemas. Por eso, el primer paso es idear un algoritmo para su solución y expresarlo por escrito, por ejemplo, en español, pero adaptando el lenguaje humano a formas lógicas que se acerquen a las tareas que puede realizar una computadora. En programación, el lenguaje artificial e informal que usan los desarrolladores en la confección de algoritmos recibe el nombre de \emph{pseudocódigo}. Es la herramienta que utilizamos para describir los algoritmos mezclando el lenguaje común con instrucciones de programación. No es en sí mismo un lenguaje de programación, es decir, la computadora no es capaz de entenderlo, sino que el objetivo del mismo es que el programador se centre en la solución lógica y luego lo utilice como guía al escribir el programa.

El pseudocódigo, como cualquier otro lenguaje, está compuesto por:

\begin{itemize}
\tightlist
\item
  Un \emph{léxico}: conjunto de palabras o frases válidas para escribir las instrucciones.
\item
  Una \emph{sintaxis}: reglas que establecen cómo se pueden combinar las distintas partes.
\item
  Una \emph{semántica}: significado que se les da a las palabras o frases.
\end{itemize}

El pseudocódigo sigue una \emph{estructura secuencial}: define una acción o instrucción que sigue a otra en secuencia. Esta estructura puede representarse de la siguiente forma:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ALGORITMO: "Ejemplo"}
\NormalTok{COMENZAR}
\NormalTok{    Acción 1}
\NormalTok{    Acción 2}
\NormalTok{    ...}
\NormalTok{    Acción N}
\NormalTok{FIN}
\end{Highlighting}
\end{Shaded}

Se comienza con un título que describa el problema que el algoritmo resuelve, seguido por la palabra \texttt{COMENZAR}. Luego se detallan las acciones o instrucciones a seguir y se concluye con la palabra \texttt{FIN}. Por ejemplo, si nuestro problema es poner en marcha un auto, el algoritmo para resolverlo puede ser expresado mediante el siguiente pseudocódigo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ALGORITMO: "Arrancar el auto"}
\NormalTok{COMENZAR}
\NormalTok{    INSERTAR la llave de contacto}
\NormalTok{    UBICAR el cambio en punto muerto}
\NormalTok{    GIRAR la llave hasta la posición de arranque}
\NormalTok{    SI el motor arranca }
\NormalTok{        ENTONCES}
\NormalTok{            DEJAR la llave en posición "encendido"}
\NormalTok{        SI NO}
\NormalTok{            LLAMAR al mecánico}
\NormalTok{    FINSI}
\NormalTok{FIN}
\end{Highlighting}
\end{Shaded}

Es importante destacar la presencia de sangrías (\emph{sangrado}) en el ejemplo anterior, que facilitan la lectura.

Los algoritmos suelen ser representados también mediante \emph{diagramas de flujo}, como el que se muestra en la siguiente figura\footnote{En este curso no emplearemos diagramas de flujo}.

\begin{figure}

{\centering \includegraphics[width=0.7\linewidth]{images/intro/flujo} 

}

\caption{Ejemplo del algoritmo "Arrancar el auto" representado gráficamente con un diagrama de flujo.}\label{fig:algoritmo}
\end{figure}

\hypertarget{codificaciuxf3n}{%
\subsection{Codificación}\label{codificaciuxf3n}}

El algoritmo anterior está presentado en pseudocódigo utilizando el lenguaje español, una opción razonable para compartir esta estrategia entre personas que se comuniquen con este idioma. Claramente, si queremos presentarle nuestro algoritmo a alguien que sólo habla francés, el español ya no sería una buena elección, y mucho menos si queremos presentarle el algoritmo a una computadora. Para que una computadora pueda entender nuestro algoritmo, debemos traducirlo en un \emph{lenguaje de programación}, que, como dijimos antes, es un idioma artificial diseñado para expresar cómputos que puedan ser llevados a cabo por equipos electrónicos, es decir es un medio de comunicación entre el humano y la máquina.

Si bien hay distintos lenguajes de programación, una computadora en definitiva es un aparato que sólo sabe \emph{hablar} en \emph{binario}, es decir, sólo interpreta señales eléctricas con dos estados posibles, los cuales son representados por los dígitos binarios 0 y 1. Toda instrucción que recibe la computadora se construye mediante una adecuada y larga combinación de ceros y unos\footnote{Como vimos anteriormente, las computadoras de la primera generación no se manejaban con lenguajes de programación, sino que para introducir información e instrucciones en las primeras computadoras se usaban tarjetas perforadas, en las cuales los orificios representaban un ``0'' y las posiciones que no los tenían se entendían como un ``1'', de modo que la máquina podía operar empleando el sistema binario.}. Este sistema de código con ceros y unos que la computadora interpreta como instrucciones o conjuntos de datos se llama \emph{lenguaje de máquina} (o código de máquina).

Programar en lenguaje de máquina es muy complejo y lento, y es fácil cometer errores pero es difícil arreglarlos. Por eso a principios de la década de 1950 se inventaron los \emph{lenguaje ensambladores}, que usan palabras para representar simbólicamente las operaciones que debe realizar la computadora. Cada una de estas palabras reemplaza un código de máquina binario, siendo un poco más fácil programar. Imaginemos que deseamos crear un programa que permita sumar dos números elegidos por una persona. La computadora puede hacer esto si se lo comunicamos mediante un mensaje compuesto por una larga cadena de ceros y unos (lenguaje de máquina) que a simple vista no podríamos entender. Sin embargo, escrito en lenguaje ensamblador, el programa se vería así (por ejemplo):

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{images/intro/ensamblador} 

}

\caption{Programa en lenguaje ensamblador para leer dos números, sumarlos y mostrar el resultado. Al final de cada línea hay una descripción de la operación realizada.}\label{fig:unnamed-chunk-5}
\end{figure}

El programa que se encarga de traducir esto al código de máquina se llama \emph{ensamblador}. A pesar de que no haya ceros y unos como en el lenguaje de máquina, probablemente el código anterior tampoco sea fácil de entender. Aparecen instrucciones que tal vez podemos interpretar, como \emph{add} por sumar o \emph{sub} por substraer, pero está lleno de cálculos hexadecimales, referencias a posiciones en la memoria de la computadora y movimientos de valores que no lo hacen muy amigable. Por eso, a pesar de que la existencia de los lenguajes ensambladores simplificó mucho la comunicación con la computadora, se hizo necesario desarrollar lenguajes que sean aún más sencillos de usar.

Por ejemplo, con el lenguaje que vamos a aprender, R, el problema de pedirle dos números a una persona y sumarlos se resumen en las siguientes líneas de código:

\begin{verbatim}
n1 <- scan()
n2 <- scan()
print(n1 + n2)
\end{verbatim}

En las dos primeras líneas con la instrucción \texttt{scan()} (que quiere decir ``escanear'', ``leer'') se le pide a la persona que indique dos números y en la tercera línea se muestra el resultado de la suma, con la instrucción \texttt{print()} (``imprimir'', ``mostrar''). Mucho más corto y entendible.

Esta simplificación es posible porque nos permitimos \emph{ignorar} ciertos aspectos del proceso que realiza la computadora. Todas esas acciones que se ven ejemplificadas en la imagen con el código ensamblador se llevan a cabo de todas formas, pero no lo vemos. Nosotros sólo tenemos que aprender esas últimas tres líneas de código, de forma que nos podemos concentrar en el problema a resolver (ingresar dos números, sumarlos y mostrar el resultado) y no en las complejas operaciones internas que tiene que hacer el microprocesador.

En programación, la idea de simplificar un proceso complejo ignorando algunas de sus partes para comprender mejor lo que hay que realizar y así resolver un problema se conoce como \emph{abstracción}\footnote{La abstracción no es una idea exclusiva de la programación. Se encuentra, también, por ejemplo, en el \emph{arte abstracto}.}. Esto quiere decir que los lenguajes de programación pueden tener distintos niveles de abstracción:

\begin{itemize}
\tightlist
\item
  \emph{Lenguajes de bajo nivel de abstracción}: permiten controlar directamente el \emph{hardware} de la computadora, son específicos para cada tipo de máquina, y son más rígidos y complicados de entender para nosotros. El lenguaje ensamblador entra en esta categoría.
\item
  \emph{Lenguajes de alto nivel de abstracción}: diseñados para que sea fácil para los humanos expresar los algoritmos sin necesidad de entender en detalle cómo hace exactamente el hardware para ejecutarlos. El lenguaje que utilizaremos en este taller, R, es de alto nivel. Son independientes del tipo de máquina.
\item
  \emph{Lenguajes de nivel medio de abstracción}: son lenguajes con características mixtas entre ambos grupos anteriores.
\end{itemize}

\begin{figure}

{\centering \includegraphics[width=0.7\linewidth]{images/intro/07_lenguajes} 

}

\caption{Distintos lenguajes de programación y sus logos.}\label{fig:lenguajes}
\end{figure}

Si bien podemos programar usando un lenguaje de alto nivel para que nos resulte más sencillo, \emph{alguien} o \emph{algo} debe traducirlo a lenguaje de máquina para que la computadora, que sólo entiende de ceros y unos, pueda realizar las tareas. Esto también es necesario incluso si programáramos en lenguaje ensamblador. Para estos procesos de traducción se crearon los \emph{compiladores} e \emph{intérpretes}.

Un \emph{compilador} es un programa que toma el código escrito en un lenguaje de alto nivel y lo traduce a código de máquina, guardándolo en un archivo que la computadora ejecutará posteriormente (archivo ejecutable). Para ilustrar el rol del compilador, imaginemos que alguien que sólo habla español le quiere mandar una carta escrita en español a alguien que vive en Alemania y sólo habla alemán. Cuando esta persona la reciba, no la va a entender. Se necesita de un intermediario que tome la carta en español, la traduzca y la escriba en alemán y luego se la mande al destinatario, quien ahora sí la podrá entender. Ese es el rol de un \emph{compilador} en la computadora. Ahora bien, el resultado de la traducción, que es la carta escrita en alemán, sólo sirve para gente que hable alemán. Si se quiere enviar el mismo mensaje a personas que hablen otros idiomas, necesitaremos hacer la traducción que corresponda. De la misma forma, el código generado por un compilador es específico para cada máquina, depende de su arquitectura.

Además de los compiladores, para realizar este pasaje también existen los \emph{intérpretes}. Un intérprete es un programa que traduce el código escrito en lenguaje de alto nivel a código de máquina, pero lo va haciendo a medida que se necesita, es decir, su resultado reside en la memoria temporal de la computadora y no se genera ningún archivo ejecutable. Siguiendo con el ejemplo anterior, es similar a viajar a Alemania con un intérprete que nos vaya traduciendo en vivo y en directo cada vez que le queramos decir algo a alguien de ese país. En su implementación por defecto, el lenguaje R es interpretado, no compilado.

Concluyendo, gracias al concepto de la \emph{abstracción} podemos escribir programas en un lenguaje que nos resulte fácil entender, y gracias al trabajo de los \emph{compiladores} e \emph{intérpretes} la computadora podrá llevar adelante las tareas necesarias.

Cada una de las acciones que componen al algoritmo son codificadas con una o varias \emph{instrucciones}, expresadas en el lenguaje de programación elegido, y el conjunto de todas ellas constituye un \emph{programa}. El programa se guarda en un \emph{archivo} con un nombre generalmente dividido en dos partes por un punto, por ejemplo: \texttt{mi\_primer\_programa.R}. La primera parte es la \emph{raíz} del nombre con la cual podemos describir el contenido del archivo. La segunda parte es indicativa del uso del archivo, por ejemplo, \texttt{.R} indica que contiene un programa escrito en el lenguaje R. El proceso general de ingresar o modificar el contenido de un archivo se denomina \emph{edición}.

\hypertarget{errores-de-programaciuxf3n}{%
\section{Errores de programación}\label{errores-de-programaciuxf3n}}

Apenas iniciemos nuestro camino en el mundo de la programación nos daremos cuenta que tendremos siempre ciertos compañeros de viaje: los \emph{errores}. Muchas veces nos pasará que queremos ejecutar nuestro código y el mismo no anda o no produce el resultado esperado. No importa cuán cuidadosos seamos, ni cuánta experiencia tengamos, los errores están siempre presentes. Con el tiempo y práctica, vamos a poder identificarlos y corregirlos con mayor facilidad, pero probablemente nunca dejemos de cometerlos.

A los errores en programación se los suele llamar \emph{bugs} (insecto o bicho en inglés) y el proceso de la corrección de los mismos se conoce como \emph{debugging} (depuración)\footnote{Algunos usan el término bug para referirse exclusivamente a errores lógicos}. Se dice que esta terminología proviene de 1947, cuando una computadora en la Universidad de Harvard (la \emph{Mark II}) dejó de funcionar y finalmente se descubrió que la causa del problema era la presencia de una polilla en un relé electromagnético de la máquina. Sin embargo, otros historiadores sostienen que el término ya se usaba desde antes.

\begin{figure}

{\centering \includegraphics[width=0.7\linewidth]{images/intro/First_Computer_Bug} 

}

\caption{La polilla (bug) encontrada por la científica de la computación Grace Hooper en la Mark II fue pegada con cinta en un reporte sobre el malfuncionamiento de la máquina.}\label{fig:unnamed-chunk-6}
\end{figure}

A continuación se presenta una de las posibles clasificaciones de los errores que se pueden cometer en programación:

\begin{itemize}
\item
  \emph{Errores de sintaxis}. Tal como el lenguaje humano, los lenguajes de programación tienen su propio vocabulario y su propia sintaxis, que es el conjunto de reglas gramaticales que establecen cómo se pueden combinar las distintas partes. Estas reglas sintácticas determinan que ciertas instrucciones están correctamente construidas, mientras que otras no. Cuando ejecutamos un programa, el compilador o el intérprete chequea si el mismo es sintácticamente correcto. Si hemos violado alguna regla, por ejemplo, nos faltó una coma o nos sobra un paréntesis, mostrará un mensaje de error y debemos editar nuestro programa para corregirlo. En estos casos, hay que interpretar el mensaje de error, revisar el código y corregir el error.
\item
  \emph{Errores lógicos}. Se presentan cuando el programa puede ser compilado sin errores pero arroja resultados incorrectos o ningún resultado. El software no muestra mensajes de error, debido a que, por supuesto, no sabe cuál es el resultado deseado, sino que sólo se limita a hacer lo que hemos programado. En estos casos hay que revisar el programa para encontrar algún error en su lógica. Este tipo de errores suelen ser los más problemáticos. Algunas ideas para enfrentarlos incluyen volver a pensar paso por paso lo que se debería hacer para solucionar el problema y compararlo con lo que se ha programado, agregar pasos para mostrar resultados intermedios o emplear herramientas especializadas de \emph{debugging} (llamadas \emph{debugger}) para explorar el código paso a paso hasta identificar el error.
\item
  \emph{Errores en la ejecución} (\emph{runtime errors}). Se presentan cuando el programa está bien escrito, sin errores lógicos ni sintácticos, pero igualmente se comporta de alguna forma incorrecta. Se dan a pesar de que el programa ande bien en el entorno de desarrollo del programador, pero no cuando algún usuario lo utiliza en algún contexto particular. Puede ser que se intente abrir un archivo que no existe, que el proceso supere la memoria disponible, que tomen lugar operaciones aritméticas no definidas como la división por cero, etc.
\end{itemize}

Los errores en la programación son tan comunes, que un científico de la computación muy reconocido, Edsger Dijkstra, dijo una vez: ``si la depuración es el proceso de eliminar errores, entonces la programación es el proceso de generarlos''. Ante la presencia de uno, no hay más que respirar profundo y con paciencia revisar hasta encontrarlo y solucionarlo.

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{images/intro/08_bug} 

}

\caption{Encontrando un bug en un programa.}\label{fig:bug}
\end{figure}

\hypertarget{procesador-ambiente-y-acciones}{%
\section{Procesador, ambiente y acciones}\label{procesador-ambiente-y-acciones}}

Hemos definido a un algoritmo como una lista de instrucciones para resolver un problema. En este contexto, se entiende por \emph{procesador} a todo agente capaz de comprender los pasos de un algoritmo y ejecutar el trabajo indicado por el mismo. Para cumplir con el objetivo, el procesador emplea ciertos recursos que tiene a disposición. Todos los elementos disponibles para ser utilizados por el procesador constituyen su \emph{entorno} o \emph{ambiente}. Cada una de las instrucciones que componen el algoritmo modifican el entorno de alguna manera y se denominan \emph{acciones}.

Ejemplificaremos estos conceptos con los siguientes ejemplos:

\emph{Ejemplo 1}

\begin{itemize}
\tightlist
\item
  \emph{Problema}: preparar una tortilla de 6 huevos.
\item
  \emph{Entorno}: una mesa, una hornalla, una sartén, un plato, un tenedor, aceite, una fuente con huevos, un tarro de basura.
\item
  \emph{Procesador}: una persona adulta.
\item
  \emph{Acciones comprensibles por el procesador}: agarrar un huevo, romper un huevo en un plato, batir huevos, poner aceite, poner en la sartén, poner al fuego, retirar del fuego, tirar las cáscaras, encender el fuego.
\end{itemize}

¿Cuál es un algoritmo adecuado para solucionar este problema? Podría ser:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ALGORITMO: "Preparar una tortilla de 6 huevos"}
\NormalTok{COMENZAR}
\NormalTok{    ROMPER seis huevos en un plato}
\NormalTok{    TIRAR las cáscaras en el tacho}
\NormalTok{    BATIR los huevos}
\NormalTok{    CALENTAR aceite en la sartén}
\NormalTok{    PONER el contenido del plato en la sartén}
\NormalTok{    ESPERAR diez minutos}
\NormalTok{    RETIRAR la tortilla del fuego}
\NormalTok{    APAGAR el fuego}
\NormalTok{FIN}
\end{Highlighting}
\end{Shaded}

\emph{Ejemplo 2}

\begin{itemize}
\tightlist
\item
  \emph{Problema}: calcular el factorial del número 5.
\item
  \emph{Entorno}: se dispone de una calculadora común.
\item
  \emph{Procesador}: una persona adulta.
\item
  \emph{Acciones comprensibles por el procesador}: pulsar teclas de la calculadora.
\end{itemize}

¿Cuál es un algoritmo adecuado para solucionar este problema? Podría ser:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ALGORITMO: "Calcular 5!"}
\NormalTok{COMENZAR}
\NormalTok{    PULSAR [ON]}
\NormalTok{    PULSAR [1]}
\NormalTok{    PULSAR [X]}
\NormalTok{    PULSAR [2]}
\NormalTok{    PULSAR [X]}
\NormalTok{    PULSAR [3]}
\NormalTok{    PULSAR [X]}
\NormalTok{    PULSAR [4]}
\NormalTok{    PULSAR [X]}
\NormalTok{    PULSAR [5]}
\NormalTok{    PULSAR [=]}
\NormalTok{    MOSTRAR la pantalla}
\NormalTok{FIN}
\end{Highlighting}
\end{Shaded}

Las acciones del algoritmo pueden clasificarse en función de su complejidad:

\begin{itemize}
\tightlist
\item
  \emph{Acción primitiva}: acción sencilla directamente realizable por el procesador sin necesidad de contar con mayor información.
\item
  \emph{Acción compuesta}: acción integrada por una sucesión de acciones primitivas.
\end{itemize}

La descripción de un algoritmo en términos de acciones compuestas puede facilitar su comprensión, pero al desarrollar el programa será necesario descomponerlas en acciones primitivas que son las que realmente ejecuta el procesador. Por ejemplo, la acción compuesta en el ejemplo de la tortilla de ``romper seis huevos en un plato'' puede descomponerse en acciones más simples:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{REPETIR 6 VECES}
\NormalTok{    TOMAR un huevo}
\NormalTok{    GOLPEAR el huevo para generar una fractura en la cáscara}
\NormalTok{    EJERCER presión sobre la cáscara}
\NormalTok{    DERRAMAR la clara y la yema sobre el plato}
\end{Highlighting}
\end{Shaded}

En el contexto de la resolución de un problema computacional, el \emph{procesador} será la computadora; las acciones estarán dadas por las instrucciones disponibles en el lenguaje de programación utilizado o las que podamos crear en base al mismo; y el \emph{ambiente} estará constituido por un conjunto de variables, estructuras de datos, funciones y otros elementos que serán de utilidad en la programación.

\hypertarget{r-y-rstudio}{%
\section{R y RStudio}\label{r-y-rstudio}}

Como dijimos anteriormente, pondremos en práctica los conceptos sobre programación utilizando \textbf{R}, un lenguaje orientado a la realización de procesos estadísticos y gráficos. A diferencia de muchos otros, este es un software libre y gratuito: se distribuye bajo la licencia \emph{GNU GPLv2} que establece la libertad de usarlo con cualquier propósito, de ver cómo fue hecho, cómo funciona y modificarlo, de distribuir copias y crear contribuciones y agregados para que estén disponibles para otros \footnote{\textbf{R} tiene una comunidad de usuarios muy activa, de las más diversas áreas, con muchos blogs, portales y encuentros en persona para buscar y recibir ayuda. Por ejemplo, existe el grupo de R en Rosario: (\url{https://renrosario.rbind.io})}.

Si bien R será nuestro medio de comunicación con la computadora, vamos a usar otro programa que brinda algunas herramientas para facilitar nuestro trabajo de programación, es decir, vamos a usar un \textbf{entorno de desarrollo integrado} (o \emph{IDE}, por \emph{integrated development environment}). Un IDE es un programa que hace que la codificación sea más sencilla porque permite manejar varios archivos de código, visualizar el \emph{ambiente} de trabajo, utilizar resaltado con colores para distintas partes del código, emplear autocompletado para escribir más rápido, explorar páginas de ayuda, implementar estrategias de depuración e incluso intercalar la ejecución de instrucciones con la visualización de los resultados mientras avanzamos en el análisis o solución del problema. El IDE más popularmente empleado para programar con R es \textbf{RStudio} y será el programa que estaremos usando todo el tiempo.

Para instalar estos programas, se debe visitar las páginas oficiales de \href{https://www.r-project.org/}{R} y de \href{https://www.rstudio.org/}{RStudio}, descargar los instaladores y ejecutarlos. En este \href{https://www.youtube.com/watch?v=D9Bp11iZssc}{enlace} se presenta un video con la instalación completa.

\hypertarget{organizaciuxf3n-de-rstudio}{%
\subsection{Organización de RStudio}\label{organizaciuxf3n-de-rstudio}}

Cuando se abre RStudio se pueden visualizar cuatro paneles:

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{images/intro/12_AbrirRStudio} 

}

\caption{Captura de pantalla de RStudio}\label{fig:unnamed-chunk-10}
\end{figure}

\begin{itemize}
\item
  A la izquierda:

  \begin{itemize}
  \tightlist
  \item
    Arriba está el \textbf{editor de archivos}. Es el lugar donde escribiremos y editaremos nuestros programas, para luego guardarlos (una especie de \emph{Bloc de Notas} o de un \emph{Word} muy simple). La primera vez que se abre RStudio después de su instalación puede ser que este panel no esté presente, pero aparece si vamos a \texttt{File\ \textgreater{}\ New\ File\ \textgreater{}\ R\ Script}, con el atajo \texttt{Ctrl\ +\ Shift\ +\ N} o haciendo clic en el primer ícono de la barra de herramientas. Podemos abrir varios archivos a la vez.
  \item
    Abajo está la \textbf{consola}. Es la ventana que se comunica con R. A través de ella se envían las instrucciones a R para que las evalúe (también decimos, que las ejecute o corra) y se visualizan los resultados.
  \end{itemize}
\item
  Arriba a la derecha hay un panel con algunas pestañas:

  \begin{itemize}
  \tightlist
  \item
    \textbf{Environment} (\emph{ambiente}): muestra todos los elementos que componen al ambiente o entorno.
  \item
    \textbf{History} (\emph{historial}): lista todas las instrucciones que R ha corrido anteriormente.
  \item
    \textbf{Otras más que no nos interesan por ahora}
  \end{itemize}
\item
  Abajo a la derecha hay otro panel con más pestañas:

  \begin{itemize}
  \tightlist
  \item
    \textbf{Files}: explorador de archivos de la computadora
  \item
    \textbf{Plots}: ventana donde aparecen los gráficos si es que nuestro código produce alguno
  \item
    \textbf{Packages}: listado de los ``paquetes'' que tenemos instalados (ver más adelante)
  \item
    \textbf{Help}: manual de ayuda sobre todas las funciones de R
  \item
    \textbf{Viewer}: espacio para ver salidas de los programas con algún componente dinámico o interactivo.
  \end{itemize}
\end{itemize}

\hypertarget{uso-de-la-consola}{%
\subsection{Uso de la consola}\label{uso-de-la-consola}}

Podemos usar la consola de R que encontramos en el panel de la izquierda para introducir allí nuestras instrucciones y al hacer \texttt{Enter} serán evaluadas, produciendo algún resultado. Por ejemplo, podemos hacer algunos cálculos matemáticos como dividir, multiplicar, sumar, restar, calcular potencias, logaritmos, raíces y mucho más:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \SpecialCharTok{+} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \SpecialCharTok{*} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 15
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{exp}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 7.389056
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \SpecialCharTok{/} \DecValTok{0}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] Inf
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{2} \SpecialCharTok{+}\NormalTok{ 3i) }\SpecialCharTok{*}\NormalTok{ (}\DecValTok{3} \SpecialCharTok{+}\NormalTok{ 6i)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] -12+21i
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{1i }\SpecialCharTok{\^{}} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] -1+0i
\end{verbatim}

Si bien podemos escribir nuestras instrucciones en la consola y dar \texttt{Enter} para que se ejecuten, en general queremos que queden escritas y guardadas en el archivo de código, por eso vamos a escribir nuestros programas en el panel de arriba a la izquierda. Una vez que escribimos una instrucción en el script, podemos \emph{correrla} (es decir, enviarla a la consola para que se ejecute) haciendo clic en el ícono \emph{Run} o con el atajo \emph{Ctrl + Enter}. De esta forma, se \emph{corre} la línea en la cual está el cursor o las líneas que hayamos seleccionado.

En todo lenguaje de programación existe un caracter especial que, al ser colocado al comienzo de una línea de código, le indica al software que dicha línea no debe ser evaluada. Esto se utiliza para incluir \textbf{comentarios}, es decir, líneas que expresan en español explicaciones o aclaraciones para nosotros mismos u otros que puedan utilizar nuestro código. También se utiliza para añadir encabezados con descripciones sobre el script, o indicar distintas secciones o partes en el programa. En R, este caracter especial es el símbolo numera (\texttt{\#}). Si \emph{corremos} líneas que empiezan con \texttt{\#}, R no hará nada con ellas, las salteará. Por ejemplo

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5}\SpecialCharTok{\^{}}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 5\^{}2}
\DecValTok{5}\SpecialCharTok{\^{}}\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 125
\end{verbatim}

\hypertarget{diseuxf1o-del-sistema-r}{%
\subsection{Diseño del sistema R}\label{diseuxf1o-del-sistema-r}}

R Se divide en dos partes:

\begin{itemize}
\item
  La \textbf{base} (\emph{R Base}), que se instala cuando descargamos el programa desde \href{https://cran.r-project.org/}{CRAN} (``Comprehensive R Archive Network''). Contiene, entre otras cosas, una serie de herramientas básicas y fundamentales de R.
\item
  \textbf{Paquetes adicionales}. Un paquete es un conjunto de archivos que se descarga de forma opcional desde CRAN u otros repositorios y que sirven para hacer alguna tarea especial. Por ejemplo, para poder hacer gráficos lindos, se puede usar un paquete que se llama \texttt{ggplot2}.
\end{itemize}

Como dijimos antes, en la pestaña \emph{Packages} del panel de abajo a la derecha tiene el listado de todos los paquetes que ya están instalados (muchos vienen con R Base). Allí también hay un botón para instalar nuevos, aunque otra opción es correr la instrucción \texttt{install.packages("nombredelpaquete")}, por ejemplo, \texttt{install.packages("ggplot2")}. También es posible instalar paquetes publicados en otros repositorios\footnote{Por ejemplo, es muy común descargar paquetes en desarrollo o en experimentación que estén disponibles en la plataforma Github. Estos paquetes se instalan especificando el nombre de la cuenta de Github de quien lo haya publicado y el nombre del paquete, por ejemplo: \texttt{devtools::install\_github("mpru/karel")}. Para esto previamente hay que haber instalado desde CRAN el paquete \texttt{devtools} con \texttt{install.packages("devtools")}.}.

Un paquete se instala una sola vez, pero cada vez que lo queramos usar debemos \emph{cargarlo} para que las herramientas que trae queden a nuestra disposición. Eso se hace con la instrucción \texttt{library("nombredelpaquete")}, por ejemplo, \texttt{library("ggplot2")}.

\hypertarget{guuxeda-de-estilo}{%
\section{Guía de estilo}\label{guuxeda-de-estilo}}

Es sumamente importante mantener la prolijidad en la escritura tanto del pseudocódigo como de los programas, para facilitar la lectura de los mismos, especialmente cuando estamos trabajando con problemas largos. Siempre hay que tener en cuenta de que cuando escribimos un programa, tenemos dos públicos potenciales: integrantes de nuestro equipo de trabajo que tienen leer el código y hacer sus propios aportes y nosotros mismos en el futuro, cuando retomemos código hecho en el pasado y necesitemos interpretar qué es lo que hicimos hacer.

Es por eso que se establecen conjuntos de reglas para controlar y unificar la forma de escribir programas, que se conocen como \textbf{guía de estilo}. Estas reglas cubren aspectos como, por ejemplo, la forma de escribir comentarios en el código, la utilización de espacios o renglones en blanco, el formato de los nombres para los elementos que creamos nosotros mismos (como las funciones) y para los archivos que generamos, etc. Una \emph{guía de estilo} no indica la única forma de escribir código, ni siquiera la forma correcta de hacerlo, sino que establece una convención para que todos trabajen de la misma forma, basándose en costumbres que sí se ha visto que pueden tener más ventajas que otras.

Por ejemplo, para programar en R, existe una guía de estilo llamada \href{https://style.tidyverse.org/}{The tidyverse style guide}, que es la que utilizan la gente de Google y de RStudio. En este curso vamos a adherir a sus recomendaciones. Si bien es una lectura muy interesante, particularmente si tenés intenciones de profundizar tus conocimientos sobre programación en R, no es necesario que lean dicha guía completa. Por ahora es suficiente con que imiten con atención el estilo que usamos en los ejemplos provistos en esta guía.

Recordemos siempre que seguir un buen estilo para programar es como hacer uso de una correcta puntuación cuando escribimos, podemos entendernos sin ella, peroesmuchomasdificilleerloqueescribimossinolarespetamosno?

\hypertarget{objetos-y-operadores}{%
\chapter{Objetos y operadores}\label{objetos-y-operadores}}

Hemos mencionado que para resolver un problema computacional se necesita de un \emph{procesador}, capaz de entender y ejecutar ciertas \emph{acciones} a partir de ciertos elementos disponibles en el \emph{ambiente} o \emph{entorno}. En este capítulo vamos aprender acerca de dichos elementos, a los que llamamos \emph{objetos}.

\hypertarget{objetos}{%
\section{Objetos}\label{objetos}}

Los \textbf{objetos} son las distintas piezas de información, o más sencillamente, \emph{datos}, que componen al \emph{entorno} y que el procesador debe manipular para resolver una tarea. Las distintas acciones del algoritmo van creando o modificando a los objetos del entorno. A medida que avancemos, veremos que hay distintas clases de objetos, algunos con estructuras más simples y otros más complejos. Es más, cada lenguaje de programación propone su propio catálogo de clases de objetos y cada programador puede crear otras nuevas. Sin embargo, en general todos los lenguajes tienen en común el hecho de que sus objetos pueden almacenar los siguientes tres tipos de datos básicos, conocidos como \textbf{tipos de datos primitivos}:

\begin{itemize}
\tightlist
\item
  \textbf{Datos de tipo numérico}: representan valores escalares de forma numérica y permiten realizar operaciones aritméticas comunes. Ejemplo: 230, 2.
\item
  \textbf{Datos de tipo carácter}: representan texto y no es posible hacer operaciones matemáticas con ellos. Representamos estos valores entre comillas. Ejemplo: ``hola'', ``chau123''
\item
  \textbf{Datos de tipo lógico}: pueden tomar dos valores (\emph{VERDADERO} o \emph{FALSO}), ya que representan el resultado de alguna comparación entre otros objetos. En R, estos valores son \texttt{TRUE} y \texttt{FALSE}, escritos sin comillas.
\end{itemize}

De manera general, al nombre de un objeto se le dice \textbf{identificador}, el cual es una secuencia de caracteres alfanuméricos que sirve para identificarlo a lo largo del algoritmo. Nombrar los objetos hace posible referirse a los mismos. La elección de los identificadores es una tarea del programador, pero cada lenguaje tiene sus propias reglas. Por ejemplo, en R los nombres de los objetos:

\begin{itemize}
\tightlist
\item
  Deben empezar con una letra o un punto (no pueden empezar con un número).
\item
  Sólo pueden contener letras, números, guiones bajos y puntos (se puede forzar a R para que acepte nombres con otros caracteres, pero no es aconsejable).
\item
  No se pueden usar las siguientes palabras como nombres, ya que son palabras claves reservadas para R: \texttt{break}, \texttt{else}, \texttt{FALSE}, \texttt{for}, \texttt{function}, \texttt{if}, \texttt{Inf}, \texttt{NA}, \texttt{NaN}, \texttt{next}, \texttt{repeat}, \texttt{return}, \texttt{TRUE}, \texttt{while}.
\end{itemize}

Es aconsejable elegir un nombre que sea representativo de la información que va a guardar el objeto, ya que esto facilita la lectura y la comprensión tanto del algoritmo como del programa. Por ejemplo, si se necesita un objeto para guardar el valor numérico del precio de algún producto, el identificador \texttt{p} sería una mala elección, mientras que \texttt{precio} sería mejor. Si se necesitan varios identificadores para distinguir los precios de diversos productos, podríamos usar algo como \texttt{precio\_manzana}, \texttt{precio\_banana}, etc. Otra opción podría ser \texttt{preciomanzana} o \texttt{precioManzana}, pero en este curso seguiremos la convención de usar guiones bajos para facilitar la lectura de los nombres elegidos. No sería posible usar como identificador a \texttt{precio\ manazana}, puesto que un nombre no puede tener espacios.

Ciertos objetos almacenan temporalmente un valor durante la ejecución de un proceso y su contenido puede cambiar mientras corre el programa. Este tipo de objetos reciben el nombre de \textbf{variables}. Por ejemplo, en un programa creado para un comercio puede existir un objeto llamado \texttt{stock} (identificador) de tipo numérico que representa la cantidad de artículos disponibles y cuyo valor se modifica cada vez que se registra una nueva venta. Podemos pensar a una variable como una caja etiquetada con un nombre (su identificador) y que guarda un valor (numérico, lógico o de caracter).

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{images/02_obj/09_cajas2} 

}

\caption{La variable A contiene al valor 5.}\label{fig:cajas}
\end{figure}

Si un objeto tiene siempre necesariamente un valor fijo, se dice que es una \textbf{constante}. El valor es siempre el mismo para cualquier ejecución del programa, es decir, no puede cambiar de una ejecución a otra. Son ejemplos de constantes el número de meses del año, las constantes matemáticas tales como el número \(\pi\), los factores de conversión de unidades de medida, etc. Las constantes pueden usarse literalmente, es decir, usando explícitamente el valor, o también a través de un objeto que asocie un identificador al valor constante (por ejemplo, asociar el nombre \texttt{pi} a la constante 3.14159265).

\hypertarget{declaraciuxf3n-de-variables-y-constantes}{%
\subsection{Declaración de variables y constantes}\label{declaraciuxf3n-de-variables-y-constantes}}

Al expresar nuestros algoritmos en pseudocódigo tomaremos la costumbre de declarar al inicio del mismo las variables y constantes necesarias para resolver el problema, explicitando su identificador y determinando el tipo de valor que guarda. Muchos lenguajes de programación utilizan esta declaración para reservar en la memoria de la computadora un espacio para almacenar la información correspondiente de manera adecuada.

Veamos un ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ALGORITMO: "Calcular área de un círculo"}
\NormalTok{COMENZAR}
\NormalTok{    CONSTANTE numérica pi}
\NormalTok{    VARIABLE numérica radio, area}
\NormalTok{        ...restantes acciones del algoritmo...}
\NormalTok{FIN}
\end{Highlighting}
\end{Shaded}

Una vez que una variable o constante ha sido definida con un tipo particular, es incorrecto intentar asignarle un valor de otro tipo, por ejemplo, asignarle a la variable \texttt{radio} del ejemplo anterior un valor de tipo caracter. Esto generaría ambigüedad, además de que en ciertos lenguajes de programación produciría un error.

R es un lenguaje dinámico que no requiere la declaración previa de las variables que serán utilizadas, sino que estas pueden definirse dinámicamente a lo largo del programa. Por eso, incluiremos declaración de variables y constantes sólo en los algoritmos y no cuando estos sean traducidos a R. Al no necesitar una declaración previa, en R es posible asignar, por ejemplo, un valor de tipo caracter a un identificador que anteriormente contenía un valor de tipo numérico, pero trataremos de evitar esto.

\hypertarget{acciuxf3n-de-asignaciuxf3n}{%
\subsection{Acción de asignación}\label{acciuxf3n-de-asignaciuxf3n}}

Para hacer que una variable guarde un determinado valor se recurre a una \textbf{acción de asignación}. Mediante asignaciones podemos dar valores iniciales a las variables, modificar el valor que tenían hasta el momento o guardar en ellas resultados intermedios o finales del algoritmo.

En pseudocódigo expresaremos a la asignación como se muestra en estos ejemplos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ALGORITMO: "Calcular área de un círculo"}
\NormalTok{COMENZAR}
\NormalTok{    CONSTANTE numérica pi}
\NormalTok{    VARIABLE numérica radio, area}
\NormalTok{    pi \textless{}{-} 3.14159265358979}
\NormalTok{    radio \textless{}{-} 3}
\NormalTok{    ...restantes acciones del algoritmo...}
\NormalTok{FIN}
\end{Highlighting}
\end{Shaded}

Si intervienen variables o constantes en la expresión a la derecha de una acción de asignación, se usará el valor que tengan las mismas en ese momento. Por ejemplo, la siguiente secuencia de acciones en un algoritmo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var1 \textless{}{-} 2}
\NormalTok{var2 \textless{}{-} var1}
\NormalTok{var1 \textless{}{-} 7}
\NormalTok{var3 \textless{}{-} var1}
\end{Highlighting}
\end{Shaded}

resultará en que las variables \texttt{var1}, \texttt{var2} y \texttt{var3} tengan almacenados los valores 7, 2 y 7 respectivamente. Un caso particular se da cuando a una variable se le asigna el valor de una operación de la que forma parte la misma variable. Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stock \textless{}{-} 43}
\NormalTok{ventas \textless{}{-} 29}
\NormalTok{compras \textless{}{-} 12}
\NormalTok{stock \textless{}{-} stock {-} ventas + compras}
\end{Highlighting}
\end{Shaded}

\hypertarget{objetosenR}{%
\subsection{Creación y manejo de objetos en R}\label{objetosenR}}

En R también se usa el operador ``flechita'' para asignar valores a variables. Como lo vamos a usar muchísimas veces, es conveniente recordar su \emph{shortcut}: \texttt{Alt\ +\ -} (teclas \emph{Alt} y guión medio). Como ya mencionamos antes, R es un lenguaje dinámico, lo cual significa que no tenemos que declarar las variables antes de asignarles un valor. Por ejemplo, si necesitamos registrar el peso y lugar de nacimiento de una persona, solamente tenemos que hacer:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lugar\_nacimiento \textless{}{-} "Bombal"}
\NormalTok{peso\_nacimiento \textless{}{-} 3.423}
\end{Highlighting}
\end{Shaded}

En este caso, \texttt{lugar\_nacimiento} es un objeto de tipo carácter, ya que la información que contiene es \texttt{"Bombal"}, y \texttt{peso\_nacimiento} es un objeto numérico. Vale aclarar que en R el punto decimal se representa con el punto \texttt{.} y no con la coma \texttt{,} como solemos escribir habitualmente, por lo que el número indicado se lee ``tres coma cuatrocientos veintitrés'' y no ``tres mil cuatrocientos veintitrés''. Asimismo, no se usan separadores de miles al escribir los números.

Por otro lado, R provee algunas funciones para poder averiguar en cualquier momento qué tipo de dato está almacenado en alguna variable. Todavía no hemos definido formalmente a las \emph{funciones}, pero por ahora nos alcanza con saber que son otro tipo de objetos que cuando las usamos se encargan de cumplir con alguna tarea específica. Las funciones también tienen un nombre (\emph{identificador}) y están seguidas por un par de paréntesis, dentro de los cuales se escriben opciones para que ellas operen. La función \texttt{class()} es la que nos dice qué tipo de dato hay en una variable:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var1 }\OtherTok{\textless{}{-}} \DecValTok{2}
\NormalTok{var2 }\OtherTok{\textless{}{-}} \StringTok{"Hola Mundo"}
\NormalTok{var3 }\OtherTok{\textless{}{-}} \ConstantTok{TRUE}
\FunctionTok{class}\NormalTok{(var1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "numeric"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(var2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "character"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(var3)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "logical"
\end{verbatim}

También hay algunas funciones que devuelven \texttt{TRUE} o \texttt{FALSE} a modo de respuesta cuando le preguntamos a R si una variable tiene un dato de tipo numérico, caracter o lógico:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.numeric}\NormalTok{(var1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.numeric}\NormalTok{(var2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.character}\NormalTok{(var3)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.logical}\NormalTok{(var3)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

Todos los objetos que vamos definiendo en nuestro algoritmo y, posteriormente, en nuestro programa, forman parte del \emph{ambiente}. En Rstudio podemos ver listados todos los objetos presentes en el ambiente en la pestaña \emph{Environment} del panel superior derecho. También podemos ver en la consola un listado de todos los nombres de los objetos que existen en el ambiente con la función \texttt{ls()}, por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "var1" "var2" "var3"
\end{verbatim}

Es probable que mientras estamos escribiendo el código, necesitemos probar si algunas partes funcionan y para eso corremos algunas líneas de código, creando objetos en el ambiente. Entre intento e intento, probablemnte necesitemos borrar alguno o todos esos objetos que se crearon, para poder comenzar con un ambiente libre. Si deseamos borrar todos los objetos del ambiente podemos correr la sentencia \texttt{rm(list\ =\ ls())} o hacer clic en el ícono de la escoba en el panel \emph{Environment}. Si queremos eliminar sólo un objeto debemos ejecutar la función \texttt{rm()}, indicando entre paréntesis el identificador del objeto que deseamos borrar, por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rm}\NormalTok{(var1)}
\end{Highlighting}
\end{Shaded}

Todos los objetos generados viven temporalmente en la memoria de la computadora mientras dure la sesión de R en la que estamos trabajando. Si cerramos R, toda esa información desaparecerá. Muchas veces eso es algo deseable: una vez finalizado el programa, guardamos algún resultado que nos interese (por ejemplo, un conjunto de datos en un archivo de Excel) y todos los objetos del ambiente que fuimos necesitando en el camino son descartados. Sin embargo, en otras oportunidades nos interesa guardar de forma permanente en la computadora una copia de todo lo que se encuentra en el ambiente en un archivo dentro de alguna carpeta. Los archivos que contienen los objetos creados en R tienen extensión \texttt{.RData}. Estos archivos se generan con el ícono de guardar en la pestaña \emph{Environment} o usando la función \texttt{save.image()}, que necesita que escribamos entre los paréntesis la carpeta donde guardaremos el archivo y el nombre elegido para el mismo, por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{save.image}\NormalTok{(}\StringTok{"C:/Users/Marcos/Documentos/Facultad/objetos.RData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Si por el contrario necesitamos \emph{importar} al ambiente objetos que estén guardados en algún lugar de nuestra compu en un archivo \texttt{.RData}, podemos usar el ícono de abrir en la pestaña \emph{Environment} o la función \texttt{load()}, por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{load}\NormalTok{(}\StringTok{"C:/Users/Marcos/Documentos/Facultad/objetos.RData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{operadores}{%
\section{Operadores}\label{operadores}}

El desarrollo de un algoritmo involucra la necesidad de efectuar operaciones de distinto tipo entre los valores guardados en los objetos: suma, resta, concatenación de caracteres, comparaciones, etc. Los elementos que describen el tipo de operación a realizar entre dos objetos se denominan \textbf{operadores}.

\hypertarget{operadores-aritmuxe9ticos}{%
\subsection{Operadores aritméticos}\label{operadores-aritmuxe9ticos}}

Los operadores aritméticos permiten realizar operaciones matemáticas con datos de tipo numérico. A continuación presentamos su simbología más comúnmente empleada a la hora de expresarlos en pseudocódigo, junto con sus equivalentes en el lenguaje R:

\begin{longtable}[]{@{}
  >{\centering\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.3504}}
  >{\centering\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.2222}}
  >{\centering\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1282}}
  >{\centering\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.0769}}
  >{\centering\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.2222}}@{}}
\caption{\label{tab:op-mat} Operadores aritméticos.}\tabularnewline
\toprule()
\begin{minipage}[b]{\linewidth}\centering
Operación
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Operador en pseudocódigo
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Operador en R
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Ejemplo
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Rtdo para x \textless- 7, y \textless- 3
\end{minipage} \\
\midrule()
\endfirsthead
\toprule()
\begin{minipage}[b]{\linewidth}\centering
Operación
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Operador en pseudocódigo
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Operador en R
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Ejemplo
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Rtdo para x \textless- 7, y \textless- 3
\end{minipage} \\
\midrule()
\endhead
Suma & + & + & x + y & 10 \\
Resta & - & - & x - y & 4 \\
Multiplicación & * & * & x * y & 21 \\
División & / & / & x / y & 2.33 \\
Potenciación & \^{} & \^{} & x \^{} y & 343 \\
División entera & DIV & \%/\% & x \%/\% y & 2 \\
División módular (resto de la división) & MOD & \%\% & x \%\% y & 1 \\
\bottomrule()
\end{longtable}

Los operadores aritméticos actúan con un orden de prioridad establecido, también conocido como \emph{orden de evaluación} u \emph{orden de precedencia}, tal como estamos acostumbrados en matemática. Las expresiones entre paréntesis se evalúan primero. Si hay paréntesis anidados se evalúan desde adentro hacia afuera. Dentro de una misma expresión, \textbf{en R} los operadores se evalúan en este orden:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Potenciación (\texttt{\^{}})
\item
  División entera y módulo (\texttt{\%/\%}, \texttt{\%\%}, y cualquier otro operador especial del tipo \texttt{\%...\%})
\item
  Multiplicación y división (\texttt{*}, \texttt{/})
\item
  Suma y resta (\texttt{+}, \texttt{-})
\end{enumerate}

Si la expresión presenta operadores con igual nivel de prioridad, se evalúan de izquierda a derecha. Veamos algunos ejemplos:

\begin{longtable}[]{@{}cc@{}}
\caption{\label{tab:ej-op-mat} Ejemplos de operaciones aritméticas según el orden de precedencia de R.}\tabularnewline
\toprule()
Operación & Resultado \\
\midrule()
\endfirsthead
\toprule()
Operación & Resultado \\
\midrule()
\endhead
4 + 2 * 4 & 12 \\
23 * 2 / 5 & 9.2 \\
3 + 5 * (10 - (2 + 4)) & 23 \\
2.1 * 1.5 + 12.3 & 15.45 \\
2.1 * (1.5 + 12.3) & 28.98 \\
1 \%\% 4 & 1 \\
8 * (7 - 6 + 5) \%\% (1 + 8 / 2) - 1 & 7 \\
\bottomrule()
\end{longtable}

\hypertarget{operadores-relacionales-o-de-comparaciuxf3n}{%
\subsection{Operadores relacionales o de comparación}\label{operadores-relacionales-o-de-comparaciuxf3n}}

Los operadores relacionales sirven para comparar dos valores de cualquier tipo y dan como resultado un valor lógico: \emph{VERDADERO} (\texttt{T} o \texttt{TRUE} en R) o \emph{FALSO} (\texttt{F} o \texttt{FALSE} en R).

\begin{longtable}[]{@{}
  >{\centering\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.2000}}
  >{\centering\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.2737}}
  >{\centering\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1579}}
  >{\centering\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.0947}}
  >{\centering\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.2737}}@{}}
\caption{\label{tab:op-rel} Operadores relacionales o de comparación.}\tabularnewline
\toprule()
\begin{minipage}[b]{\linewidth}\centering
Comparación
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Operador en pseudocódigo
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Operador en R
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Ejemplo
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Rtdo para x \textless- 7, y \textless- 3
\end{minipage} \\
\midrule()
\endfirsthead
\toprule()
\begin{minipage}[b]{\linewidth}\centering
Comparación
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Operador en pseudocódigo
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Operador en R
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Ejemplo
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Rtdo para x \textless- 7, y \textless- 3
\end{minipage} \\
\midrule()
\endhead
Mayor que & \textgreater{} & \textgreater{} & x \textgreater{} y & TRUE \\
Menor que & \textless{} & \textless{} & x \textless{} y & FALSE \\
Mayor o igual que & \textgreater= & \textgreater= & x \textgreater= y & TRUE \\
Menor o igual que & \textless= & \textless= & x \textless= y & FALSE \\
Igual a & = o == & == & x == y & FALSE \\
Distinto a & ¬= o != & != & x != y & TRUE \\
\bottomrule()
\end{longtable}

Otros ejemplos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{3}
\NormalTok{b }\OtherTok{\textless{}{-}} \DecValTok{4}
\NormalTok{d }\OtherTok{\textless{}{-}} \DecValTok{2}
\NormalTok{e }\OtherTok{\textless{}{-}} \DecValTok{10}
\NormalTok{f }\OtherTok{\textless{}{-}} \DecValTok{15}
\NormalTok{(a }\SpecialCharTok{*}\NormalTok{ b) }\SpecialCharTok{==}\NormalTok{ (d }\SpecialCharTok{+}\NormalTok{ e)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(a }\SpecialCharTok{*}\NormalTok{ b) }\SpecialCharTok{!=}\NormalTok{ (f }\SpecialCharTok{{-}}\NormalTok{ b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

Es interesante notar que primero se evalúan las operaciones a cada lado de los operadores relacionales y luego se hace la comparación. Es decir, \textbf{los operadores aritméticos preceden a los relacionales en el orden de prioridad}. Por eso, en los ejemplos anteriores no eran necesarios los paréntesis y podríamos poner directamente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\SpecialCharTok{*}\NormalTok{ b }\SpecialCharTok{==}\NormalTok{ d }\SpecialCharTok{+}\NormalTok{ e}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\SpecialCharTok{*}\NormalTok{ b }\SpecialCharTok{!=}\NormalTok{ f }\SpecialCharTok{{-}}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

Si bien en pseudocódigo podemos usar tanto \texttt{=} o \texttt{==} para probar la igualdad entre dos elementos, \textbf{en R no debemos usar} \texttt{=} para este fin, puesto que \texttt{=} no es un operador de comparación sino de asignación, parecido al \texttt{\textless{}-}.

\hypertarget{operadores-luxf3gicos}{%
\subsection{Operadores lógicos}\label{operadores-luxf3gicos}}

Mientras que los operadores relacionales comparan cualquier tipo de valores, los operadores lógicos sólo toman operandos de tipo lógico y producen también un resultado lógico. Los operadores lógicos que utilizaremos son:

\begin{longtable}[]{@{}
  >{\centering\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1364}}
  >{\centering\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.2955}}
  >{\centering\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1705}}
  >{\centering\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1023}}
  >{\centering\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.2955}}@{}}
\caption{\label{tab:op-log} Operadores lógicos.}\tabularnewline
\toprule()
\begin{minipage}[b]{\linewidth}\centering
Operación
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Operador en pseudocódigo
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Operador en R
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Ejemplo
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Rtdo para x \textless- T, y \textless- F
\end{minipage} \\
\midrule()
\endfirsthead
\toprule()
\begin{minipage}[b]{\linewidth}\centering
Operación
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Operador en pseudocódigo
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Operador en R
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Ejemplo
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Rtdo para x \textless- T, y \textless- F
\end{minipage} \\
\midrule()
\endhead
Conjunción & Y & \&\& & x \&\& y & FALSE \\
Disyunción & O & \textbar\textbar{} & x \textbar\textbar{} y & TRUE \\
Negación & NO o ¬ & ! & !x & FALSE \\
\bottomrule()
\end{longtable}

\begin{itemize}
\tightlist
\item
  La operación de conjunción (Y) devuelve un valor \textbf{VERDADERO} sólo si son verdaderas \textbf{ambas} expresiones que vincula. Ejemplo: \texttt{(3\ \textgreater{}\ 2)\ Y\ (3\ \textgreater{}\ 5)} resulta en \texttt{VERDADERO\ Y\ FALSO} y esto es \texttt{FALSO}.
\item
  La operación de disyunción (O) devuelve un valor \textbf{VERDADERO} si \textbf{al menos una} de las dos expresiones que vincula es verdadera. Ejemplo: \texttt{(3\ \textgreater{}\ 2)\ O\ (3\ \textgreater{}\ 5)} resulta en \texttt{VERDADERO\ O\ FALSO} y esto es \texttt{VERDADERO}.
\item
  La operación de negación (NO) niega un valor lógico, es decir, devuelve el opuesto. Ejemplo: \texttt{NO\ (3\ \textgreater{}\ 2)} resulta en \texttt{NO\ VERDADERO} y esto es \texttt{FALSO}.
\end{itemize}

Tanto para la conjunción como para la disyunción, R provee dos operadores, repitiendo o no el símbolo correspondiente: \texttt{\&\&} vs \texttt{\&}; \texttt{\textbar{}\textbar{}} vs \texttt{\textbar{}}. Hay una diferencia entre ellos que por ahora no viene al caso, pero vamos a señalar que por ahora estaremos usando las versiones presentadas anteriormente: \texttt{\&\&} y \texttt{\textbar{}\textbar{}}.

La \textbf{tabla de verdad} o \textbf{tabla de valores de verdad} se utiliza para mostrar los resultados de estas operaciones lógicas:

\begin{longtable}[]{@{}cccc@{}}
\caption{\label{tab:verdad} Operadores relacionales o de comparación.}\tabularnewline
\toprule()
Valor 1 & Operador & Valor 2 & Resultado \\
\midrule()
\endfirsthead
\toprule()
Valor 1 & Operador & Valor 2 & Resultado \\
\midrule()
\endhead
F & Y & F & F \\
F & Y & V & F \\
V & Y & F & F \\
V & Y & V & V \\
F & O & F & F \\
F & O & V & V \\
V & O & F & V \\
V & O & V & V \\
& NO & F & V \\
& NO & V & F \\
\bottomrule()
\end{longtable}

Con estos operadores es posible construir evaluaciones lógicas más elaboradas como los siguientes ejemplos:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Evaluar si el valor de \texttt{ancho} está entre 5 y 7: \texttt{(ancho\ \textgreater{}\ 5)\ Y\ (ancho\ \textless{}\ 7)}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ancho }\OtherTok{\textless{}{-}} \FloatTok{6.4}
\NormalTok{(ancho }\SpecialCharTok{\textgreater{}} \DecValTok{5}\NormalTok{) }\SpecialCharTok{\&\&}\NormalTok{ (ancho }\SpecialCharTok{\textless{}} \DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}
\item
  Establecer si una persona estudia Estadística o Economía: \texttt{(carrera\ ==\ "Estadística")\ O\ (carrera\ ==\ "Economía")}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{carrera }\OtherTok{\textless{}{-}} \StringTok{"Administración"}
\NormalTok{(carrera }\SpecialCharTok{==} \StringTok{"Estadística"}\NormalTok{) }\SpecialCharTok{||}\NormalTok{ (carrera }\SpecialCharTok{==} \StringTok{"Economía"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE
\end{verbatim}
\item
  Determinar si una persona no estudia Estadística: \texttt{NO\ (carrera\ ==\ "Estadística")}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{carrera }\OtherTok{\textless{}{-}} \StringTok{"Administración"}
\SpecialCharTok{!}\NormalTok{(carrera }\SpecialCharTok{==} \StringTok{"Estadística"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}
\item
  Verificar que el valor guardado en \texttt{x} no sea igual a 2 ni a 3:

  \begin{itemize}
  \tightlist
  \item
    Opción correcta 1: \texttt{(x\ !=\ 2)\ Y\ (x\ !=\ 3)}
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Da verdadero porque x no es ni 2 ni 3}
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{10}
\NormalTok{(x }\SpecialCharTok{!=} \DecValTok{2}\NormalTok{) }\SpecialCharTok{\&\&}\NormalTok{ (x }\SpecialCharTok{!=} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Da falso porque x es igual a 3}
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{3}
\NormalTok{(x }\SpecialCharTok{!=} \DecValTok{2}\NormalTok{) }\SpecialCharTok{\&\&}\NormalTok{ (x }\SpecialCharTok{!=} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE
\end{verbatim}

  \begin{itemize}
  \tightlist
  \item
    Opción correcta 2: \texttt{NO\ ((x\ ==\ 2)\ O\ (x\ ==\ 3))}
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Da verdadero porque x no es ni 2 ni 3}
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{10}
\SpecialCharTok{!}\NormalTok{(x }\SpecialCharTok{==} \DecValTok{2} \SpecialCharTok{||}\NormalTok{ x }\SpecialCharTok{==} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Da falso porque x es igual a 3}
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{3}
\SpecialCharTok{!}\NormalTok{(x }\SpecialCharTok{==} \DecValTok{2} \SpecialCharTok{||}\NormalTok{ x }\SpecialCharTok{==} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE
\end{verbatim}

  \begin{itemize}
  \tightlist
  \item
    Opción incorrecta: \texttt{(x\ !=\ 2)\ O\ (x\ !=\ 3)}
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Da verdadero, porque al ser x igual a 3, es distinto de 2,}
\CommentTok{\# haciendo que la primera parte sea verdadera }
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{3}
\NormalTok{(x }\SpecialCharTok{!=} \DecValTok{2}\NormalTok{) }\SpecialCharTok{||}\NormalTok{ (x }\SpecialCharTok{!=} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}
\end{enumerate}

Este último ejemplo se relaciona con las \textbf{Leyes de Morgan}: siendo \texttt{b} y \texttt{c} valores lógicos, se tiene:

\begin{itemize}
\tightlist
\item
  \texttt{NO\ (b\ O\ c)} es equivalente a \texttt{NO\ b\ Y\ NO\ c}.
\item
  \texttt{NO\ (b\ Y\ c)} es equivalente a \texttt{NO\ b\ O\ NO\ c}.
\end{itemize}

Es importante notar que todos los paréntesis usados en el código de R del ejemplo 4 son innecesarios, puesto que \textbf{los operadores relacionales preceden a los lógicos en el orden de prioridad}. Sin embargo, a veces preferimos usar paréntesis para que la lectura sea más sencilla. En el siguiente ejemplo, ambas expresiones son equivalentes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ancho }\OtherTok{\textless{}{-}} \FloatTok{6.4}
\NormalTok{(ancho }\SpecialCharTok{\textgreater{}} \DecValTok{5}\NormalTok{) }\SpecialCharTok{\&\&}\NormalTok{ (ancho }\SpecialCharTok{\textless{}} \DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ancho }\SpecialCharTok{\textgreater{}} \DecValTok{5} \SpecialCharTok{\&\&}\NormalTok{ ancho }\SpecialCharTok{\textless{}} \DecValTok{7}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

Para pensar: predecir el resultado de las siguientes operaciones y luego verificar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{2}
\NormalTok{y }\OtherTok{\textless{}{-}} \SpecialCharTok{{-}}\DecValTok{2}
\NormalTok{x }\SpecialCharTok{\textgreater{}} \DecValTok{0} \SpecialCharTok{\&\&}\NormalTok{ y }\SpecialCharTok{\textless{}} \DecValTok{0}
\NormalTok{x }\SpecialCharTok{\textgreater{}} \DecValTok{0} \SpecialCharTok{||}\NormalTok{ y }\SpecialCharTok{\textless{}} \DecValTok{0}
\SpecialCharTok{!}\NormalTok{(x }\SpecialCharTok{\textgreater{}} \DecValTok{0} \SpecialCharTok{\&\&}\NormalTok{ y }\SpecialCharTok{\textless{}} \DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{evaluaciuxf3n-en-cortocircuito}{%
\subsubsection{Evaluación en cortocircuito}\label{evaluaciuxf3n-en-cortocircuito}}

Para evaluar la operación de conjunción \texttt{x\ \&\&\ y}, en R se comienza por evaluar la expresión del primer operando \texttt{x} y si su resultado es \texttt{FALSE} ya no se evalúa la expresión \texttt{y} del segundo operando. Esto es porque si \texttt{x} es \texttt{FALSE}, el resultado de \texttt{x\ \&\&\ y} ya no depende de \texttt{y}, será siempre \texttt{FALSE}. Por este motivo se dice que el operador \texttt{\&\&} se evalúa en \emph{cortocircuito}. La evaluación en cortocircuito evita realizar operaciones innecesarias\footnote{El otro operador de conjunción, \&, no evalúa en cortocircuito, además de poseer otras diferencias.}.

Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{y }\OtherTok{\textless{}{-}} \DecValTok{2}

\CommentTok{\# La primera parte da TRUE, se continúa con la segunda, pero da error porque no}
\CommentTok{\# existe un objeto llamado z}
\NormalTok{(y }\SpecialCharTok{\textgreater{}}\NormalTok{ x) }\SpecialCharTok{\&\&}\NormalTok{ (x }\SpecialCharTok{\textgreater{}}\NormalTok{ z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in eval(expr, envir, enclos): object 'z' not found
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# La primera parte da FALSE, entonces toda la operación será FALSE, no se}
\CommentTok{\# continúa con la segunda parte, con lo cual no se intenta usar el objeto}
\CommentTok{\# inexistente z y no hay error}
\NormalTok{(y }\SpecialCharTok{\textless{}}\NormalTok{ x) }\SpecialCharTok{\&\&}\NormalTok{ (x }\SpecialCharTok{\textgreater{}}\NormalTok{ z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE
\end{verbatim}

La operación de disyunción también se evalúa en cortocircuito, es decir, si se encuentra que uno de los operandos es \texttt{TRUE}, no hace falta evaluar los restantes, puesto que el resultado general será \texttt{TRUE}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Es TRUE porque la primera parte es TRUE, sin evaluar la segunda, que daría}
\CommentTok{\# error}
\NormalTok{(y }\SpecialCharTok{\textgreater{}}\NormalTok{ x) }\SpecialCharTok{||}\NormalTok{ (x }\SpecialCharTok{\textgreater{}}\NormalTok{ z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Como la primera parte es FALSE, debe evaluar la segunda, no encuentra a z y da}
\CommentTok{\# error}
\NormalTok{(x }\SpecialCharTok{\textgreater{}}\NormalTok{ y) }\SpecialCharTok{||}\NormalTok{ (x }\SpecialCharTok{\textgreater{}}\NormalTok{ z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in eval(expr, envir, enclos): object 'z' not found
\end{verbatim}

\hypertarget{orden-de-precedencia-completo-en-r}{%
\subsubsection{Orden de precedencia completo en R}\label{orden-de-precedencia-completo-en-r}}

Resumiendo la información anterior, a continuación se presenta el orden completo de precedencia de los operadores en R que utilizaremos (hay algunos más que pueden ver en \texttt{?Syntax}):

\begin{longtable}[]{@{}ccc@{}}
\caption{\label{tab:orden} Orden de precedencia de los operadores en R.}\tabularnewline
\toprule()
Orden & Operaciones & Operadores \\
\midrule()
\endfirsthead
\toprule()
Orden & Operaciones & Operadores \\
\midrule()
\endhead
1 & Potenciación & \^{} \\
2 & Signo de un número (ej: -3) & + - \\
3 & División entera y resto & \%/\% \%\% \\
4 & Multiplicación y división & * / \\
5 & Suma y resta & + - \\
6 & Operadores de comparación & \textless{} \textgreater{} \textless= \textgreater= == != \\
7 & Negación & ! \\
8 & Conjunción & \&\& \& \\
9 & Disyunción & \textbar\textbar{} \textbar{} \\
10 & Asignación (izquierda a derecha) & \textless- \\
\bottomrule()
\end{longtable}

Dentro de una misma expresión, operadores con igual prioridad se evalúan de izquierda a derecha.

\hypertarget{entrada-y-salida-de-informaciuxf3n}{%
\section{Entrada y salida de información}\label{entrada-y-salida-de-informaciuxf3n}}

En la resolución de problemas puede ser necesario que alguna fuente externa (como un usuario del programa) provea información. En estos casos se debe registrar dicha información como un valor que debe ser asignado a una variable. Cuando escribamos nuestros algoritmos en pseudocódigo, para esto utilizaremos la acción \texttt{LEER}. Cuando deseamos mostrar un resultado en un mensaje empleamos la acción \texttt{ESCRIBIR}. Las palabras o frases literales que se desean mostrar en el mensaje deben estar encerradas entre comillas porque son cadenas de texto, mientras que si se desea mostrar el valor de una variable se debe escribir su identificador sin comillas.

Por ahora, en R ejecutaremos a la acción \texttt{LEER} mediante la asignación directa de un valor a una variable a través del operador \texttt{\textless{}-}. La acción \texttt{ESCRIBIR} puede ser ejecutada a través de la función \texttt{cat()} si se quiere mostrar una frase compuesta. En los casos en los que sólo interesa mostrar un valor (sin escribir una frase) no será necesario usar \texttt{cat()}, ya que sencillamente al correr el nombre de un objeto, su valor es mostrado en la consola. En otros casos usaremos la función \texttt{print()}. Ya iremos viendo la utilidad de cada una de estas opciones.

Vamos a completar el ejemplo del algoritmo para el cálculo del área de un círculo, integrando todo lo mencionado anteriormente:

\textbf{Pseudocódigo}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ALGORITMO: "Calcular área de un círculo"}
\NormalTok{COMENZAR}
\NormalTok{    CONSTANTE numérica pi}
\NormalTok{    VARIABLE numérica radio, area}
\NormalTok{    pi \textless{}{-} 3.14159265358979}
\NormalTok{    LEER radio}
\NormalTok{    area \textless{}{-} pi * radio\^{}2}
\NormalTok{    ESCRIBIR "El área del círculo es " area}
\NormalTok{FIN}
\end{Highlighting}
\end{Shaded}

\textbf{En R}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PROGRAMA: "Calcular área de un círculo" {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}

\NormalTok{pi }\OtherTok{\textless{}{-}} \FloatTok{3.14159265358979}
\NormalTok{radio }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{area }\OtherTok{\textless{}{-}}\NormalTok{ pi }\SpecialCharTok{*}\NormalTok{ radio}\SpecialCharTok{\^{}}\DecValTok{2}
\FunctionTok{cat}\NormalTok{(}\StringTok{"El área del círculo es"}\NormalTok{, area)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
El área del círculo es 78.53982
\end{verbatim}

\emph{Nota}: \texttt{pi} ya es una constante incorporada en R Base, en realidad no es necesario crear esta constante y asignarle valor.

\hypertarget{directorio-de-trabajo}{%
\section{Directorio de trabajo}\label{directorio-de-trabajo}}

Antes de terminar este capítulo vamos a presentar un concepto fundamental acerca de cómo se relaciona R con el sistema opertaivo de nuestra computadora para poder tener acceso a nuestros archivos o para generar otros nuevos.

Al finalizar la sección \ref{objetosenR} vimos ejemplos en los que se utilizó R para, en primer lugar, generar un archivo llamado \texttt{objetos.RData} con todos los objetos existentes en nuestro ambiente de trabajo y, en segundo lugar, cargar la información que dicho archivo contiene:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{save.image}\NormalTok{(}\StringTok{"C:/Users/Marcos/Documentos/Facultad/objetos.RData"}\NormalTok{)}
\FunctionTok{load}\NormalTok{(}\StringTok{"C:/Users/Marcos/Documentos/Facultad/objetos.RData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

En ambos casos, dentro de las funciones \texttt{save.image()} y \texttt{load()} se tuvo que escribir la dirección completa que representa cuál es la ubicación exacta de dicho archivo en la computadora: \texttt{C:/Users/Marcos/Documentos/Facultad/objetos.RData}. Esto significa que el archivo se encuentra en la carpeta \texttt{Facultad}, que a su vez está dentro de la carpeta \texttt{Documentos}, dentro de \texttt{Marcos} y dentro de \texttt{Users}, en el disco C de la computadora.

Expresiones como \texttt{C:/Users/Marcos/Documentos/Facultad/objetos.RData} reciben el nombre de \textbf{ruta informática} o \emph{path} y sirven para referenciar de manera exacta la localización ya sea de una carpeta o de un archivo en particular dentro del sistema de archivos que maneja el sistema operativo de la computadora. Un \emph{path} está compuesto por todos los nombres de los directorios que ordenadamente nos permiten llegar hasta la carpeta o archivo de interés, separados por un carácter que dependiendo del sistema operativo puede ser una barra diagonal \texttt{/} o una barra inversa \texttt{\textbackslash{}}.

R siempre está mirando a alguna carpeta en particular dentro de la computadora, la cual recibe el nombre \textbf{directorio de trabajo} (o \emph{working directory}, \emph{wd}). Por ejemplo, en este momento y en mi computadora, R está posando su atención en una carpeta que se llama \texttt{introprog} y cuya ruta puedo descubrir con la función \texttt{getwd()}, que significa ``obtener (get) el directorio de trabajo (wd)'':

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{getwd}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "/home/marcos/GitProjects/introprog"
\end{verbatim}

Esto quiere decir que R puede ver y acceder de manera directa a todos los archivos que hay allí, sin necesidad de escribir la ruta completa. Por ejemplo, si en lugar de ejecutar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{save.image}\NormalTok{(}\StringTok{"C:/Users/Marcos/Documentos/Facultad/objetos.RData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

ejecuto sencillamente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{save.image}\NormalTok{(}\StringTok{"objetos.RData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

lo que ocurre es que el nuevo archivo se generará en mi directorio de trabajo (carpeta \texttt{introprog}) y no en la carpeta \texttt{Facultad}. Del mismo modo, si ejecuto:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{load}\NormalTok{(}\StringTok{"objetos.RData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

el software va a buscar el archivo \texttt{objetos.RData} en mi directorio de trabajo (carpeta \texttt{introprog}) y va a cargar su contenido al ambiente de trabajo. Si en dicha carpeta no existe un archivo con ese nombre, obtendremos un mensaje de error muy famoso:

\begin{verbatim}
cannot find file 'objetos.RData', probable reason 'No such file or directory'
\end{verbatim}

El directorio de trabajo por default suele ser la carpeta \emph{Documentos} o alguna equivalente y es la que vemos en el panel \texttt{Files} de RStudio. Podemos cambiar el directorio de trabajo por cualquier otra carpeta en la que queramos estar trabajando con la función \texttt{setwd()} (``setear el working directory''):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{setwd}\NormalTok{(}\StringTok{"/home/marcos/documents/introprog/tp1"}\NormalTok{)}
\FunctionTok{getwd}\NormalTok{()}
\StringTok{"/home/marcos/documents/introprog/tp1"}
\end{Highlighting}
\end{Shaded}

Por ejemplo, si estamos resolviendo un trabajo práctico para el cual tenemos varios archivos necesarios guardados en la carpeta \texttt{tp1}, tenemos dos opciones:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Sin importar cuál es nuestro directorio de trabajo, hacer referencia a dichos archivos con \emph{paths} completos, por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{load}\NormalTok{(}\StringTok{"/home/marcos/documents/introprog/tp1/objetos.RData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  Setear como directorio de trabajo a la carpeta del trabajo práctico y hacer un uso directo de los archivos que se encuentren allí:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{setwd}\NormalTok{(}\StringTok{"/home/marcos/documents/introprog/tp1"}\NormalTok{)}
\FunctionTok{load}\NormalTok{(}\StringTok{"objetos.RData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

Es importante recordar lo siguiente: al escribir \emph{paths}, R sólo reconoce como caracteres delimitadores entre los nombres de carpetas a la barra diagonal \texttt{/} o a dos barras invertidas \texttt{\textbackslash{}\textbackslash{}}. Quienes usan el sistema operativo Windows notarán que en el explorador de archivos, las rutas están delimitadas con una sola barra invertida \texttt{\textbackslash{}}. En el contexto de R, debe ser reemplazada por dos barras invertidas o por una sola barra diagonal.

\hypertarget{estructuras-de-control}{%
\chapter{Estructuras de control}\label{estructuras-de-control}}

Como mencionamos anteriormente, un algoritmo está compuesto por una sucesión ordenada de comandos que se ejecutan uno detrás de otro. Sin embargo, con frecuencia es necesario recurrir a comandos especiales que alteran o controlan el orden en el que se ejecutan las acciones. Llamamos \textbf{estructuras de control del flujo de las acciones} al conjunto de reglas que permiten controlar el flujo de las acciones de un algoritmo o programa. Las mismas pueden clasificarse en \textbf{secuenciales}, \textbf{condicionales} e \textbf{iterativas}.

\hypertarget{estructuras-de-control-secuenciales}{%
\section{Estructuras de control secuenciales}\label{estructuras-de-control-secuenciales}}

Las \textbf{estructuras secuenciales} están compuestas por un número definido de acciones que se ubican en un orden específico y se suceden una tras otra. Los ejemplos que hemos discutido anteriormente están conformados por este tipo de estructura.

\hypertarget{estructuras-de-control-condicionales}{%
\section{Estructuras de control condicionales}\label{estructuras-de-control-condicionales}}

En algunas partes de un algoritmo puede ser útil detenerse a hacer una pregunta porque se llegó a una situación en la que puede haber una o más opciones disponibles para continuar. Dependiendo de la respuesta a la pregunta, que siempre deberá ser \texttt{VERDADERO} (\texttt{TRUE}) o \texttt{FALSO} (\texttt{FALSE}), el algoritmo seguirá ciertas acciones e ignorará otras. Estas preguntas y respuestas representan procesos de toma de decisión que conducen a diferentes caminos dentro del algoritmo, permitiéndonos que la solución para el problema en cuestión sea flexible y se adapte a distintas situaciones. Este tipo de estructuras de control de las acciones reciben el nombre de \textbf{condicionales} (o \emph{estructuras de selección}) y pueden ser \textbf{simples}, \textbf{dobles} y \textbf{múltiples}.

\hypertarget{estructuras-condicionales-simples}{%
\subsection{Estructuras condicionales simples}\label{estructuras-condicionales-simples}}

Postulan una evaluación lógica y, si su resultado es \texttt{VERDADERO}, se procede a ejecutar las acciones encerradas por esta estructura. Se describen en pseudocódigo con la siguiente sintaxis:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{SI \textless{}condición\textgreater{} ENTONCES}
\NormalTok{    Acción/es}
\NormalTok{FIN SI}
\end{Highlighting}
\end{Shaded}

La palabra \texttt{SI} indica el comando de evaluación lógica, \texttt{\textless{}condición\textgreater{}} indica la condición a evaluar y \texttt{Acción/es} son las instrucciones que se realizarán sólo si se cumple la condición, es decir, si la evaluación resulta en \texttt{VERDADERO}. Si la condición no se verifica, no se ejecuta ninguna acción y el algoritmo sigue su estructura secuencial a continuación del \texttt{FIN\ SI}.

En R, la estructura que nos permite realizar esto es:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (}\SpecialCharTok{\textless{}}\NormalTok{condición}\SpecialCharTok{\textgreater{}}\NormalTok{) \{}
\NormalTok{    ...código para ejecutar acciones...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Por ejemplo, el siguiente algoritmo registra la edad de una persona y, en el caso de que sea mayor de edad, avisa que puede votar en las elecciones provinciales de Santa Fe:

\begin{verbatim}
ALGORITMO: "Analizar edad para votar"
COMENZAR
    VARIABLE numérica edad
    LEER edad
    SI edad >= 18 ENTONCES
        ESCRIBIR "Edad = " edad " años: puede votar"
    FIN SI
FIN
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Programa: "Analizar edad para votar" {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\NormalTok{edad }\OtherTok{\textless{}{-}} \DecValTok{21}
\ControlFlowTok{if}\NormalTok{ (edad }\SpecialCharTok{\textgreater{}=} \DecValTok{18}\NormalTok{) \{}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"Edad ="}\NormalTok{, edad, }\StringTok{"años: puede votar"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Edad = 21 años: puede votar
\end{verbatim}

Notar que si bien el uso de sangrías en el código es opcional, decidimos emplearlo para facilitar su lectura. Mantener la prolijidad en nuestros programas es esencial.

\hypertarget{estructuras-condicionales-dobles}{%
\subsection{Estructuras condicionales dobles}\label{estructuras-condicionales-dobles}}

Este tipo de estructura añade una acción a ejecutarse en el caso de que la condición evaluada no se verifique (es decir, devuelve el valor \texttt{FALSO}). La sintaxis es:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{SI \textless{}condición\textgreater{} ENTONCES}
\NormalTok{  Acción/es}
\NormalTok{SI NO}
\NormalTok{  Acción/es}
\NormalTok{FIN SI}
\end{Highlighting}
\end{Shaded}

La palabra \texttt{ENTONCES} antecede a las acciones que se realizan si se cumple la condición y la expresión \texttt{SI\ NO} a las que se realizan si no se verifica la misma.

En R se utiliza el comando \texttt{else}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (}\SpecialCharTok{\textless{}}\NormalTok{condición}\SpecialCharTok{\textgreater{}}\NormalTok{) \{}
\NormalTok{    ...código para ejecutar acciones...}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    ...código para ejecutar acciones...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Retomando el ejemplo anterior:

\begin{verbatim}
ALGORITMO: "Analizar edad para votar"
COMENZAR
    VARIABLE numérica edad
    LEER edad
    SI edad >= 18 ENTONCES
        ESCRIBIR "Edad = " edad " años: puede votar"
    SI NO
        ESCRIBIR "Edad = " edad " años: no puede votar"
    FIN SI
FIN
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Programa: "Analizar edad para votar" {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\NormalTok{edad }\OtherTok{\textless{}{-}} \DecValTok{21}
\ControlFlowTok{if}\NormalTok{ (edad }\SpecialCharTok{\textgreater{}=} \DecValTok{18}\NormalTok{) \{}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"Edad ="}\NormalTok{, edad, }\StringTok{"años: puede votar"}\NormalTok{)}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"Edad ="}\NormalTok{, edad, }\StringTok{"años: no puede votar"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Edad = 21 años: puede votar
\end{verbatim}

\hypertarget{estructuras-condicionales-muxfaltiples-o-anidadas}{%
\subsection{Estructuras condicionales múltiples o anidadas}\label{estructuras-condicionales-muxfaltiples-o-anidadas}}

Permiten combinar varias estructuras condicionales para establecer controles más complejos sobre el flujo de las acciones, representando una toma de decisión múltiple. Podemos ejemplificar la sintaxis de la siguiente forma:

\begin{verbatim}
SI <condición 1> ENTONCES
  Acción 1
SI NO
  SI <condición 2> ENTONCES
    Acción 2
  SI NO
    Acción 3
  FIN SI
FIN SI
\end{verbatim}

En la estructura anterior, hay una primera evaluación lógica en la cual si el resultado es \texttt{VERDADERO}, se ejecuta la Acción 1 y nada más. En cambio, si su resultado es \texttt{FALSO}, se procede a realizar una segunda evaluación lógica, que da lugar a la ejecución de la Acción 2 o de la Acción 3 si su resultado es \texttt{VERDADERO} o \texttt{FALSO}, respectivamente.

Se debe notar que luego del primer \texttt{SI\ NO} comienza una nueva estructura completa de \texttt{SI/ENTONCES/SI\ NO/FIN\ SI}. Cada \texttt{SI} termina con su propio \texttt{FIN\ SI}. Al traducir esto a R, se vuelve algo más sencillo:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (}\SpecialCharTok{\textless{}}\NormalTok{condición }\DecValTok{1}\SpecialCharTok{\textgreater{}}\NormalTok{) \{}
\NormalTok{    ...Acción }\DecValTok{1}\NormalTok{...}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\SpecialCharTok{\textless{}}\NormalTok{condición }\DecValTok{2}\SpecialCharTok{\textgreater{}}\NormalTok{) \{}
\NormalTok{    ...Acción }\DecValTok{2}\NormalTok{...}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    ...Acción }\DecValTok{3}\NormalTok{...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

El último bloque de acciones (\texttt{...Acción\ 3...}) se evaluará si ninguna de las condiciones lógicas anteriores fue \texttt{VERDADERO}.

En el ejemplo de la edad:

\begin{verbatim}
ALGORITMO: "Analizar edad para votar"
COMENZAR
    VARIABLE numérica edad
    LEER edad
    SI edad < 18 ENTONCES
        ESCRIBIR "Edad = " edad " años: no puede votar"
    SI NO
        SI edad >= 70 ENTONCES
            ESCRIBIR "Edad = " edad " años: puede votar opcionalmente"
        SI NO
            ESCRIBIR "Edad = " edad " años: debe votar obligatoriamente"
        FIN SI
    FIN SI
FIN
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Programa: "Analizar edad para votar" {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\NormalTok{edad }\OtherTok{\textless{}{-}} \DecValTok{21}
\ControlFlowTok{if}\NormalTok{ (edad }\SpecialCharTok{\textless{}} \DecValTok{18}\NormalTok{) \{}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"Edad ="}\NormalTok{, edad, }\StringTok{"años: no puede votar"}\NormalTok{)}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (edad }\SpecialCharTok{\textgreater{}=} \DecValTok{70}\NormalTok{) \{}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"Edad ="}\NormalTok{, edad, }\StringTok{"años: puede votar opcionalmente"}\NormalTok{)}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"Edad ="}\NormalTok{, edad, }\StringTok{"años: debe votar obligatoriamente"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Edad = 21 años: debe votar obligatoriamente
\end{verbatim}

\hypertarget{estructuras-de-control-iterativas}{%
\section{Estructuras de control iterativas}\label{estructuras-de-control-iterativas}}

Las estructuras de control iterativas son útiles cuando la solución de un problema requiere que se ejecute repetidamente un determinado conjunto de acciones. El número de veces que se debe repetir dicha secuencia de acciones puede ser fijo o puede variar dependiendo de algún dato o condición a evaluar en el algoritmo.

\hypertarget{estructuras-de-control-iterativas-con-un-nuxfamero-fijo-de-iteraciones}{%
\subsection{Estructuras de control iterativas con un número fijo de iteraciones}\label{estructuras-de-control-iterativas-con-un-nuxfamero-fijo-de-iteraciones}}

Se aplican cuando se conoce de antemano el número exacto de veces que se debe repetir una secuencia de acciones. También se conocen como \emph{bucles (loops) controlados por un conteo}, ya que el algoritmo va contando la cantidad de repeticiones haciendo uso de una variable que recibe el nombre de \textbf{variable de iteración}, \textbf{índice} o \textbf{conteo}.

Por ejemplo, imaginemos que queremos escribir un algoritmo que permita calcular la quinta potencia de cualquier número. Para esto, se debe tomar dicho número y multiplicarlo por sí mismo 5 veces. Por lo tanto, una posible solución es:

\begin{verbatim}
ALGORITMO: "Calcular la quinta potencia"
COMENZAR
    VARIABLE numérica x, resultado
    LEER x
    resultado <- 1
    resultado <- resultado * x
    resultado <- resultado * x
    resultado <- resultado * x
    resultado <- resultado * x
    resultado <- resultado * x
    ESCRIBIR x "elevado a la quinta es igual a" resultado
FIN
\end{verbatim}

Ya que sabemos que la multiplicación se debe repetir 5 veces, podemos resumir lo anterior con la siguiente estructura:

\begin{verbatim}
ALGORITMO: "Calcular la quinta potencia"
COMENZAR
    VARIABLE numérica x, resultado
    LEER x
    resultado <- 1
    PARA i DESDE 1 HASTA 5 HACER
        resultado <- resultado * x
    FIN PARA
    ESCRIBIR x "elevado a la quinta es igual a" resultado
FIN
\end{verbatim}

La letra \texttt{i} es la variable de iteración. Podríamos haber elegido otra letra u otra palabra en su lugar, pero emplear \texttt{i} es una elección bastante común. En este ejemplo, su única función es ir contando la cantidad de veces que se repiten las acciones encerradas dentro de la estructura \texttt{PARA/FIN\ PARA}. El bloque de instrucciones se repite tantas veces como \texttt{i} tarde en llegar a 5 partiendo desde 1. Por convención, a la variable de iteración no la declaramos junto con las otras variables numéricas (como \texttt{x} y \texttt{resultado}).

En R, el ejemplo anterior se implementa así:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Programa: "Calcular la quinta potencia" {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{4}
\NormalTok{resultado }\OtherTok{\textless{}{-}} \DecValTok{1}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{) \{}
\NormalTok{    resultado }\OtherTok{\textless{}{-}}\NormalTok{ resultado }\SpecialCharTok{*}\NormalTok{ x}
\NormalTok{\}}
\FunctionTok{cat}\NormalTok{(x, }\StringTok{"elevado a la quinta es igual a"}\NormalTok{, resultado)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4 elevado a la quinta es igual a 1024
\end{verbatim}

Dado que la variable de iteración toma un valor numérico que va cambiando en cada repetición del bloque, se puede aprovechar para hacer cuentas con el mismo. Por ejemplo, el siguiente algoritmo muestra la tabla del ocho:

\begin{verbatim}
ALGORITMO: "Mostrar tabla del 8"
COMENZAR
    VARIABLE numérica resultado
    PARA i DESDE 0 HASTA 10 HACER
        resultado <- 8 * i
        ESCRIBIR "8 x" i "=" resultado
    FIN PARA
FIN
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Programa: "Mostrar tabla del 8" {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{0}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) \{}
\NormalTok{    resultado }\OtherTok{\textless{}{-}} \DecValTok{8} \SpecialCharTok{*}\NormalTok{ i}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"8 x"}\NormalTok{, i, }\StringTok{"="}\NormalTok{, resultado, }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
8 x 0 = 0 
8 x 1 = 8 
8 x 2 = 16 
8 x 3 = 24 
8 x 4 = 32 
8 x 5 = 40 
8 x 6 = 48 
8 x 7 = 56 
8 x 8 = 64 
8 x 9 = 72 
8 x 10 = 80 
\end{verbatim}

En lo anterior, \texttt{\textbackslash{}n} es un carácter especial que indica ``salto de línea''. Si no lo agregamos, los mensajes se imprimirían uno al lado del otro en el mismo renglón:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Programa: "Mostrar tabla del 8" {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{0}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) \{}
\NormalTok{    resultado }\OtherTok{\textless{}{-}} \DecValTok{8} \SpecialCharTok{*}\NormalTok{ i}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"8 x"}\NormalTok{, i, }\StringTok{"="}\NormalTok{, resultado)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
8 x 0 = 08 x 1 = 88 x 2 = 168 x 3 = 248 x 4 = 328 x 5 = 408 x 6 = 488 x 7 = 568 x 8 = 648 x 9 = 728 x 10 = 80
\end{verbatim}

De manera general, la sintaxis para este tipo de estructuras es:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{PARA \textless{}variable\textgreater{} DESDE \textless{}valor1\textgreater{} HASTA \textless{}valor2\textgreater{} CON PASO \textless{}valor3\textgreater{} HACER}
\NormalTok{    Acción/es}
\NormalTok{FIN PARA}
\end{Highlighting}
\end{Shaded}

Dado un valor inicial \texttt{\textless{}valor1\textgreater{}} asignado a la \texttt{\textless{}variable\textgreater{}}, esta se irá aumentando o disminuyendo según el paso \texttt{\textless{}valor3\textgreater{}} hasta llegar a tomar el valor \texttt{\textless{}valor2\textgreater{}}. Si no se indica el paso se asume que la variable de iteración aumenta de uno en uno. En R:

\begin{verbatim}
for (<variable> in seq(<valor1>, <valor2>, <valor3>)) {
    ...Acción/es...
}
\end{verbatim}

Notar en el ejemplo de la quinta potencia que \texttt{1:5} es lo mismo que \texttt{seq(1,\ 5,\ 1)}, pero podemos usar la función \texttt{seq()} en otros contextos más complejos, donde la variable de iteración puede pegar otros saltos en lugar de uno en uno.

\hypertarget{estructuras-de-control-iterativas-con-un-nuxfamero-indeterminado-de-iteraciones}{%
\subsection{Estructuras de control iterativas con un número indeterminado de iteraciones}\label{estructuras-de-control-iterativas-con-un-nuxfamero-indeterminado-de-iteraciones}}

En otras circunstancias se puede necesitar repetir un bloque de acciones sin conocer con exactitud cuántas veces, si no que esto depende de algún otro aspecto del algoritmo. Las iteraciones pueden continuar \emph{mientras que} o \emph{hasta que} se verifique alguna condición, dando lugar a dos tipos de estructuras. Estos casos también se conocen como \emph{bucles (loops) controlados por una condición}.

\hypertarget{mientras-que}{%
\subsubsection{Mientras que}\label{mientras-que}}

El conjunto de sentencias se repite mientras que se siga evaluando como \texttt{VERDADERO} una condición declarada al inicio del bloque. Cuando la condición ya no se cumple, el proceso deja de ejecutarse. La sintaxis es:

\begin{verbatim}
MIENTRAS QUE <condición> HACER
   Acción/es a repetir
FIN MIENTRAS
\end{verbatim}

En R:

\begin{verbatim}
while (<condición>) {
    ...Acción/es a repetir...
}
\end{verbatim}

Observaciones:

\begin{itemize}
\tightlist
\item
  La evaluación de la condición se lleva a cabo antes de cada iteración, incluso antes de ejecutar el código dentro del bloque por primera vez. Si la condición es \texttt{FALSO} inicialmente, entonces las acciones en el cuerpo de la estructura no se ejecutan nunca.
\item
  La evaluación de la condición \textbf{sólo} se lleva a cabo al inicio de cada iteración. Si la condición se vuelve \texttt{FALSO} en algún punto durante la ejecución de un bloque, el programa no lo nota hasta que se termine de ejecutar el bloque y la condición sea evaluada antes de comenzar la próxima iteración.
\end{itemize}

Veamos un ejemplo:

\begin{verbatim}
ALGORITMO: "Dividir un número por 2 hasta encontrar un valor menor que 0.01"
COMENZAR
    VARIABLE numérica x
    LEER x
    MIENTRAS QUE x >= 0.01 HACER
        x <- x / 2
        ESCRIBIR x
    FIN MIENTRAS
FIN
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{100}
\ControlFlowTok{while}\NormalTok{ (x }\SpecialCharTok{\textgreater{}=} \FloatTok{0.01}\NormalTok{) \{}
\NormalTok{    x }\OtherTok{\textless{}{-}}\NormalTok{ x }\SpecialCharTok{/} \DecValTok{2}
    \FunctionTok{cat}\NormalTok{(x, }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
50 
25 
12.5 
6.25 
3.125 
1.5625 
0.78125 
0.390625 
0.1953125 
0.09765625 
0.04882812 
0.02441406 
0.01220703 
0.006103516 
\end{verbatim}

\hypertarget{hasta-que}{%
\subsubsection{Hasta que}\label{hasta-que}}

A diferencia de la estructura \emph{MIENTRAS QUE}, la estructura \emph{HASTA QUE} repite el bloque de acciones hasta que se cumpla una condición, es decir, se ejecuta mientras que dicha condición sea evaluada como \texttt{FALSA}. La sintaxis es:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{REPETIR}
\NormalTok{   Acción/es}
\NormalTok{HASTA QUE \textless{}condición\textgreater{}}
\end{Highlighting}
\end{Shaded}

Observación: con la estructura \emph{MIENTRAS QUE} podría ser que el conjunto de sentencias nunca llegue a ejecutarse si desde partida la condición evaluada ya es falsa. Por el contrario, en la estructura \emph{HASTA QUE} el proceso se realiza al menos una vez, dado que la condición se evalúa al final.

El ejemplo anterior empleando este tipo de estructura:

\begin{verbatim}
ALGORITMO: "Dividir un número por 2 hasta encontrar un valor menor que 0.01"
COMENZAR
    VARIABLE numérica x
    LEER x
    REPETIR
        x <- x / 2
        ESCRIBIR x
    HASTA QUE x < 0.01
FIN
\end{verbatim}

En R este tipo de estructura se implementa con la sentencia \texttt{repeat\ \{\}}. Si bien a continuación se muestra el correspondiente ejemplo, no vamos a utilizar esta estructura, debido a que su escritura es más compleja y a que generalmente es posible obtener el mismo resultado con un \texttt{while\ ()\ \{\}}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{100}
\ControlFlowTok{repeat}\NormalTok{ \{}
\NormalTok{    x }\OtherTok{\textless{}{-}}\NormalTok{ x }\SpecialCharTok{/} \DecValTok{2}
    \FunctionTok{cat}\NormalTok{(x, }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
    \ControlFlowTok{if}\NormalTok{ (x }\SpecialCharTok{\textless{}} \FloatTok{0.01}\NormalTok{) }\ControlFlowTok{break}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
50 
25 
12.5 
6.25 
3.125 
1.5625 
0.78125 
0.390625 
0.1953125 
0.09765625 
0.04882812 
0.02441406 
0.01220703 
0.006103516 
\end{verbatim}

\hypertarget{loops-infinitos}{%
\subsubsection{Loops infinitos}\label{loops-infinitos}}

Con las sentencias de tipo \texttt{MIENTRAS\ QUE} se debe tener mucha precaución, puesto que si la evaluación lógica no está bien especificada o nunca deja de ser evaluada como \texttt{TRUE}, se incurre en un \emph{loop} infinito: el programa nunca deja de repetir el bloque (al menos hasta que la máquina se tilde o se produzca un error por desbordamiento de memoria, por ejemplo).

La siguiente situación ilustra esto:

\begin{verbatim}
var <- 9
while (var < 10) {
    var <- var - 1
    cat("var =", var, "No puedo parar!!!\n")
}

var = 8 No puedo parar!!!
var = 7 No puedo parar!!!
var = 6 No puedo parar!!!
var = 5 No puedo parar!!!
var = 4 No puedo parar!!!
var = 3 No puedo parar!!!
var = 2 No puedo parar!!!
var = 1 No puedo parar!!!
var = 0 No puedo parar!!!
var = -1 No puedo parar!!!
...
\end{verbatim}

En R se puede usar la instrucción \texttt{break} para forzar la detención del proceso iterativo si se presenta alguna condición en particular\footnote{También podemos usar \texttt{break} dentro de una estructura \texttt{for}}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var }\OtherTok{\textless{}{-}} \DecValTok{9}
\ControlFlowTok{while}\NormalTok{ (var }\SpecialCharTok{\textless{}} \DecValTok{10}\NormalTok{) \{}
\NormalTok{    var }\OtherTok{\textless{}{-}}\NormalTok{ var }\SpecialCharTok{{-}} \DecValTok{1}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"var ="}\NormalTok{, var, }\StringTok{"No puedo parar!!!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
    \ControlFlowTok{if}\NormalTok{ (var }\SpecialCharTok{==} \SpecialCharTok{{-}}\DecValTok{3}\NormalTok{) }\ControlFlowTok{break}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
var = 8 No puedo parar!!!
var = 7 No puedo parar!!!
var = 6 No puedo parar!!!
var = 5 No puedo parar!!!
var = 4 No puedo parar!!!
var = 3 No puedo parar!!!
var = 2 No puedo parar!!!
var = 1 No puedo parar!!!
var = 0 No puedo parar!!!
var = -1 No puedo parar!!!
var = -2 No puedo parar!!!
var = -3 No puedo parar!!!
\end{verbatim}

\hypertarget{ejemplos}{%
\section{Ejemplos}\label{ejemplos}}

A continuación se presentan algunos otros ejemplos

\begin{itemize}
\item
  No necesariamente tiene que ser \texttt{i} la variable iteradora, podemos darle cualquier nombre:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (guau }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{) \{}
    \FunctionTok{print}\NormalTok{(guau)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
\end{verbatim}

  La sentencia \texttt{print()} también sirve para mostrar resultados. La ventaja con respecto a \texttt{cat()} es que no necesitamos agregar \texttt{\textbackslash{}n} para que el siguiente mensaje se escriba en un nuevo renglón, ya que lo agrega por sí sola sin que lo pidamos. La desventaja es que no nos permite crear un mensaje combinando elementos separados entre comas, tal como se puede hacer con \texttt{cat()} (por ejemplo, \texttt{cat("El\ valor\ de\ x\ es\ igual\ a",\ x)}).
\item
  Acá tenemos un ejemplo de dos estructuras \texttt{for} anidadas. En primer lugar, \texttt{i} toma el valor 1, y entonces \texttt{j} varía de 1 a 2, generando las combinaciones \texttt{i\ =\ 1,\ j\ =\ 1;\ i\ =\ 1,\ j\ =\ 2}. Luego de que el \emph{loop} de \texttt{j} finalice habiendo recorrido todo su campo de variación, comienza la segunda iteración del \emph{loop} de \texttt{i}, actualizándose su valor a 2 y comenzando otra vez el \emph{loop} de \texttt{j}, que varía de 1 a 2. Así, se generan las combinaciones \texttt{i\ =\ 2,\ j\ =\ 1;\ i\ =\ 2,\ j\ =\ 2}. Finalmente, se actualiza \texttt{i} y pasa a valer 3, generando las combinaciones \texttt{i\ =\ 3,\ j\ =\ 1;\ i\ =\ 3,\ j\ =\ 2}. Para cada combinación, se muestra el valor de la suma:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{) \{}
    \ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{) \{}
\NormalTok{        suma }\OtherTok{\textless{}{-}}\NormalTok{ i }\SpecialCharTok{+}\NormalTok{ j}
        \FunctionTok{cat}\NormalTok{(}\StringTok{"i vale"}\NormalTok{, i, }\StringTok{"y j vale"}\NormalTok{, j, }\StringTok{". La suma es igual a"}\NormalTok{, suma, }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{) }
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
i vale 1 y j vale 1 . La suma es igual a 2 
i vale 1 y j vale 2 . La suma es igual a 3 
i vale 2 y j vale 1 . La suma es igual a 3 
i vale 2 y j vale 2 . La suma es igual a 4 
i vale 3 y j vale 1 . La suma es igual a 4 
i vale 3 y j vale 2 . La suma es igual a 5 
\end{verbatim}
\item
  Sumar los números naturales del 1 al 5:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{suma }\OtherTok{\textless{}{-}} \DecValTok{0}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{) \{}
\NormalTok{    suma }\OtherTok{\textless{}{-}}\NormalTok{ suma }\SpecialCharTok{+}\NormalTok{ i}
\NormalTok{\}}
\NormalTok{suma}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 15
\end{verbatim}
\item
  Sumar números naturales hasta que la suma pase el valor 100 y detenerse:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{suma }\OtherTok{\textless{}{-}} \DecValTok{0}
\NormalTok{i }\OtherTok{\textless{}{-}} \DecValTok{1}
\ControlFlowTok{while}\NormalTok{ (suma }\SpecialCharTok{\textless{}} \DecValTok{100}\NormalTok{) \{}
\NormalTok{    suma }\OtherTok{\textless{}{-}}\NormalTok{  suma }\SpecialCharTok{+}\NormalTok{ i}
\NormalTok{    i }\OtherTok{\textless{}{-}}\NormalTok{ i }\SpecialCharTok{+} \DecValTok{1}
\NormalTok{\}}
\NormalTok{suma}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 105
\end{verbatim}
\item
  Escribir todos los múltiplos de 8 menores que 150:

\begin{verbatim}
ALGORITMO: "Múltiplos de 8 menores a 150"
COMENZAR
    VARIABLE numérica multiplo
    multiplo <- 8
    MIENTRAS QUE multiplo < 150 HACER
        ESCRIBIR multiplo
        multiplo <- multiplo + 8
    FIN MIENTRAS
FIN
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Programa: "Múltiplos de 8 menores a 150" {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\NormalTok{multiplo }\OtherTok{\textless{}{-}} \DecValTok{8}
\ControlFlowTok{while}\NormalTok{ (multiplo }\SpecialCharTok{\textless{}} \DecValTok{150}\NormalTok{) \{}
    \FunctionTok{print}\NormalTok{(multiplo)}
\NormalTok{    multiplo }\OtherTok{\textless{}{-}}\NormalTok{ multiplo }\SpecialCharTok{+} \DecValTok{8}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 8
[1] 16
[1] 24
[1] 32
[1] 40
[1] 48
[1] 56
[1] 64
[1] 72
[1] 80
[1] 88
[1] 96
[1] 104
[1] 112
[1] 120
[1] 128
[1] 136
[1] 144
\end{verbatim}
\end{itemize}

\hypertarget{descomposiciuxf3n-algoruxedtmica}{%
\chapter{Descomposición algorítmica}\label{descomposiciuxf3n-algoruxedtmica}}

Un principio fundamental en la resolución de un problema es intentar descomponerlo en partes más pequeñas, que puedan ser más fáciles de afrontar. Este concepto también se aplica en la programación. Nuestros algoritmos pueden descomponerse en \textbf{subalgoritmos} que den solución a un aspecto del problema, de menor extensión. Este proceso se conoce como \textbf{descomposición algorítmica} o \textbf{descomposición modular}. Cada subalgoritmo debe ser independiente de los demás y a su vez podría seguir descomponiéndose en partes más sencillas en lo que se conoce como \textbf{refinamiento sucesivo}. Si un programa es muy largo se corre el riesgo de que sea muy difícil de entender como un todo, pero siempre se lo puede dividir en secciones más simples y manejables. Un subalgoritmo se escribe una vez y luego es utilizado por todos aquellos algoritmos que lo necesiten.

Cada vez que, como parte de la resolución de un problema, desde un algoritmo se solicita que se realicen las acciones establecidas por un subalgoritmo, se dice que se lo está \textbf{invocando} o \textbf{llamando}. Al algoritmo que invoca a los subalgoritmos a veces le decimos \emph{algoritmo principal} para darle un mayor énfasis a la idea que, desde el curso de acción principal, cada tanto se delega la ejecución de algunas tareas al subalgoritmo.

El empleo de subalgoritmos, desarrollando por separado ciertas partes del problema, resulta especialmente ventajoso en los casos siguientes:

\begin{itemize}
\tightlist
\item
  \textbf{En algoritmos complejos}: si el algoritmo, y luego el programa, se escribe todo seguido y en un único archivo de código, resulta muy complicado de entender, porque se pierde la visión de su estructura global dada la gran cantidad de operaciones que lo conforman. Aislando ciertas partes como subalgoritmos separados se reduce la complejidad.
\item
  \textbf{Cuando se repiten operaciones análogas}: si la resolución de un problema requiere realizar una tarea que se repite varias veces en el algoritmo, podemos definir dicha tarea como un subalgoritmo por separado. De esta manera, su código se escribirá sólo una vez aunque se use en muchos puntos del programa.
\end{itemize}

En este capítulo hay algunas secciones indicadas como ``opcionales'' y algunos comentarios agregados como notas al pie. Estas partes añaden información para quienes estén interesados en saber un poco más, pero su contenido no será requerido en la práctica ni en las evaluaciones.

\hypertarget{tipos-de-subalgoritmos}{%
\section{Tipos de subalgoritmos}\label{tipos-de-subalgoritmos}}

En el mundo de la programación existen muchos términos para definir distintos tipos de subalgoritmos: subrutinas, funciones, procedimientos, métodos, subprogramas, etc. No es posible obtener una definición que capture todas las variantes que existen en el uso de estos términos debido a que el significado de cada uno de ellos varía según el paradigma
\footnote{Se usa el término paradigma de programación para clasificar a los lenguajes según sus características. En \href{https://hackr.io/blog/programming-paradigms}{este link} se puede encontrar una breve descripción de los principales paradigmas de programación}
y el lenguaje de programación escogidos.

Sin embargo, suele haber bastante consenso en distinguir, dentro de los subalgoritmos, a las \textbf{funciones} y a los \textbf{procedimientos} de esta forma:

\begin{itemize}
\tightlist
\item
  Una \textbf{función} es un subalgoritmo que al ser evaluado devuelve un único resultado (por ejemplo, un valor numérico) que es utilizado en el algoritmo principal que lo invoca.
\item
  Un \textbf{procedimiento} es un subalgoritmo que al ser evaluado no devuelve un valor, sino que produce \emph{efectos secundarios} en el ambiente del algoritmo principal que lo invoca. Persigue el objetivo de ayudar en la modularidad del programa.
\end{itemize}

\hypertarget{funciones}{%
\section{Funciones}\label{funciones}}

Una \textbf{función} es un subalgoritmo que devuelve un único resultado a partir de otros valores provistos. El valor que la función devuelve define su \textbf{tipo}, de modo que una función puede ser de tipo \textbf{numérica}, \textbf{carácter} o \textbf{lógica} \footnote{No siempre se pueden clasificar de esta forma a las funciones, ya que hay algunas que pueden devolver distintos tipos de valores según el caso o que devuelven otras clases de objetos.}.

Para ejemplificar, podemos decir que la noción de \emph{función} en programación se asemeja a la idea matemática de \emph{función de una o más variables}. Podemos pensar en la función \(f(x, y) = x^2 + 3y\) (ejemplo 1). Si queremos saber cuál es el valor numérico de la función \(f\) cuando \(x\) toma el valor \(4\) e \(y\) toma el valor \(5\), reemplazamos en la expresión anterior las variables por los valores mencionados y obtenemos: \(f(4, 5) = 4^2 + 3 \times 5 = 31\).

Podemos definir dicha función en pseudocódigo de la siguiente manera:

\begin{verbatim}
FUNCIÓN f(x: numérico, y: numérico): numérico
COMENZAR
    DEVOLVER x^2 + 3 * y
FIN FUNCIÓN
\end{verbatim}

El primer renglón de la definición comienza con la palabra clave \texttt{FUNCIÓN} y termina, luego de los dos puntos, con la palabra \texttt{numérico} para indicar que esta función devuelve como resultado un valor numérico.

En el medio se encuentra el nombre elegido para la función (\texttt{f}), seguido por la declaración entre paréntesis de los \emph{parámetros} o \emph{argumentos} que la función necesita para operar, es decir, el \emph{input} o información de entrada con la cual se realizarán las operaciones. Se dice que \(x\) e \(y\) son los \textbf{parámetros formales} o \textbf{ficticios}, ya que no tienen un valor asignado en sí mismos sino que permiten expresar de manera general las acciones que la función ejecuta. Describen lo que uno diría en palabras: ``hay que tomar a \(x\), elevarlo al cuadrado y sumarle la \(y\) multiplicada por 3''. Entre los paréntesis también se aclara que estos parámetros formales son de tipo numérico.

Los valores en los cuales se quiere evaluar la función se llaman \textbf{parámetros actuales} o \textbf{reales}. Por ejemplo, si nos interesa calcular \(f(4, 5)\), los valores \(4\) y \(5\) son los parámetros actuales y se establece una correspondencia entre el parámetro formal \(x\) y el actual \(4\), así como entre la \(y\) y el \(5\). El resultado que se obtiene, como observamos antes, es \(31\) y este es el valor que la función \emph{devuelve}.

La definición anterior también puede ser expresada como:

\begin{verbatim}
FUNCIÓN f(x: numérico, y: numérico): numérico
COMENZAR
    VARIABLE numérica resultado
    resultado <- x^2 + 3 * y
    DEVOLVER resultado
FIN FUNCIÓN
\end{verbatim}

Aquí notamos que no debemos declarar a \texttt{x} e \texttt{y} puesto que son los parámetros de la función (quedan declarados entre los paréntesis en la primera línea). Sin embargo, sí declaramos cualquier otra nueva variable que sea creada dentro de la función, por ejemplo, la variable \texttt{resultado}.

De manera general, la definición de una función es:

\begin{verbatim}
FUNCIÓN nombre(lista de parámetros formales): tipo de resultado
COMENZAR
    Declaración de variables
    Acciones
    DEVOLVER valor
FIN FUNCIÓN
\end{verbatim}

La palabra clave \texttt{DEVOLVER} provoca la inmediata finalización de la ejecución de la función e indica cuál es el resultado de la misma, cuyo tipo debe coincidir con el tipo de función declarado en el encabezado. La acción \texttt{DEVOLVER} se puede insertar en cualquier punto del cuerpo de la función y, además, es posible utilizar más de una sentencia \texttt{DEVOLVER} en una misma función, aunque sólo una llegue a ejecutarse. Esto puede verse en el siguiente ejemplo (ejemplo 2):

\begin{verbatim}
FUNCIÓN maximo(num1: numérico, num2: numérico): numérico
COMENZAR
    SI num1 >= num2 ENTONCES
        DEVOLVER num1
    SI NO
        DEVOLVER num2
    FIN SI
FIN FUNCIÓN
\end{verbatim}

Para usar una función en un algoritmo, se la invoca escribiendo su nombre seguido por los valores actuales entre paréntesis, separados por coma. Esta invocación representa un valor que puede ser usado como operando en otra expresión. Por ejemplo:

\begin{verbatim}
ALGORITMO: "Hallar el máximo entre dos valores y restarle 100"
COMENZAR
    VARIABLE numérica x, y, rtdo
    LEER x, y
    rtdo <- maximo(x, y) - 100
    ESCRIBIR "El resultado es " rtdo
FIN
\end{verbatim}

Al invocar una función es obligatorio que los valores suministrados para los argumentos actuales entre los paréntesis correspondan en cantidad, tipo y orden con los argumentos formales de la definición de la función. Es por esto que los siguientes casos son ejemplos de un \textbf{uso incorrecto} de funciones en el algoritmo principal:

\begin{verbatim}
ALGORITMO: "Incorrecto por proveer pocos argumentos para la función"
COMENZAR
    VARIABLE numérica x, y, rtdo
    LEER x, y
    rtdo <- maximo(x) - 100
    ESCRIBIR "El resultado es " rtdo
FIN

ALGORITMO: "Incorrecto por proveer valores de tipo carácter para la función"
COMENZAR
    VARIABLE numérica rtdo
    VARIABLE carácter x, y
    x <- "chau"
    y <- "hola"
    rtdo <- maximo(x, y) - 100
    ESCRIBIR "El resultado es " rtdo
FIN

ALGORITMO: "Incorrecto por no proveer argumentos para la función"
COMENZAR
    VARIABLE numérica x, y, rtdo
    LEER x, y
    rtdo <- maximo - 100
    ESCRIBIR "El resultado es " rtdo
FIN
\end{verbatim}

Para motivar el uso de una buena práctica que ayude a distinguir entre las acciones de los subalgoritmos y del algoritmo, vamos a escribir los subalgoritmos \textbf{antes} y \textbf{por fuera} del algoritmo principal\footnote{Es más, podríamos escribirlos y guardarlos en archivos distintos.}. Consideremos el ejemplo 3 mostrado a continuación. Primero definimos los subalgoritmos que necesitaremos (son los de los ejemplos 1 y 2) y luego escribiremos un algoritmo principal que hace uso de ellos para resolver un problema en particular:

\begin{verbatim}
---------------------------------------------------------------
SUBALGORITMOS
---------------------------------------------------------------

FUNCIÓN f(x: numérico, y: numérico): numérico
COMENZAR
    DEVOLVER x^2 + 3 * y
FIN FUNCIÓN

FUNCIÓN maximo(num1: numérico, num2: numérico): numérico
COMENZAR
    SI num1 >= num2 ENTONCES
        DEVOLVER num1
    SI NO
        DEVOLVER num2
    FIN SI
FIN FUNCIÓN

--------------------------------------------------------------
ALGORITMO PRINCIPAL
--------------------------------------------------------------

ALGORITMO: "Realizar operaciones matemáticas muy importantes"
COMENZAR
    VARIABLE numérica rtdo1, rtdo2, rtdo3
    rtdo1 <- f(2, 5)
    rtdo2 <- f(3, 10)
    rtdo3 <- maximo(rtdo1, rtdo2) + 20
    ESCRIBIR "El resultado es " rtdo3
FIN
\end{verbatim}

¿Qué mensaje escribe el algoritmo anterior?

\hypertarget{funciones-en-r}{%
\section{Funciones en R}\label{funciones-en-r}}

En la sección anterior vimos cómo definir funciones en pseudocódigo. Antes de pasar a ver cómo programar nuestras funciones en R, vamos a comentar algunas cuestiones acerca de las funciones que R ya trae disponibles como parte de su funcionalidad básica.

\hypertarget{funcpredef}{%
\subsection{Funciones predefinidas de R}\label{funcpredef}}

R, como todo lenguaje de programación, tiene \textbf{funciones predefinidas}, es decir, sentencias que se encargan de realizar alguna actividad. Ya estuvimos usando algunas de ellas, por ejemplo, cuando hemos necesitado mostrar algún mensaje usamos las funciones \texttt{cat()} o \texttt{print()}\footnote{Sentencias como \texttt{for}, \texttt{while} o \texttt{if} también son funciones, aunque con una estructura muy particular.}. Además, existen muchas otras funciones predefinidas, como todas aquellas que se necesitan para realizar ciertas operaciones matemáticas:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Raíz cuadrada}
\FunctionTok{sqrt}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Valor absoluto}
\FunctionTok{abs}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 100
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Función exponencial}
\FunctionTok{exp}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2.688117e+43
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Logaritmo natural}
\FunctionTok{log}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 4.60517
\end{verbatim}

En los ejemplos anteriores, \texttt{100} representa un valor numérico que se pasa como argumento a la función para que la misma opere. Algunas funciones predefinidas en R pueden trabajar con más de un argumento, en cuyo caso hay que enumerarlos dentro de los paréntesis, separados con comas. Por ejemplo, si en lugar de calcular el logaritmo natural (cuya base es la constante matemática \(e\)), queremos calcular un logaritmo en base 10, podemos hacer lo siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Logaritmo de 100 en base 10}
\FunctionTok{log}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2
\end{verbatim}

¿Cómo sabemos que la función \texttt{log()} se puede usar de esa forma, cambiando el valor de la base con respecto a la cual toma el logaritmo? Lo aprendemos al leer el manual de ayuda de R. Toda función predefinida de R viene con un instructivo que detalla cómo se usa, qué argumentos incluye y otras aclaraciones. Lo encontramos en la pestaña de Ayuda (\emph{Help}) en el panel de abajo a la derecha en RStudio. Otras formas de abrir la página de ayuda sobre una función es correr en la consola alguna de estas sentencias:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{help}\NormalTok{(log)}
\NormalTok{?log}
\end{Highlighting}
\end{Shaded}

Esa página de ayuda tiene bastante información, porque reúne información sobre muchas funciones relacionadas con logaritmos y exponenciales, pero podemos detenernos en la parte resaltada que se muestra a continuación:

\begin{figure}

{\centering \includegraphics[width=0.7\linewidth]{images/03_funciones/ayuda} 

}

\caption{Captura de pantalla de la ayuda sobre la función log()}\label{fig:unnamed-chunk-73}
\end{figure}

En la sección \emph{Usage} (``uso'') descubrimos que la función \texttt{log()} puede usarse con dos argumentos: \texttt{x} y \texttt{base}. En la sección \emph{Arguments} entendemos que \texttt{x} es el número al cual le vamos a sacar el logaritmo y \texttt{base} es la base con respecto a la cual se toma el logaritmo. Por eso, al correr \texttt{log(100,\ 10)}, estamos calculando el logaritmo de \texttt{x\ =\ 100} con \texttt{base\ =\ 10}.

Vemos, además, una diferencia en la forma en que \texttt{x} y \texttt{base} aparecen en la descripción: \texttt{log(x,\ base\ =\ exp(1))}. Cuando un argumento tiene un signo \texttt{=} significa que tiene asignado un \textbf{valor por default} y que no es necesario usarlo. Por eso, cuando corremos \texttt{log(100)} estamos calculando el logaritmo de \texttt{x\ =\ 100} con la base elegida por R por defecto: \texttt{base\ =\ exp(1)}, que es la forma que tiene R de nombrar a la constante \(e = 2.718282...\) (es el logaritmo natural). Si quiero cambiar la base, debo proveer un valor, por ejemplo, \texttt{log(100,\ 10)}. Por el contrario, el argumento \texttt{x} no tiene asignado un valor por default. Eso significa que obligatoriamente tenemos que proveer un valor para el mismo.

R también permite usar una función escribiendo los nombres de los argumentos (es decir, detallando tanto los parámetros formales como los actuales), lo cual muchas veces es muy esclarecedor:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{log}\NormalTok{(}\AttributeTok{x =} \DecValTok{100}\NormalTok{, }\AttributeTok{base =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2
\end{verbatim}

Es más, si escribimos los nombres de los parámetros explícitamente, podemos cambiar su orden, sin alterar el resultado:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{log}\NormalTok{(}\AttributeTok{base =} \DecValTok{10}\NormalTok{, }\AttributeTok{x =} \DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2
\end{verbatim}

Si no escribimos los nombres, el orden importa:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{log}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{log}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 0.5
\end{verbatim}

Al no tener los nombres indicados explícitamente, R hace corresponder los parámetros formales \texttt{x} y \texttt{base} con los valores provistos en ese orden: en el primer caso \texttt{x} recibe el valor \texttt{100} y \texttt{base}, el valor \texttt{10}, mientras que en el segundo caso es al revés.

Finalmente, se debe observar que no es necesario invocar a la función escribiendo de forma directa los valores entre los paréntesis, sino que en su lugar pueden ir variables:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{100}
\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ x }\SpecialCharTok{/} \DecValTok{2}
\NormalTok{z }\OtherTok{\textless{}{-}} \DecValTok{4}
\FunctionTok{log}\NormalTok{(x }\SpecialCharTok{{-}}\NormalTok{ y, }\DecValTok{4}\NormalTok{)       }\CommentTok{\# Log en base 4 de x {-} y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2.821928
\end{verbatim}

\hypertarget{definiciuxf3n-de-nuevas-funciones-en-r}{%
\subsection{Definición de nuevas funciones en R}\label{definiciuxf3n-de-nuevas-funciones-en-r}}

Ahora que ya hemos visto cómo se trabaja con funciones en R de manera general, vamos a aprender a definir nuestras propias funciones. Recordemos el subalgoritmo del ejemplo 1:

\begin{verbatim}
FUNCIÓN f(x: numérico, y: numérico): numérico
COMENZAR
    VARIABLE numérica resultado
    resultado <- x^2 + 3 * y
    DEVOLVER resultado
FIN FUNCIÓN
\end{verbatim}

En R, definimos esta función así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, y) \{}
\NormalTok{    resultado }\OtherTok{\textless{}{-}}\NormalTok{ x}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+} \DecValTok{3} \SpecialCharTok{*}\NormalTok{ y}
    \FunctionTok{return}\NormalTok{(resultado)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/03_funciones/31} 

}

\caption{Estructura de una función en R}\label{fig:unnamed-chunk-79}
\end{figure}

La estructura general es:

\begin{verbatim}
nombre <- function(argumentos) {
  ... sentencias de R ...
}
\end{verbatim}

Debemos:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Elegir un nombre
\item
  Al lado del nombre, colocar el operador de asignación (\texttt{\textless{}-}) para asociar a ese nombre la definición de una función.
\item
  Escribir la sentencia \texttt{function(...)\ \{...\}}, donde entre paréntesis se definen todos los parámetros formales separados con coma y entre llaves el conjunto de acciones a englobar.
\item
  El valor que la función debe arrojar como resultado se encierra dentro de la sentencia \texttt{return()}, que indica el fin de la ejecución.
\end{enumerate}

Una vez que la definición de la función es ejecutada, pasa a formar parte de los elementos que conforman al ambiente, como se puede apreciar al verla listada como un objeto más en el panel \emph{Environment} de RStudio \footnote{Sí, las funciones que creamos también son \emph{objetos} para R, ya que son una pieza que guarda algún tipo de información. Las funciones en R son objetos de clase ``function''. Ver, por ejemplo, \texttt{class(f)}}. A partir de este momento, podemos utilizarla, como parte de otro programa. Para invocarla, escribimos el nombre de la función y entre paréntesis los valores que nos interesan para el cálculo (parámetros actuales). Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ejemplos de uso de la función f}
\FunctionTok{f}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 31
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f}\NormalTok{(}\DecValTok{6}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 21
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 0
\end{verbatim}

Recordando lo discutido en la sección anterior, podemos apreciar que los siguientes usos de la función \texttt{f()} son equivalentes:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 31
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f}\NormalTok{(}\AttributeTok{x =} \DecValTok{4}\NormalTok{, }\AttributeTok{y =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 31
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f}\NormalTok{(}\AttributeTok{y =} \DecValTok{5}\NormalTok{, }\AttributeTok{x =} \DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 31
\end{verbatim}

Sin embargo, no son equivalentes los siguientes:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Siguiendo el orden de definición, x recibe el valor 4, y recibe el 5:}
\FunctionTok{f}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 31
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Siguiendo el orden de definición, x recibe el valor 5, y recibe el 4:}
\FunctionTok{f}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 37
\end{verbatim}

A continuación, podemos ver casos que generan error por hacer un uso incorrecto de la función (¿por qué?):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Error por omitir un argumento de uso obligatorio (x recibe 4, falta y)}
\FunctionTok{f}\NormalTok{(}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in f(4): argument "y" is missing, with no default
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Error por proveer más argumentos de los declarados en la definición}
\FunctionTok{f}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in f(4, 5, 6): unused argument (6)
\end{verbatim}

Retomemos ahora el ejemplo 3. Mencionamos que es importante distinguir entre la definición de los subalgoritmos y la de un algoritmo principal que los invoca:

\begin{verbatim}
---------------------------------------------------------------
SUBALGORITMOS
---------------------------------------------------------------

FUNCIÓN f(x: numérico, y: numérico): numérico
COMENZAR
    DEVOLVER x^2 + 3 * y
FIN FUNCIÓN

FUNCIÓN maximo(num1: numérico, num2: numérico): numérico
COMENZAR
    SI num1 >= num2 ENTONCES
        DEVOLVER num1
    SI NO
        DEVOLVER num2
    FIN SI
FIN FUNCIÓN

--------------------------------------------------------------
ALGORITMO PRINCIPAL
--------------------------------------------------------------

ALGORITMO: "Realizar  operaciones matemáticas muy importantes"
COMENZAR
    VARIABLE numérica rtdo1, rtdo2, rtdo3
    rtdo1 <- f(2, 5)
    rtdo2 <- f(3, 10)
    rtdo3 <- maximo(rtdo1, rtdo2) + 20
    ESCRIBIR "El resultado es " rtdo3
FIN
\end{verbatim}

Esta distinción también es importante en R: la definición de las funciones debe ejecutarse antes de que las mismas sean llamadas desde el programa principal. Así, para traducir el pseudocódigo anterior a R, podríamos crear un archivo de código (llamado, por ejemplo, \texttt{ejemplo3.R}) con el siguiente contenido:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# DEFINICIÓN DE FUNCIONES}
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}

\NormalTok{f }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, y) \{}
\NormalTok{    resultado }\OtherTok{\textless{}{-}}\NormalTok{ x}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+} \DecValTok{3} \SpecialCharTok{*}\NormalTok{ y}
    \FunctionTok{return}\NormalTok{(resultado)}
\NormalTok{\}}

\NormalTok{maximo }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(num1, num2) \{}
    \ControlFlowTok{if}\NormalTok{ (num1 }\SpecialCharTok{\textgreater{}}\NormalTok{ num2) \{}
        \FunctionTok{return}\NormalTok{(num1)}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \FunctionTok{return}\NormalTok{(num2)}
\NormalTok{    \}}
\NormalTok{\}}

\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# PROGRAMA PRINCIPAL}
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}

\NormalTok{rtdo1 }\OtherTok{\textless{}{-}} \FunctionTok{f}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\NormalTok{rtdo2 }\OtherTok{\textless{}{-}} \FunctionTok{f}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{rtdo3 }\OtherTok{\textless{}{-}} \FunctionTok{maximo}\NormalTok{(rtdo1, rtdo2) }\SpecialCharTok{+} \DecValTok{20}
\FunctionTok{cat}\NormalTok{(}\StringTok{"El resultado es"}\NormalTok{, rtdo3)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
El resultado es 59
\end{verbatim}

\hypertarget{null-vs-na-vs-nan}{%
\subsection{\texorpdfstring{\texttt{NULL} vs \texttt{NA} vs \texttt{NaN}}{NULL vs NA vs NaN}}\label{null-vs-na-vs-nan}}

Generalmente los lenguajes de programación poseen un valor conocido como \texttt{NULO}, para representar un objeto vacío, sin información. El mismo suele emplearse como valor devuelto por funciones cuando no corresponde devolver otro tipo de resultado. En pseudocódigo podemos usar esta estrategia escribiendo \texttt{DEVOLVER\ NULO}, si deseamos que nuestra función no devuelva nada. La representación en R de este tipo de objeto es \texttt{NULL}, que se trata de un objeto vacío que generalmente devuelven las funciones cuando el resultado es indefinido. Es decir, podemos crear funciones que terminen con un \texttt{return(NULL)}, como en el siguiente caso donde interesa emitir un mensaje, pero no devolver ningún objeto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, y) \{}
\NormalTok{    resultado }\OtherTok{\textless{}{-}}\NormalTok{ x}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+} \DecValTok{3} \SpecialCharTok{*}\NormalTok{ y}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"El resultado de esta cuenta es:"}\NormalTok{, resultado)}
    \FunctionTok{return}\NormalTok{(}\ConstantTok{NULL}\NormalTok{)}
\NormalTok{\}}
\FunctionTok{g}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
El resultado de esta cuenta es: 31
\end{verbatim}

\begin{verbatim}
NULL
\end{verbatim}

El objeto \texttt{NULL} no debe confundirse con otros dos valores existentes en el lenguaje R: \texttt{NA} y \texttt{NaN}:

\begin{itemize}
\tightlist
\item
  \texttt{NA} son las siglas de \emph{Not Available} y es un valor lógico (como \texttt{TRUE} y \texttt{FALSE}) que generalmente representa datos faltantes.
\item
  \texttt{NaN} son las siglas de \emph{Not a Number} y es un valor numérico que generalmente surge como resultado de operaciones aritméticas imposibles de calcular, como indeterminaciones, raíces negativas, etc. (correr \texttt{0/0}, \texttt{log(-1)} o \texttt{sqrt(-1)} para verlo). Es un valor establecido por IEEE, el estándar con el cual se rige la representación numérica en la computadora.
\end{itemize}

Otro valor numérico muy especial es \texttt{Inf} (y su contrapartida negativa, \texttt{-Inf}), que es el resultado de almacenar un número muy grande o de una división por cero. No es semejante a \texttt{NA}, porque además de no ser de tipo lógico, no representa que hay un dato faltante sino que se trata de un valor numérico.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \ConstantTok{NULL}
\NormalTok{b }\OtherTok{\textless{}{-}} \ConstantTok{NA}
\NormalTok{d }\OtherTok{\textless{}{-}} \ConstantTok{NaN}
\NormalTok{e }\OtherTok{\textless{}{-}} \ConstantTok{Inf}
\NormalTok{f }\OtherTok{\textless{}{-}} \StringTok{"NULL"}

\FunctionTok{class}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "NULL"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "logical"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "numeric"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(e)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "numeric"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "character"
\end{verbatim}

\hypertarget{funciuxf3n-return}{%
\subsection{\texorpdfstring{Función \texttt{return()}}{Función return()}}\label{funciuxf3n-return}}

En R, la función \texttt{return()} puede omitirse, ya que si no está presente se devuelve el resultado de la última expresión analizada. Por eso, las siguientes funciones son equivalentes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g1 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, y) \{}
\NormalTok{    resultado }\OtherTok{\textless{}{-}}\NormalTok{ x}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+} \DecValTok{3} \SpecialCharTok{*}\NormalTok{ y}
    \FunctionTok{return}\NormalTok{(resultado)}
\NormalTok{\}}
\FunctionTok{g1}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 31
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g2 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, y) \{}
\NormalTok{    x}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+} \DecValTok{3} \SpecialCharTok{*}\NormalTok{ y}
\NormalTok{\}}
\FunctionTok{g2}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 31
\end{verbatim}

De todos modos, es aconsejable usar \texttt{return()} para evitar ambigüedades y ganar en claridad. Además, en funciones más complejas, su uso puede ser indispensable para indicar el término de la evaluación de la función.

En el caso particular donde interese que nuestra función emita un mensaje, sin necesariamente devolver un objeto en particular, podemos proceder como se mencionó en la sección anterior:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g3 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, y) \{}
\NormalTok{    resultado }\OtherTok{\textless{}{-}}\NormalTok{ x}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+} \DecValTok{3} \SpecialCharTok{*}\NormalTok{ y}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"El resultado de esta cuenta es:"}\NormalTok{, resultado)}
    \FunctionTok{return}\NormalTok{(}\ConstantTok{NULL}\NormalTok{)}
\NormalTok{\}}
\FunctionTok{g3}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
El resultado de esta cuenta es: 31
\end{verbatim}

\begin{verbatim}
NULL
\end{verbatim}

O de esta otra forma:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g4 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, y) \{}
\NormalTok{    resultado }\OtherTok{\textless{}{-}}\NormalTok{ x}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+} \DecValTok{3} \SpecialCharTok{*}\NormalTok{ y}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"El resultado de esta cuenta es:"}\NormalTok{, resultado)}
\NormalTok{\}}
\FunctionTok{g4}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
El resultado de esta cuenta es: 31
\end{verbatim}

En ambos casos, la función escribe el mensaje y devuelve como resultado un objeto \texttt{NULL}: en \texttt{g3} porque se lo pedimos explícitamente y en \texttt{g4} porque la función \texttt{cat()}, que es lo último en evaluarse, además de escribir un mensaje, devuelve un \texttt{NULL}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{g3}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
El resultado de esta cuenta es: 31
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
NULL
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{g4}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
El resultado de esta cuenta es: 31
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
NULL
\end{verbatim}

\hypertarget{ejemplofact}{%
\section{Documentación de los subalgoritmos}\label{ejemplofact}}

En el contexto de la programación, documentar significa escribir indicaciones para que otras personas puedan entender lo que queremos hacer en nuestro código o para que sepan cómo usar nuestras funciones. Por ejemplo, como vimos antes todas funciones predefinidas de R están documentadas para que podamos buscar ayuda si la necesitamos. Cuando estamos creando nuestras propios subalgoritmos, es importante que también incluyamos comentarios para guiar a otras personas (y a nosotros mismos en el futuro si nos olvidamos) para qué y cómo se usa lo que estamos desarrollando.

Para ilustrar esto, vamos a recordar que en la práctica 2 escribimos un algoritmo para el cálculo de factoriales. Dado que los mismos son muy útiles en variadas aplicaciones, podemos escribir un subalgortimo que se encargue de obtenerlos. Luego, escribiremos un algoritmo para mostrar todos los factoriales de los números 1 a 10.

\begin{verbatim}
---------------------------------------------------------------
SUBALGORITMOS
---------------------------------------------------------------

#-------------------------------------------------------
# Función fact
# Calcula el factorial de números enteros no negativos
# Entrada:
#   - n, entero no negativo
# Salida:
#   - el factorial de n
#-------------------------------------------------------
FUNCIÓN fact(n: numérico): numérico
COMENZAR
    VARIABLE numérica resultado
    resultado <- 1
    SI n > 0 ENTONCES
        PARA i DESDE 1 HASTA n HACER
            resultado <- resultado * i
        FIN PARA
    FIN SI
    DEVOLVER resultado
FIN FUNCIÓN

---------------------------------------------------------------
ALGORITMO PRINCIPAL
---------------------------------------------------------------

ALGORITMO: "Mostrar los factoriales de los 10 primeros naturales"
COMENZAR
    PARA j DESDE 1 HASTA 10 HACER
        ESCRIBIR "El factorial de " j " es igual a " fact(j)
    FIN PARA
FIN
\end{verbatim}

En R:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# DEFINICIÓN DE FUNCIONES}
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}

\CommentTok{\#{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# Función fact}
\CommentTok{\# Calcula el factorial de números enteros no negativos}
\CommentTok{\# Entrada:}
\CommentTok{\#       {-} n, entero no negativo}
\CommentTok{\# Salida:}
\CommentTok{\#       {-} el factorial de n}
\CommentTok{\#{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\NormalTok{fact }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n) \{}
\NormalTok{    resultado }\OtherTok{\textless{}{-}} \DecValTok{1}
    \ControlFlowTok{if}\NormalTok{ (n }\SpecialCharTok{\textgreater{}} \DecValTok{0}\NormalTok{) \{}
        \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{n) \{}
\NormalTok{            resultado }\OtherTok{\textless{}{-}}\NormalTok{ resultado }\SpecialCharTok{*}\NormalTok{ i}
\NormalTok{        \}}
\NormalTok{    \}}
    \FunctionTok{return}\NormalTok{(resultado)}
\NormalTok{\}}

\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# PROGRAMA PRINCIPAL: Mostrar los factoriales de los 10 primeros naturales}
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) \{}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"El factorial de"}\NormalTok{, j, }\StringTok{"es igual a"}\NormalTok{, }\FunctionTok{fact}\NormalTok{(j), }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
El factorial de 1 es igual a 1 
El factorial de 2 es igual a 2 
El factorial de 3 es igual a 6 
El factorial de 4 es igual a 24 
El factorial de 5 es igual a 120 
El factorial de 6 es igual a 720 
El factorial de 7 es igual a 5040 
El factorial de 8 es igual a 40320 
El factorial de 9 es igual a 362880 
El factorial de 10 es igual a 3628800 
\end{verbatim}

\hypertarget{pasaje-de-paruxe1metros}{%
\section{Pasaje de parámetros}\label{pasaje-de-paruxe1metros}}

Los algoritmos y subalgoritmos comunican información entre sí a través de los parámetros o argumentos. Esta comunicación recibe el nombre de \textbf{pasaje de argumentos} y se puede realizar de dos formas: \emph{por valor} o \emph{por referencia}. Algunos lenguajes de programación trabajan con uno u otro sistema, mientras que otros lenguajes permiten el uso de ambos.

\hypertarget{pasaje-por-valor}{%
\subsection{Pasaje por valor}\label{pasaje-por-valor}}

En este caso, los argumentos representan valores que se transmiten \textbf{desde} el algoritmo \textbf{hacia} el subalgoritmo. El \textbf{pasaje por valor} implica que los objetos del algoritmo provistos como argumentos en la llamada al subalgoritmo no serán modificados por la ejecución del mismo. Este sistema funciona de la siguiente forma:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Se evalúan los argumentos actuales usados en la invocación al subalgoritmo.
\item
  Los valores obtenidos se \emph{copian} en los argumentos formales dentro del subalgoritmo.
\item
  Los argumentos formales se usan como variables dentro del subalgoritmo. Aunque los mismos sean modificados (por ejemplo, se les asignen nuevos valores), no se modifican los argumentos actuales en el algoritmo, sólo sus copias dentro del subalgoritmo.
\end{enumerate}

Veamos un ejemplo:

\begin{verbatim}
---------------------------------------------------------------
SUBALGORITMOS
---------------------------------------------------------------

FUNCIÓN fun(x: numérico, y: numérico): numérico
COMENZAR
    x <- x + 1
    y <- y * 2
    DEVOLVER x + y
FIN FUNCIÓN

---------------------------------------------------------------
ALGORITMO PRINCIPAL
---------------------------------------------------------------

ALGORITMO: "Ejemplo de pasaje de argumentos"
COMENZAR
    VARIABLE numérica a, b, d
    a <- 3
    b <- 5
    d <- fun(a, b)
    ESCRIBIR a b d
FIN
\end{verbatim}

Si el pasaje de argumentos se hace por valor, los cambios producidos en el cuerpo de la función sobre los parámetros formales no son transmitidos a los parámetros actuales en el algoritmo principal. Esto significa que los formales son una ``copia'' de los actuales. Los pasos que sigue el algoritmo son:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  En el algoritmo principal, se asignan los valores: \texttt{a\ =\ 3}, \texttt{b\ =\ 5}.
\item
  Al invocar la función, se establece la correspondencia: \texttt{x\ =\ 3,\ y\ =\ 5}.
\item
  Primera línea de la función: \texttt{x\ =\ 3\ +\ 1\ =\ 4}.
\item
  Segunda línea de la función: \texttt{y\ =\ 5\ *\ 2\ =\ 10}.
\item
  La función devuelve el valor \texttt{x\ +\ y\ =\ 4\ +\ 10\ =\ 14}.
\item
  De regreso en el algoritmo principal: \texttt{d} recibe el valor \texttt{14}.
\item
  El algoritmo escribe: \texttt{3\ 5\ 14}.
\end{enumerate}

En R, el pasaje de argumentos es \textbf{por valor}. Por lo tanto, este tipo de comportamiento es lo que vemos cuando implementamos el ejemplo discutido\footnote{\textbf{Nota}: En general, se desalienta la reasignación de valor a los parámetros de la función por resultar confuso. Esto quiere decir que en el ejemplo anterior, para evitar ambigüedades, sería recomendable reemplazar \texttt{x\ \textless{}-\ x\ +\ 1} por algo como \texttt{z\ \textless{}-\ x\ +\ 1} y operar con \texttt{z}, de modo que no se sobreescriba el valor del parámetro \texttt{x}. También sería aconsejable hacer algo similar para la \texttt{y}.}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# DEFINICIÓN DE FUNCIONES}
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}

\NormalTok{fun }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, y) \{}
\NormalTok{    x }\OtherTok{\textless{}{-}}\NormalTok{ x }\SpecialCharTok{+} \DecValTok{1}
\NormalTok{    y }\OtherTok{\textless{}{-}}\NormalTok{ y }\SpecialCharTok{*} \DecValTok{2}
    \FunctionTok{return}\NormalTok{(x }\SpecialCharTok{+}\NormalTok{ y)}
\NormalTok{\}}

\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# PROGRAMA PRINCIPAL}
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}

\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{3}
\NormalTok{b }\OtherTok{\textless{}{-}} \DecValTok{5}
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{fun}\NormalTok{(a, b)}
\FunctionTok{cat}\NormalTok{(a, b, d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3 5 14
\end{verbatim}

\hypertarget{pasaje-por-referencia}{%
\subsection{Pasaje por referencia}\label{pasaje-por-referencia}}

En este caso, los argumentos no sólo representan valores que se transmiten desde el algoritmo hacia el subalgoritmo, sino también desde el subalgoritmo al algoritmo. Esto sirve en las situaciones en las que se quiere que el subalgoritmo pueda modificar las variables del algoritmo principal que se pasaron como argumentos. De esta manera, un subalgoritmo puede producir uno o varios efectos secundarios en el ambiente del algoritmo.

Si un parámetro se pasa por referencia, todos los cambios que experimente dentro del subalgoritmo se producirán también en la variable externa pasada como argumento. Esto se debe a que la información que es pasada desde el algoritmo al subalgoritmo es la dirección en la memoria de la computadora donde se halla almacenado el parámetro actual, es decir, se pasa una referencia a la variable, no el valor que contiene.

Este sistema funciona de la siguiente forma:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Se seleccionan las variables usadas como argumentos actuales.
\item
  Se asocia cada variable con el argumento formal correspondiente.
\item
  Los cambios que experimenten los argumentos formales se reflejan también en los argumentos actuales de origen.
\end{enumerate}

Retomemos el ejemplo anterior:

\begin{verbatim}
---------------------------------------------------------------
SUBALGORITMOS
---------------------------------------------------------------

FUNCIÓN fun(x: numérico, y: numérico): numérico
COMENZAR
    x <- x + 1
    y <- y * 2
    DEVOLVER x + y
FIN FUNCIÓN

---------------------------------------------------------------
ALGORITMO PRINCIPAL
---------------------------------------------------------------

ALGORITMO: "Ejemplo de pasaje de argumentos"
COMENZAR
    VARIABLE numérica a, b, d
    a <- 3
    b <- 5
    d <- fun(a, b)
    ESCRIBIR a b d
FIN
\end{verbatim}

Si el pasaje de argumentos se hace por referencia, los pasos que sigue el algoritmo son:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  En el algoritmo principal, se asignan los valores: \texttt{a\ =\ 3}, \texttt{b\ =\ 5}.
\item
  Al invocar la función, se establece la correspondencia: \texttt{x\ =\ 3,\ y\ =\ 5}.
\item
  Primera línea de la función: \texttt{x\ =\ 3\ +\ 1\ =\ 4}. El parámetro actual asociado con \texttt{x}, \texttt{a}, es en realidad el que sufre dicho cambio y recibe el valor \texttt{4} (\texttt{a\ =\ 4}).
\item
  Segunda línea de la función: \texttt{y\ =\ 5\ *\ 2\ =\ 10}. El parámetro actual asociado con \texttt{y}, \texttt{b}, es en realidad el que sufre dicho cambio y recibe el valor \texttt{10} (\texttt{b\ =\ 10}).
\item
  La función devuelve el valor \texttt{x\ +\ y\ =\ 4\ +\ 10\ =\ 14}.
\item
  De regreso en el algoritmo principal: \texttt{d} recibe el valor \texttt{14}.
\item
  El algoritmo escribe: \texttt{4\ 10\ 14}.
\end{enumerate}

Debe notarse que los resultados difieren dependiendo del tipo de pasaje de argumentos empleado
\footnote{Para diferenciar subalgoritmos con pasaje por referencia, algunos autores sugieren distinguir la declaración de los parámetros formales con algún símbolo, por ejemplo \texttt{\&}.}. R no trabaja con pasaje por referencia (aunque es posible forzar a que haga algo similar, si así se lo desea).

\hypertarget{uxe1mbito-de-las-variables}{%
\section{Ámbito de las variables}\label{uxe1mbito-de-las-variables}}

En todo lenguaje de programación se le dice \textbf{ámbito} o \textbf{scope} a la región del programa donde una variable definida existe y es visible, tal que fuera de dicha región no se puede acceder a la misma
\footnote{No sólo las variables pertenecen a un ámbito, sino todos los objetos que se puedan crear, sean estos variables, constantes o subalgoritmos.}. Según el ámbito en el que existen, las variables pueden considerarse \emph{locales} o \emph{globales}.

\hypertarget{variables-locales}{%
\subsection{Variables locales}\label{variables-locales}}

Las variables declaradas dentro de un subalgoritmo (por ejemplo, dentro de una función) se llaman \textbf{variables locales}. Sólo pueden ser usadas por las instrucciones que están dentro de esa función, mientras que el programa principal u otros subalgoritmos desconocen su existencia y no las pueden usar. Las \emph{variables locales} residen en el \emph{ambiente local} de un subalgortimo y no tienen nada que ver con las variables que puedan ser declaradas con el mismo nombre en otros lugares\footnote{Cuando otro subalgoritmo utiliza el mismo nombre se refiere a una posición diferente en memoria.}. En el siguiente ejemplo, las variables \texttt{a} y \texttt{b} son locales a la función \texttt{f1} y no se pueden usar desde el programa principal, porque dejan de existir una vez que termina la ejecución de \texttt{f1}:

\begin{verbatim}
---------------------------------------------------------------
SUBALGORITMOS
---------------------------------------------------------------

FUNCIÓN f1(x: numérico): numérico
COMENZAR
    VARIABLE numérica a, b
    a <- x - 10
    b <- x + 10
    DEVOLVER a + b
FIN FUNCIÓN

---------------------------------------------------------------
ALGORITMO PRINCIPAL
---------------------------------------------------------------

ALGORITMO: "Ejemplo"
COMENZAR
    VARIABLE numérica z
    z <- f1(50)
    ESCRIBIR z
    ESCRIBIR z + a   ---LÍNEA CON ERROR---
FIN
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# DEFINICIÓN DE FUNCIONES}
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}

\NormalTok{f1 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    a }\OtherTok{\textless{}{-}}\NormalTok{ x }\SpecialCharTok{{-}} \DecValTok{10}
\NormalTok{    b }\OtherTok{\textless{}{-}}\NormalTok{ x }\SpecialCharTok{+} \DecValTok{10}
    \FunctionTok{return}\NormalTok{(a }\SpecialCharTok{+}\NormalTok{ b)}
\NormalTok{\}}

\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# PROGRAMA PRINCIPAL}
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}

\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{f1}\NormalTok{(}\DecValTok{50}\NormalTok{)}
\NormalTok{z}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 100
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\SpecialCharTok{+}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in eval(expr, envir, enclos): object 'a' not found
\end{verbatim}

El error se genera porque el algoritmo principal quiere usar a la variable \texttt{a}, la cual es local a la función \texttt{f1()} y sólo existe dentro de la misma.

El uso de \emph{variables locales} tiene muchas ventajas. Permiten independizar al subalgoritmo del algoritmo principal, ya que las variables definidas localmente en un subalgoritmo no son reconocidas fuera de él. La comunicación entre el subalgoritmo y el algoritmo principal se da exclusivamente a través de la lista de parámetros. Esta característica hace posible dividir grandes proyectos en piezas más pequeñas y que, por ejemplo, diferentes programadores puedan trabajar independientemente en un mismo proyecto.

\hypertarget{variables-globales}{%
\subsection{Variables globales}\label{variables-globales}}

Las variables globales son las que se definen en el algoritmo principal y pueden ser usadas dentro de los subalgoritmos, aún cuando no se las pase como argumento. En el ejemplo anterior \texttt{z} es una variable global\footnote{\texttt{f1} también es global: todo tipo de objeto, incluso las funciones, pertenecen a un determinado ambiente}. Las \emph{variables globales} residen en el \emph{ambiente global} del algoritmo.

El siguiente ejemplo muestra cómo la función \texttt{f2} puede hacer uso de una variable global \texttt{y} que fue definida fuera de ella, en el programa principal
\footnote{Algunos autores sugieren agregar la palabra \emph{GLOBAL} o \emph{LOCAL} en la declaración de las variables para distinguir su ambiente, por ejemplo, poner dentro de \texttt{f2} \texttt{VARIABLE\ LOCAL\ numérica\ a} y en el algoritmo \texttt{VARIABLE\ GLOBAL\ y}, pero no seguiremos esta práctica para ganar en sencillez de escritura. También algunos lenguajes de programación requieren señalar de alguna manera especial a las variables globales.}:

\begin{verbatim}
---------------------------------------------------------------
SUBALGORITMOS
---------------------------------------------------------------

FUNCIÓN f2(x: numérico): numérico
COMENZAR
    VARIABLE numérica a
    a <- x * y
    DEVOLVER a
FIN FUNCIÓN

---------------------------------------------------------------
ALGORITMO PRINCIPAL
---------------------------------------------------------------

ALGORITMO: "Ejemplo"
COMENZAR
    VARIABLE numérica y
    y <- 20
    ESCRIBIR f2(2)
    y <- 18
    ESCRIBIR f2(2)
FIN
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# DEFINICIÓN DE FUNCIONES}
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}

\NormalTok{f2 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    a }\OtherTok{\textless{}{-}}\NormalTok{ x }\SpecialCharTok{*}\NormalTok{ y}
    \FunctionTok{return}\NormalTok{(a)}
\NormalTok{\}}

\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# PROGRAMA PRINCIPAL}
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}

\NormalTok{y }\OtherTok{\textless{}{-}} \DecValTok{20}
\FunctionTok{f2}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 40
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{\textless{}{-}} \DecValTok{18}
\FunctionTok{f2}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 36
\end{verbatim}

La función pudo hacer uso de la variable global \texttt{y} sin haberse comunicado con el programa principal a través de los argumentos. Esta práctica no es recomendable: si bien evaluemos \texttt{f2(2)} dos veces, el resultado no fue el mismo, porque depende de cuánto vale \texttt{y} en el ambiente global en el momento que \texttt{f2} es invocada. Además de ser confuso, esto es una violación al principio de \emph{transparencia referencial}: un subalgoritmo sólo debe utilizar elementos mencionados en la lista de argumentos o definidos localmente, sin emplear variables globales. En particular, si hablamos de una función donde el pasaje de parámetros es por valor, esta práctica garantiza que la misma siempre devuelva el mismo resultado cada vez que sea invocada con los mismos valores en los argumentos de entrada, sin producir ningún efecto secundario en el algoritmo principal. El uso de variables globales permite escribir subalgoritmos que carecen de transparencia referencial.

Un algoritmo puede usar el mismo nombre para variables locales y globales, pero dentro de una función toma precedencia la variable local. En el siguiente ejemplo, hay una variable global \texttt{a} en el programa principal que recibe el valor \texttt{70}. Y hay otra variable \texttt{a} que es local a la función \texttt{f3}. Cuando \texttt{f3} calcula \texttt{a\ +\ b}, lo hace con el valor de su variable local (\texttt{x\ -\ 10}) y no con el valor de la variable global (\texttt{70}):

\begin{verbatim}
---------------------------------------------------------------
SUBALGORITMOS
---------------------------------------------------------------

FUNCIÓN f3(x: numérico): numérico
COMENZAR
    VARIABLE numérica a, b
    a <- x - 10
    b <- x + 10
    ESCRIBIR "Acá, dentro de la f3, el valor de a es", a
    DEVOLVER a + b
FIN FUNCIÓN

---------------------------------------------------------------
ALGORITMO PRINCIPAL
---------------------------------------------------------------

ALGORITMO: "Ejemplo"
COMENZAR
    VARIABLE numérica a, z
    a <- 70
    z <- f3(50)
    ESCRIBIR z
    ESCRIBIR "Acá, en el programa principal, el valor de a es", a
    ESCRIBIR a + z
FIN
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# DEFINICIÓN DE FUNCIONES}
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}

\NormalTok{f3 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    a }\OtherTok{\textless{}{-}}\NormalTok{ x }\SpecialCharTok{{-}} \DecValTok{10}
\NormalTok{    b }\OtherTok{\textless{}{-}}\NormalTok{ x }\SpecialCharTok{+} \DecValTok{10}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"Acá, dentro de la f3, el valor de a es"}\NormalTok{, a)}
    \FunctionTok{return}\NormalTok{(a }\SpecialCharTok{+}\NormalTok{ b)}
\NormalTok{\}}

\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# PROGRAMA PRINCIPAL}
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}

\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{70}
\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{f3}\NormalTok{(}\DecValTok{50}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Acá, dentro de la f3, el valor de a es 40
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 100
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cat}\NormalTok{(}\StringTok{"Acá, en el programa principal, el valor de a es"}\NormalTok{, a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Acá, en el programa principal, el valor de a es 70
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\SpecialCharTok{+}\NormalTok{ z}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 170
\end{verbatim}

Se debe prestar atención que con la sentencia \texttt{ESCRIBIR} o la función \texttt{cat()} en R se muestra en pantalla un mensaje en el momento en el que se ejecuta esa acción. Si el mensaje incluye mostrar valores guardados en objetos, se mostrarán los valores que los mismos tienen en ese momento. Por otro lado, lo devuelto por la sentencia \texttt{DEVOLVER} o la función \texttt{return()} es el resultado de la ejecución de la función: el valor que la función entrega puede ser asignado a otro objeto en el algoritmo principal, como ocurre en la lína de \texttt{z\ \textless{}-\ f3(50)}.

\hypertarget{otras-nociones-importantes-en-r}{%
\section{Otras nociones importantes en R}\label{otras-nociones-importantes-en-r}}

\hypertarget{la-funciuxf3n-source}{%
\subsection{La función source()}\label{la-funciuxf3n-source}}

Cuanto más grande o complejo es el problema a resolver, más funciones deben ser programadas y no es necesario escribirlas a todas en el mismo archivo de código del programa principal. Para ser más ordenados, podemos escribir nuestras funciones en uno o más archivos separados. Si hacemos esto, en el comienzo del script del programa principal debemos incluir una sentencia para que en primer lugar se ejecute el código guardado en esos otros archivos, de modo que las funciones sean definidas y formen parte del ambiente global.

Consideremos otra vez el ejemplo de la función para el cálculo de factoriales. Podemos guardar el código de esta función (y otras si hubiese) en un archivo llamado \texttt{funciones.R}, con el siguiente contenido:

\begin{verbatim}
#-----------------------------------------------------
# Función fact
# Calcula el factorial de números enteros no negativos
# Entrada:
#       - n, entero no negativo
# Salida:
#       - el factorial de n
#-----------------------------------------------------
fact <- function(n) {
    resultado <- 1
    if (n > 0) {
        for (i in 1:n) {
            resultado <- resultado * i
        }
    }
    return(resultado)
}
\end{verbatim}

Luego, en cualquier problema que requiera el cálculo de factoriales, vamos a pedirle a R que ejecute el código guardado en el archivo \texttt{funciones.R} con la sentencia \texttt{source()}, como paso inicial en el archivo donde estemos escribiendo el programa principal. Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# PROGRAMA PRINCIPAL: Mostrar los factoriales de los 10 primeros naturales}
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}

\FunctionTok{source}\NormalTok{(}\StringTok{"C:/Documentos/Facultad/IALP/funciones.R"}\NormalTok{)}

\ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) \{}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"El factorial de"}\NormalTok{, j, }\StringTok{"es igual a"}\NormalTok{, }\FunctionTok{fact}\NormalTok{(j), }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Gracias a \texttt{source()} todas las funciones definidas en el archivo \texttt{funciones.R} aparecerán en el entorno y no hay necesidad ni siquiera de abrirlo. Notar que \texttt{C:/Documentos/Facultad/IALP/} es la dirección o \emph{path} de la carpeta en la computadora donde está guardado el archivo \texttt{funciones.R}.

\hypertarget{argumentos-con-valores-asignados-por-defecto}{%
\subsection{Argumentos con valores asignados por defecto}\label{argumentos-con-valores-asignados-por-defecto}}

Hemos visto que algunos argumentos de las funciones predefinidas de R tienen valores asignados por defecto, como es el caso de la función \texttt{log()}, que a menos que indiquemos otra cosa opera con la base natural. Cuando definimos nuestras propias funciones, también es posible asignarle un valor por defecto a uno o más de sus argumentos.
Tomemos el primer ejemplo de este capítulo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, y) \{}
\NormalTok{    resultado }\OtherTok{\textless{}{-}}\NormalTok{ x}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+} \DecValTok{3} \SpecialCharTok{*}\NormalTok{ y}
    \FunctionTok{return}\NormalTok{(resultado)}
\NormalTok{\}}
\FunctionTok{f}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 31
\end{verbatim}

Esta función también podría ser definida así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nueva\_f }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, }\AttributeTok{y =} \DecValTok{100}\NormalTok{) \{}
\NormalTok{    resultado }\OtherTok{\textless{}{-}}\NormalTok{ x}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+} \DecValTok{3} \SpecialCharTok{*}\NormalTok{ y}
    \FunctionTok{return}\NormalTok{(resultado)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Esto significa que si no proveemos un valor para el argumento \texttt{y}, a este se le asignará por default el valor 100. Luego:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nueva\_f}\NormalTok{(}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 316
\end{verbatim}

En el caso anterior, se hace corresponder el 4 al primer argumento de la función, \texttt{x}, y como no hay ningún otro parámetro actual que le estemos pasando a la función, la misma le asigna a \texttt{y} el valor 100 y calcula: \texttt{x\^{}2\ +\ 3\ *\ y\ =\ 16\ +\ 300\ =\ 316}. Sin embargo, podemos, como antes, proveer cualquier otro valor para \texttt{y}, de modo que no se use el valor por default:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nueva\_f}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 31
\end{verbatim}

Como \texttt{x} no tiene valor asignado por default en la función \texttt{nueva\_f()}, siempre debemos pasarle un valor. En caso contrario, recibiremos un error:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nueva\_f}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in nueva_f(): argument "x" is missing, with no default
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nueva\_f}\NormalTok{(}\AttributeTok{y =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in nueva_f(y = 5): argument "x" is missing, with no default
\end{verbatim}

\hypertarget{otros-tuxf3picos-de-lectura-opcional}{%
\section{Otros tópicos de lectura opcional}\label{otros-tuxf3picos-de-lectura-opcional}}

\hypertarget{modificar-una-variable-global-desde-el-cuerpo-de-una-funciuxf3n-en-r}{%
\subsection{Modificar una variable global desde el cuerpo de una función en R}\label{modificar-una-variable-global-desde-el-cuerpo-de-una-funciuxf3n-en-r}}

Hemos dicho que una función recibe información desde el programa principal a través de sus parámetros, y envía información al mismo mediante el valor que devuelve. Sin embargo, es posible alterar el comportamiento para que sea capaz de producir efectos secundarios, por ejemplo, modificando el valor de una variable global, violando así el principio de transparencia referencial.

Los siguientes ejemplos definen dos funciones con un único argumento, \texttt{x}, pero que en su cuerpo hacen uso de una variable global, \texttt{y}, definida el algoritmo principal (estos casos violan el principio de transparencia referencial, su práctica no es recomendable). La diferencia entre ellas es que \texttt{g1()} modifica el valor de \texttt{y} dentro de la función, pero el valor de \texttt{y} en el ambiente global no es alterado; mientras que \texttt{g2()} cambia el valor de \texttt{y} no sólo localmente, sino también en el ambiente global. Esto se logra mediante el uso del operador \texttt{\textless{}\textless{}-}\footnote{En realidad, el operador \texttt{\textless{}\textless{}-} trabaja de forma más compleja que lo mencionado en esta guía. En programas más elaborados de R, pueden haber ambientes anidados y este operador iniciará una búsqueda desde el ambiente actual hacia los superiores hasta encontrar una variable que se llame \texttt{y} para asignarle un valor. En este caso sencillo, sólo hay dos ambientes, el de la función \texttt{g2} y el global. Por lo tanto el operador \texttt{\textless{}\textless{}-} hace que se le asigne un valor a la variable \texttt{y} en el global.}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# DEFINICIÓN DE FUNCIONES}
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}

\NormalTok{g1 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    y }\OtherTok{\textless{}{-}}\NormalTok{ y }\SpecialCharTok{+} \DecValTok{100}
    \FunctionTok{return}\NormalTok{(x }\SpecialCharTok{/}\NormalTok{ y)}
\NormalTok{\}}

\NormalTok{g2 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    y }\OtherTok{\textless{}\textless{}{-}}\NormalTok{ y }\SpecialCharTok{+} \DecValTok{100}
    \FunctionTok{return}\NormalTok{(x }\SpecialCharTok{/}\NormalTok{ y)}
\NormalTok{\}}

\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# PROGRAMA PRINCIPAL}
\CommentTok{\# {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}

\CommentTok{\# Caso 1: el valor de y en el ambiente global no es modificado por g1}
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{500}
\NormalTok{y }\OtherTok{\textless{}{-}} \DecValTok{50}
\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{g1}\NormalTok{(x)}
\FunctionTok{cat}\NormalTok{(x, y, z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
500 50 3.333333
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Caso 2: el valor de y en el ambiente global es modificado por g2}
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{500}
\NormalTok{y }\OtherTok{\textless{}{-}} \DecValTok{50}
\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{g2}\NormalTok{(x)}
\FunctionTok{cat}\NormalTok{(x, y, z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
500 150 3.333333
\end{verbatim}

Nuevamente, esta forma de trabajo no es aconsejable porque estamos produciendo \emph{efectos secundarios} desde la función en el ambiente global que pueden pasar desapercibidos si no estamos muy atentos. Así como la mejor práctica es pasar toda la información desde el programa principal hacia la función a través de sus parámetros, también es recomendable que toda comunicación desde la función hacia el programa principal se realice a través del valor (u objeto) que la función devuelve, sin producir efectos secundarios (transparencia referencial).

\hypertarget{procedimientos}{%
\subsection{Procedimientos}\label{procedimientos}}

Un \textbf{procedimiento} es un subalgoritmo que agrupa una acción o conjunto de acciones, dándoles un nombre por el que se las puede identificar posteriormente. Se diferencia de la función en que no tiene como objetivo, en general, devolver un valor, sino sólo contribuir a la descomposición o modularidad del programa. R no trabaja con el concepto de \emph{procedimiento}, sino que todo tipo de subalgoritmo se genera con la misma estructura de \texttt{function(...)\{...\}}\footnote{En la jerga de R, se habla de \emph{funciones puras} o \emph{no puras}. Las primeras no producen ningún efecto secundario en el ambiente global, las segundas sí. Hay muy pocas funciones no puras en R}.

Como en las funciones, desde el algoritmo principal se pasan valores al procedimiento utilizando \textbf{parámetros} o \textbf{argumentos}, aunque también puede haber procedimientos que carezcan de los mismos. Para usar un procedimiento hay que invocarlo, escribiendo su nombre y a continuación, si los hay, los valores de los argumentos actuales para esa llamada, separados por comas. Aquí también los argumentos actuales deben ser compatibles en cuanto a la cantidad, tipo y orden que los argumentos formales declarados en la definición del procedimiento.

En el siguiente ejemplo podemos identificar los argumentos actuales \texttt{a} (con el valor 5), \texttt{b} (con el valor 2), \texttt{c} y \texttt{d} (sin valores asignados inicialmente). Cuando el procedimiento \texttt{proced1} es invocado, se establece una correspondencia con los argumentos formales \texttt{n1}, \texttt{n2}, \texttt{n3} y \texttt{n4}, respectivamente. \texttt{n1} toma el valor 5, \texttt{n2} toma el valor 2 y el procedimiento le asigna los valores 7 a \texttt{n3} y 1 a \texttt{n4}. Al finalizar, este procedimiento habrá dejado sin cambios a las variables \texttt{a} y \texttt{b}, mientras que le habrá asignado los valores 7 a \texttt{c} y 1 a \texttt{d}. Como resultado, el algoritmo escribe ``5 2 7 1''.

\begin{verbatim}
---------------------------------------------------------------
SUBALGORITMOS
---------------------------------------------------------------

PROCEDIMIENTO proced1(n1: numérico, n2: numérico, n3: numérico, n4: numérico)
    n3 <- n1 + n2
    n4 <- n2 - 1
FIN PROCEDIMIENTO

---------------------------------------------------------------
ALGORITMO PRINCIPAL
---------------------------------------------------------------

ALGORITMO: Primer ejemplo de procedimiento
COMENZAR
    VARIABLE numérica a, b, c, d
    a <- 5
    b <- 2
    proced1(a, b, c, d)
    ESCRIBIR a b c d
FIN
\end{verbatim}

En el siguiente ejemplo, el procedimiento \texttt{proced2} modifica las variables que actúan como argumentos actuales. Al ser invocado, se establece una correspondencia entre los argumentos actuales \texttt{a} (con el valor 5) y \texttt{b} (con el valor 2), y los argumentos formales \texttt{n1} y \texttt{n2}, respectivamente. De esta forma, la primera acción del procedimiento le asigna el valor 7 a \texttt{n1} y 1 a \texttt{n2}. De esta manera, al finalizar \texttt{a} vale 7 y \texttt{b} vale 1 y el algoritmo escribe ``7 1''.

\begin{verbatim}
---------------------------------------------------------------
SUBALGORITMOS
---------------------------------------------------------------

PROCEDIMIENTO proced2(n1: numérico, n2: numérico)
    n1 <- n1 + n2
    n2 <- n2 - 1
FIN PROCEDIMIENTO

---------------------------------------------------------------
ALGORITMO PRINCIPAL
---------------------------------------------------------------

ALGORITMO: Segundo ejemplo de procedimiento
COMENZAR
    VARIABLE numérica a, b
    a <- 5
    b <- 2
    proced2(a, b)
    ESCRIBIR a b
FIN
\end{verbatim}

Analicemos ahora el tipo de pasaje de argumentos en el contexto de un procedimiento:

\begin{verbatim}
---------------------------------------------------------------
SUBALGORITMOS
---------------------------------------------------------------

PROCEDIMIENTO miProc(x: numérico, y: numérico)
    x <- x * 2
    y <- x - y
FIN PROCEDIMIENTO

---------------------------------------------------------------
ALGORITMO PRINCIPAL
---------------------------------------------------------------

ALGORITMO: Tercer ejemplo de procedimiento
COMENZAR
    VARIABLE numérica a, b
    a <- 8
    b <- 4
    miProc(a, b)
    ESCRIBIR a b
FIN
\end{verbatim}

Si el pasaje es por referencia, los pasos que sigue el algoritmo serían:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  En el algortimo se asignan los valores: \texttt{a\ =\ 8,\ b\ =\ 4}.
\item
  Al invocar la función: \texttt{x\ =\ 8,\ y\ =\ 4}.
\item
  Primera línea de la función: \texttt{x\ =\ 8\ *\ 2\ =\ 16}. Lo mismo sucede con el parámetro actual \texttt{a}: \texttt{a\ =\ 16}.
\item
  Segunda línea de la función: \texttt{y\ =\ 16\ -\ 4\ =\ 12}. Lo mismo sucede con el parámetro actual \texttt{b}: \texttt{b\ =\ 12}.
\item
  Al regresar al algoritmo principal, la sentencia \texttt{ESCRIBIR} produce: \texttt{16\ 12}.
\end{enumerate}

Si el pasaje hubiese sido por valor, \texttt{a} y \texttt{b} no hubiesen cambiado y la sentencia \texttt{ESCRIBIR} mostraría \texttt{8,\ 4}. Como en un procedimiento los resultados regresan en los mismos parámetros, no pueden ser todos pasados por valor, porque en ese caso el procedimiento nunca realizaría ninguna acción.

Si el parámetro \texttt{x} se pasa por valor mientras que \texttt{y} se pasa por referencia, los pasos serían:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{a\ =\ 8,\ b\ =\ 4}.
\item
  Al invocar la función: \texttt{x\ =\ 8,\ y\ =\ 4}.
\item
  Primera línea de la función: \texttt{x\ =\ 8\ *\ 2\ =\ 16}.
\item
  Segunda línea de la función: \texttt{y\ =\ 16\ -\ 4\ =\ 12}. Lo mismo sucede con el parámetro actual \texttt{b}: \texttt{b\ =\ 12}.
\item
  Al regresar al algoritmo principal, la sentencia \texttt{ESCRIBIR} produce: \texttt{8\ 12}.
\end{enumerate}

Dado que en R el pasaje de argumentos es \textbf{siempre} por valor y no por referencia, no existen los procedimientos. Por esta razón, esta sección no se ejemplifica con código de R.

\hypertarget{estructuras-de-datos}{%
\chapter{Estructuras de datos}\label{estructuras-de-datos}}

Hasta ahora todos los algoritmos que hemos desarrollado hacen uso de objetos que guardan datos individuales, los cuales representan un número, una cadena de texto o un valor lógico. Sin embargo, la verdadera utilidad de la computación radica en poder trabajar con conjuntos de datos, organizados de acuerdo a ciertas reglas que permitan su manipulación y acceso. Definimos entonces como \textbf{estructura de datos} a un conjunto de datos que cuentan con un sistema de organización.

\hypertarget{arreglos}{%
\section{Arreglos}\label{arreglos}}

Un \textbf{arreglo} se define como una colección de valores individuales con dos características fundamentales:

\begin{itemize}
\tightlist
\item
  \emph{Ordenamiento}: los valores individuales pueden ser enumerados en orden, es decir, debe ser posible identificar en qué posición del arreglo se encuentra cada valor.
\item
  \emph{Homogeneidad}: los valores individuales almacenados en un arreglo son todos del mismo tipo (numérico, carácter, lógico).
\end{itemize}

Los arreglos son muy útiles para almacenar información en la memoria de la computadora, organizando valores que estén relacionados entre sí de alguna manera, por ejemplo, una conjunto de precios, los meses del año, el listado de calificaciones de estudiantes en distintos parciales, etc.

Los componentes individuales del conjunto se llaman \textbf{elementos}. Para indicar qué posición ocupa cada elemento en el arreglo se emplean uno o más \textbf{índices}. Dependiendo de cuántos índices se deban utilizar para acceder a cada elemento dentro de los arreglos, estos se clasifican en \textbf{unidmensionales} (\emph{vectores}) o \textbf{bidimensionales} (\emph{matrices}). También existen los arreglos \textbf{multidimensionales} y están presentados al final de este capítulo, pero como no trabajaremos la lectura de esa sección es opcional.

\hypertarget{arreglos-unidimensionales-o-vectores}{%
\subsection{Arreglos unidimensionales o vectores}\label{arreglos-unidimensionales-o-vectores}}

Un \textbf{arreglo unidimensional} o \textbf{vector} tiene \emph{n} elementos todos del mismo tipo. Por ejemplo, el siguiente es un vector de tipo numérico llamado \texttt{x} con 5 elementos:

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/05_estructuras/estr01} 

}

\caption{Ejemplo de un vector numérico}\label{fig:unnamed-chunk-106}
\end{figure}

Cada uno de los elementos ocupa una posición determinada en el vector. Por ejemplo, el elemento 3 del vector \texttt{x} es el numéro 2.71. Se puede \emph{acceder} o hacer referencia a cada elemento mediante el uso de \emph{índices}, expresados entre corchetes al lado del nombre del vector. De esta forma, si escribimos \texttt{x{[}3{]}} hacemos referencia a la tercera posición del vector, que actualmente guarda al valor 2.71. Como podemos ver, sólo hace falta un índice para hacer referencia a cada elemento de un vector.

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/05_estructuras/estr02} 

}

\caption{Ejemplo de un vector numérico: índices para señalar cada posición.}\label{fig:unnamed-chunk-107}
\end{figure}

Los siguientes son ejemplos de vectores de tipo carácter y lógico, con distintas cantidades de elementos:

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/05_estructuras/estr03} 

}

\caption{Ejemplo de un vector carácter y un vector lógico}\label{fig:unnamed-chunk-108}
\end{figure}

Al igual que todas las variables que empleamos en nuestros algoritmos, los vectores que serán utilizados deben ser declarados en el pseudocódigo, eligiendo un \emph{identificador} (nombre) e indicando su tipo y su tamaño, es decir, la cantidad de posiciones que contienen. Esto último se señala entre paréntesis al lado del nombre elegido. Por ejemplo, el vector \texttt{x} visto anteriomente puede ser creado de la siguiente forma:

\begin{verbatim}
VARIABLE numérica x(5)
x[1] <- -4.5
x[2] <- 12
x[3] <- 2.71
x[4] <- -6
x[5] <- 25
\end{verbatim}

Si bien la declaración de un vector sólo tiene como objetivo permitirle a la computadora que reserve internamente el espacio necesario en memoria para el mismo, para escribir pseudocódigo de una manera sencilla estableceremos la siguiente \textbf{convención}. Cuando declaramos un vector de tipo numérico con la expresión \texttt{VARIABLE\ numérica\ x(5)} asumiremos que, además de reservar espacio en memoria para el vector, se le asigna un 0 (cero) en cada posición. Es decir, el vector \texttt{x} es iniciado con ceros, que más tarde pueden ser reemplazados por otros valores. Del mismo modo, asumiremos que cuando declaramos vectores de tipo carácter, todos sus elementos son iniciados con valores \texttt{""} (una cadena de texto vacía) y cuando declaramos vectores de tipo lógico, con el valor \texttt{FALSO}.

En R, los vectores se construyen de forma dinámica por lo cual no es necesario declararlos antes de comenzar a utilizarlos. La función \texttt{c()} (de \emph{combinar}) permite crear vectores, por ejemplo, los mencionados anteriormente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\FloatTok{4.5}\NormalTok{, }\DecValTok{12}\NormalTok{, }\FloatTok{2.71}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{6}\NormalTok{, }\DecValTok{25}\NormalTok{)}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"ARG"}\NormalTok{, }\StringTok{"correo@gmail.com"}\NormalTok{, }\StringTok{"Ok"}\NormalTok{, }\StringTok{"chau"}\NormalTok{)}
\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/05_estructuras/estr04} 

}

\caption{Creación de vectores en R}\label{fig:unnamed-chunk-110}
\end{figure}

Cuando ejecutamos dichas líneas, se crean en el ambiente global los objetos \texttt{x}, \texttt{y} y \texttt{z}, como podemos notar en la pestaña \texttt{Environment} de RStudio. Es decir, los vectores, así como cualquier otro tipo de arreglo, son \textbf{objetos} que constituyen entidades en sí mismas y que pueden ser manipulados al hacer referencia a sus indicadores. Además, RStudio nos muestra en la pestaña mencionada qué tipo de vector es cada uno (\texttt{num}, \texttt{chr}, \texttt{logi}), cuántos elementos tiene (\texttt{{[}1:5{]}}, \texttt{{[}1:4{]}}, \texttt{{[}1:3{]}}) y una previsualización de sus primeros elementos.

Dado que la función \texttt{c()} resulta, en consecuencia, muy importante al programar en R, es recomendable que evitemos usar la letra \texttt{c} como nombre para otros objetos\footnote{Aunque a veces me olvido de esta recomendación y por eso en algunos ejemplos de la asignatura hay variables llamadas \texttt{c}}.

Podemos emplear estructuras iterativas para recorrer todas las posiciones de un vector y realizar operaciones con ellas, por ejemplo:

\begin{verbatim}
PARA i DESDE 1 HASTA 5 HACER
    ESCRIBIR "La posición " i "de x está ocupada por el valor " x[i]
FIN PARA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{) \{}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"La posición"}\NormalTok{, i, }\StringTok{"de x está ocupada por el valor"}\NormalTok{, x[i], }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
La posición 1 de x está ocupada por el valor -4.5 
La posición 2 de x está ocupada por el valor 12 
La posición 3 de x está ocupada por el valor 2.71 
La posición 4 de x está ocupada por el valor -6 
La posición 5 de x está ocupada por el valor 25 
\end{verbatim}

Todos los lenguajes de programación incluyen, además, alguna función para determinar cuántos elementos tiene un vector que ya fue creado. Para esto emplearemos la expresión \texttt{LARGO()} en el pseudocódigo y la función \texttt{length} de R:

\begin{verbatim}
ESCRIBIR "El vector x tiene " LARGO(x) " elementos."
ESCRIBIR "El vector y tiene " LARGO(y) " elementos."
ESCRIBIR "El vector z tiene " LARGO(z) " elementos."
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cat}\NormalTok{(}\StringTok{"El vector x tiene"}\NormalTok{, }\FunctionTok{length}\NormalTok{(x), }\StringTok{"elementos."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
El vector x tiene 5 elementos.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cat}\NormalTok{(}\StringTok{"El vector y tiene"}\NormalTok{, }\FunctionTok{length}\NormalTok{(y), }\StringTok{"elementos."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
El vector y tiene 4 elementos.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cat}\NormalTok{(}\StringTok{"El vector z tiene"}\NormalTok{, }\FunctionTok{length}\NormalTok{(z), }\StringTok{"elementos."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
El vector z tiene 3 elementos.
\end{verbatim}

Entonces, para recorrer todos los elementos del vector podemos hacer también:

\begin{verbatim}
PARA i DESDE 1 HASTA LARGO(x) HACER
    ESCRIBIR "La posición " i "de x está ocupada por el valor " x[i]
FIN PARA
\end{verbatim}

O bien:

\begin{verbatim}
tam <- LARGO(x)
PARA i DESDE 1 HASTA tam HACER
    ESCRIBIR "La posición " i "de x está ocupada por el valor " x[i]
FIN PARA
\end{verbatim}

Antes comentamos que en R los vectores se crean con expresiones como \texttt{x\ \textless{}-\ c(-4.5,\ 12,\ 2.71,\ -6,\ 25)}, donde sus elementos están listados de forma literal. También podemos crear vectores de un largo determinado dejando que cada posición quede ocupada por algún valor asignado por defecto. Por ejemplo, el siguiente código crea un vector tipo numérico con 10 posiciones, uno carácter con 7 y otro lógico con 2. En cada caso, R rellena todas las posiciones con el mismo valor: ceros en el vector numérico, caracteres vacíos \texttt{""} en el vector de tipo carácter y valores \texttt{FALSE} en el vector lógico:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\NormalTok{b }\OtherTok{\textless{}{-}} \FunctionTok{character}\NormalTok{(}\DecValTok{7}\NormalTok{)}
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{logical}\NormalTok{(}\DecValTok{2}\NormalTok{)}

\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] 0 0 0 0 0 0 0 0 0 0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "" "" "" "" "" "" ""
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE FALSE
\end{verbatim}

Se pueden asignar valores a una, varias o todas las posiciones de un vector en cualquier parte del algoritmo. Además, en pseudocódigo emplearemos la palabra clave \texttt{MOSTRAR} cuando deseamos que se escriba en pantalla todo el contenido de un vector. Por ejemplo:

\begin{verbatim}
VARIABLE numérica a(10)
...algunas acciones...
PARA i DESDE 1 HASTA LARGO(a) HACER
    SI i MOD 3 == 0 ENTONCES  
        a[i] <- i * 100
    FIN SI
FIN PARA
MOSTRAR a
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{length}\NormalTok{(a)) \{}
    \ControlFlowTok{if}\NormalTok{ (i }\SpecialCharTok{\%\%} \DecValTok{3} \SpecialCharTok{==} \DecValTok{0}\NormalTok{) \{}
\NormalTok{        a[i] }\OtherTok{\textless{}{-}}\NormalTok{ i }\SpecialCharTok{*} \DecValTok{100}
\NormalTok{    \}}
\NormalTok{\}}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]   0   0 300   0   0 600   0   0 900   0
\end{verbatim}

En los ejemplos anteriores, declaramos los vectores explicitando su tamaño con un número: \texttt{VARIABLE\ numérica\ x(5)} o \texttt{VARIABLE\ numérica\ a(10)}. Sin embargo, el tamaño del vector podría estar guardado en otra variable, cuyo valor se determina en cada ejecución del programa mediante información externa o como resultado de algún cálculo anterior. En el siguiente ejemplo se deja que el usuario determine la dimensión del vector y que provea cada uno de los valores para el mismo. Antes de poder declarar la existencia del nuevo vector llamado \texttt{mi\_vector}, se ``lee'' su tamaño:

\begin{verbatim}
VARIABLE numérica tam
LEER tam
VARIABLE numérica mi_vector(tam)
PARA i DESDE 1 HASTA tam HACER
    LEER mi_vector[i]
FIN PARA
\end{verbatim}

Por ahora, toda instrucción de \emph{leer} en el pseudocódigo será traducida en R mediante la asignación directa de valores. Por ejemplo, \texttt{LEER\ tam} se reemplaza por \texttt{tam\ \textless{}-\ 5} (o el número que necesitemos).

Antes de terminar esta sección haremos una última observación. En R todos los objetos que hemos considerado como ``variable'' y que guardan un único valor (como \texttt{tam} en el ejemplo anterior), son también considerados como vectores, cuyo largo es 1, como podemos verificar en el siguiente ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{25}
\FunctionTok{length}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.vector}\NormalTok{(x) }\CommentTok{\# Esta función lógica le pregunta a R si el objeto x es un vector}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\textbf{Ejemplo: invertir los elementos de un vector}

Nos planteamos el problema de dar vuelta los elementos pertenecientes a un vector, de manera que el primer elemento pase a ser el último, el segundo pase al penúltimo lugar, etcétera. Por ejemplo, dado el vector de tipo carácter \texttt{v}:

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/05_estructuras/estr11} 

}

\caption{Vector v original}\label{fig:inv1}
\end{figure}

queremos modificarlo para obtener:

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/05_estructuras/estr12} 

}

\caption{Vector v reordenado}\label{fig:inv2}
\end{figure}

Si bien podemos pensar en distintas formas para resolver este problema, probablemente la más sencilla requiere que intercambiemos de a dos los valores en ciertas posiciones del vector, por ejemplo, empezando por intercambiar el primero con el último. Para esto podemos emplear una variable auxiliar que guarde el valor de alguna de las celdas temporariamente (por eso lo vamos a llamar \texttt{tmp}):

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/05_estructuras/estr13} 

}

\caption{Pasos para intercambiar valores}\label{fig:inv3}
\end{figure}

Ahora sólo resta realizar el mismo procedimiento para los valores de las posiciones 2 y 4. Como el número de elementos en el vector es impar, el valor en la posición central queda en su lugar. Podemos definir el siguiente algoritmo para resolver este problema de manera general. En el siguiente pseudocódigo, primero declaramos una variable numérica \texttt{n} que puede tomar cualquier valor y que servirá para declarar cuántos espacios necesita el vector. Luego, se itera para leer cada elemento del vector. Finalmente, se implementa la estrategia de reordenamiento:

\begin{verbatim}
ALGORITMO: "Invertir (dar vuelta) los elementos de un vector"
COMENZAR
    
  # Declarar variables
  VARIABLE numérica n
  VARIABLE carácter tmp
  LEER n
  VARIABLE carácter v(n)
  
  # Asignar valores al vector
  PARA i DESDE 1 HASTA n HACER
      LEER v[i]
  FIN PARA
  
  # Reordenar
  PARA i DESDE 1 HASTA n DIV 2 HACER
      tmp <- v[i]                 # Paso 1
      v[i] <- v[n - i + 1]        # Paso 2
      v[n - i + 1] <- tmp         # Paso 3
  FIN PARA
  
  # Mostrar el vector reodenado
  MOSTRAR v
    
FIN
\end{verbatim}

En el ejemplo anterior hemos incorporado el uso de comentarios en el pseudocódigo para describir el objetivo de cada parte. Imitando lo que hacemos en R, señalamos la presencia de comentarios con el carácter \texttt{\#} (podríamos usar otra cosa, pero adheriremos a esta convención). Se usó el operador \texttt{DIV} para obtener la división entera entre \texttt{n} y \texttt{2} (por ejemplo, \texttt{5\ DIV\ 2\ =\ 2}). En R reemplazamos todas las instrucciones \texttt{LEER} por una asignación directa de valores y empleamos el operador de división entera \texttt{\%/\%}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Estadística"}\NormalTok{, }\StringTok{"en"}\NormalTok{, }\StringTok{"Licenciatura"}\NormalTok{, }\StringTok{"la"}\NormalTok{, }\StringTok{"Aguante"}\NormalTok{)}
\NormalTok{n }\OtherTok{\textless{}{-}} \FunctionTok{length}\NormalTok{(v)}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{(n}\SpecialCharTok{\%/\%}\DecValTok{2}\NormalTok{)) \{}
\NormalTok{    tmp }\OtherTok{\textless{}{-}}\NormalTok{ v[i]}
\NormalTok{    v[i] }\OtherTok{\textless{}{-}}\NormalTok{ v[n }\SpecialCharTok{{-}}\NormalTok{ i }\SpecialCharTok{+} \DecValTok{1}\NormalTok{]}
\NormalTok{    v[n }\SpecialCharTok{{-}}\NormalTok{ i }\SpecialCharTok{+} \DecValTok{1}\NormalTok{] }\OtherTok{\textless{}{-}}\NormalTok{ tmp}
\NormalTok{\}}
\NormalTok{v}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "Aguante"      "la"           "Licenciatura" "en"           "Estadística" 
\end{verbatim}

\hypertarget{arreglos-bidimensionales-o-matrices}{%
\subsection{Arreglos bidimensionales o matrices}\label{arreglos-bidimensionales-o-matrices}}

Un \textbf{arreglo bidimensional} representa lo que habitualmente conocemos en matemática como \textbf{matriz} y por eso también lo llamamos de esa forma. Podemos \emph{imaginar} que en una matriz los elementos están organizados en \emph{filas} y \emph{columnas} formando una tabla. Por ejemplo, la siguiente es una matriz llamada \texttt{x}:

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/05_estructuras/estr05} 

}

\caption{Ejemplo de una matriz numérica}\label{fig:unnamed-chunk-117}
\end{figure}

A diferencia de los vectores, las matrices requieren dos índices para señalar la posición de cada elemento, el primero para indicar la fila y el segundo para indicar la columna. Los mismos se colocan entre corchetes, separados por una coma, al lado del identificador de la matriz. De esta forma, si hablamos de \texttt{x{[}1,\ 3{]}} hacemos referencia a la posición ocupada por el valor 18, mientras que si mencionamos \texttt{x{[}3,\ 1{]}} nos referimos al valor 14.

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/05_estructuras/estr06} 

}

\caption{Ejemplo de una matriz numérica: índices para señalar cada posición}\label{fig:unnamed-chunk-118}
\end{figure}

Al \emph{tamaño} de una matriz, es decir, cuántas filas y columnas tiene, se le dice \textbf{dimensión}. La matriz anterior es de dimension \(3 \times 4\).

Como hicimos con los vectores, debemos declarar las matrices que vamos a usar en el pseudocódigo, indicando su identificador, tipo y dimensión: \texttt{VARIABLE\ numérica\ x(3,\ 4)}. También vamos a asumir que todas las posiciones de una matriz son iniciadas con el valor 0, \texttt{""} o \texttt{FALSO} si la misma es numérica, carácter o lógica, respectivamente. La matriz \texttt{x} puede ser generada en pseudocódigo de esta forma:

\begin{verbatim}
VARIABLE numérica x(3, 4)
x[1, 1] <- 8
x[1, 2] <- 13
x[1, 3] <- 18
x[1, 4] <- 23
x[2, 1] <- 11
x[2, 2] <- 16
x[2, 3] <- 21
x[2, 4] <- 26
x[3, 1] <- 14
x[3, 2] <- 19
x[3, 3] <- 24
x[3, 4] <- 29
\end{verbatim}

En R, no es necesario declarar las matrices con anterioridad y las mismas pueden ser creadas de manera literal con la función \texttt{matrix()}. Su primer argumento, \texttt{data}, es un vector con todos los elementos que queremos guardar en la matriz. Luego, se indica la cantidad de filas para la misma con \texttt{nrow} y la cantidad de columnas con \texttt{ncol}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\AttributeTok{data =} \FunctionTok{c}\NormalTok{(}\DecValTok{8}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{16}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{26}\NormalTok{, }\DecValTok{29}\NormalTok{),}
            \AttributeTok{nrow =} \DecValTok{3}\NormalTok{, }\AttributeTok{ncol =} \DecValTok{4}\NormalTok{)}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3] [,4]
[1,]    8   13   18   23
[2,]   11   16   21   26
[3,]   14   19   24   29
\end{verbatim}

Notar que R ubicó a los valores provistos llenando primero la columna 1, luego la 2, etc. Ese comportamiento puede ser modificado con el argumento \texttt{byrow}, que por default es \texttt{FALSE}. Si lo cambiamos a \texttt{TRUE} los elementos son ubicados por fila. Además, podemos usar saltos de líneas (\emph{enter}) para visualizar las diferentes filas de la matriz. Esto no tiene ningún impacto en R, sólo sirve para que el código sea más fácil de leer. Dado que hemos provisto 12 valores e indicamos que queremos 3 filas, el argumento \texttt{ncol} no es necesario (es obvio que quedarán 4 columnas). Por eso, las siguientes sentencias son equivalentes a la anterior:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{( }\DecValTok{8}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{23}\NormalTok{, }
              \DecValTok{11}\NormalTok{, }\DecValTok{16}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{26}\NormalTok{, }
              \DecValTok{14}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{29}\NormalTok{), }
            \AttributeTok{nrow =} \DecValTok{3}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{)}

\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{( }\DecValTok{8}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{23}\NormalTok{, }
              \DecValTok{11}\NormalTok{, }\DecValTok{16}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{26}\NormalTok{, }
              \DecValTok{14}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{29}\NormalTok{), }
            \AttributeTok{ncol =} \DecValTok{4}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Si colocamos un único valor como primer argumento en la función \texttt{matrix()}, el mismo se repetirá en todas las posiciones. En este caso sí o sí tenemos que indicar cuántas filas y columnas deseamos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{0}\NormalTok{, }\AttributeTok{nrow =} \DecValTok{2}\NormalTok{, }\AttributeTok{ncol =} \DecValTok{5}\NormalTok{)}
\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3] [,4] [,5]
[1,]    0    0    0    0    0
[2,]    0    0    0    0    0
\end{verbatim}

Una vez que la matriz ya existe, en el pseudocódigo haremos referencia al número de filas y columnas de la misma con las expresiones \texttt{NFILA(x)} y \texttt{NCOL(x)}. En R tenemos las siguientes funciones para analizar el tamaño de las matrices:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nrow}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ncol}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nrow}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ncol}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 5
\end{verbatim}

Podemos recorrer todas las posiciones de una matriz con una estructura iterativa doble: nos situamos en la primera fila y recorremos cada columna, luego en la segunda fila y recorremos todas las columnas y así sucesivamente:

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/05_estructuras/estr07} 

}

\caption{Recorrer una matriz por fila}\label{fig:unnamed-chunk-123}
\end{figure}

También se puede recorrer la matriz por columna, si modificamos ligeramente las estructuras iterativas:

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/05_estructuras/estr08} 

}

\caption{Recorrer una matriz por columna}\label{fig:unnamed-chunk-125}
\end{figure}

Se puede usar cualquier letra o palabra como variables iteradoras, pero el uso de \texttt{i} para las filas y de \texttt{j} para las columnas es bastante común.

También podemos asignar valores en cada celda mientras recorremos la matriz. De hecho, la matriz \texttt{x} del ejemplo puede ser generada así, donde los índices \texttt{i} y \texttt{j} no sólo señalan una posición en particular dentro de la matriz, sino que además se usan para hacer el cálculo del valor a asignar:

\begin{verbatim}
VARIABLE numérica x(3, 4)
PARA i DESDE 1 HASTA NFILA(x) HACER
    PARA j DESDE 1 HASTA NCOL(x) HACER
        x[i, j] <- 3 * i + 5 * j
    FIN PARA
FIN PARA
MOSTRAR x
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{0}\NormalTok{, }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{, }\AttributeTok{ncol =} \DecValTok{4}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{nrow}\NormalTok{(x)) \{}
    \ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{ncol}\NormalTok{(x)) \{}
\NormalTok{        x[i, j] }\OtherTok{\textless{}{-}} \DecValTok{3} \SpecialCharTok{*}\NormalTok{ i }\SpecialCharTok{+} \DecValTok{5} \SpecialCharTok{*}\NormalTok{ j}
\NormalTok{    \}}
\NormalTok{\}}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3] [,4]
[1,]    8   13   18   23
[2,]   11   16   21   26
[3,]   14   19   24   29
\end{verbatim}

Si queremos dejar que el valor en cada posición sea determinado por una fuente de información externa a la hora de correr el programa, empleamos la sentencia \texttt{LEER} en el pseudocódigo:

\begin{verbatim}
VARIABLE numérica x(3, 4)
PARA i DESDE 1 HASTA NFILA(x) HACER
  PARA j DESDE 1 HASTA NCOL(x) HACER
    LEER x[i, j]
  FIN PARA
FIN PARA
\end{verbatim}

\textbf{Ejemplo: trasponer una matriz}

En Álgebra, trasponer una matriz de dimensión \(m \times n\) significa generar una nueva matriz de dimensión \(n \times m\), donde los elementos se intercambian de este modo:

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/05_estructuras/estr14} 

}

\caption{Matriz traspuesta}\label{fig:unnamed-chunk-127}
\end{figure}

Podemos formalizar el algoritmo que permite generar la matriz traspuesta, teniendo en cuenta que cada elemento que originalmente ocupa la posición \texttt{{[}i,\ j{]}} en la matriz original, debe pasar a ocupar la posición \texttt{{[}j,\ i{]}} en la matriz traspuesta:

\begin{verbatim}
ALGORITMO: Trasponer matriz
COMENZAR
    
    # Declarar objetos
    VARIABLE numérica nf, nc
    LEER nf, nc
    VARIABLE numérica x(nf, nc), traspuesta(nc, nf)
    
    # Leer los valores de la matriz
    PARA i DESDE 1 HASTA nf HACER
        PARA j DESDE 1 HASTA nc HACER
            LEER x[i, j]
        FIN PARA
    FIN PARA
    
    # Trasponer
    PARA i DESDE 1 HASTA nf HACER
        PARA j DESDE 1 HASTA nc HACER
            traspuesta[j, i] <- x[i, j]
        FIN PARA
    FIN PARA
    
    # Mostrar ambas matrices
    ESCRIBIR "Matriz original"
    MOSTRAR x
    ESCRIBIR "Matriz traspuesta"
    MOSTRAR traspuesta
    
FIN
\end{verbatim}

Dado que en R vamos a asignar valores en la matriz de manera literal, primero la creamos y luego usamos \texttt{nrow()} y \texttt{ncol()} para obtener los correspondientes valores de \texttt{nf} y \texttt{nc}. En el siguiente ejemplo, además, todas las posiciones de la matriz traspuesta son iniciadas con el valor \texttt{NA}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{( }\DecValTok{8}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{23}\NormalTok{, }
              \DecValTok{11}\NormalTok{, }\DecValTok{16}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{26}\NormalTok{, }
              \DecValTok{14}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{29}\NormalTok{), }
            \AttributeTok{nrow =} \DecValTok{3}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{nf }\OtherTok{\textless{}{-}} \FunctionTok{nrow}\NormalTok{(x)}
\NormalTok{nc }\OtherTok{\textless{}{-}} \FunctionTok{ncol}\NormalTok{(x)}
\NormalTok{traspuesta }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\ConstantTok{NA}\NormalTok{, nc, nf)}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{nf) \{}
    \ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{nc) \{}
\NormalTok{        traspuesta[j, i] }\OtherTok{\textless{}{-}}\NormalTok{ x[i, j]}
\NormalTok{    \}}
\NormalTok{\}}
\FunctionTok{cat}\NormalTok{(}\StringTok{"Matriz original}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{x}
\FunctionTok{cat}\NormalTok{(}\StringTok{"Matriz traspuesta}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{traspuesta}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Matriz original
     [,1] [,2] [,3] [,4]
[1,]    8   13   18   23
[2,]   11   16   21   26
[3,]   14   19   24   29
Matriz traspuesta
     [,1] [,2] [,3]
[1,]    8   11   14
[2,]   13   16   19
[3,]   18   21   24
[4,]   23   26   29
\end{verbatim}

\hypertarget{caracteruxedsticas-particulares-de-las-estructuras-de-datos-en-r}{%
\section{Características particulares de las estructuras de datos en R}\label{caracteruxedsticas-particulares-de-las-estructuras-de-datos-en-r}}

Los vectores y matrices son estructuras que están bien representadas en casi cualquier lenguaje de programación. Por esta razón, ante diversos problemas computacionales podemos escribir algoritmos que empleando arreglos y operando con cada uno de sus elementos alcancen los objetivos propuestos.

No obstante, cada lenguaje de programación propone formas particulares de operar con los arreglos e incluso otros tipos de estructuras de datos. En esta sección nos dedicaremos a conocer cuáles son las herramientas que R nos ofrece para trabajar con vectores y matrices. Como son específicas de R, no hay convenciones generales para representarlas en pseudocódigo.

\hypertarget{elementos-con-nombre}{%
\subsection{Elementos con nombre}\label{elementos-con-nombre}}

Además de guardar información, los objetos de R pueden poseer ciertos \textbf{atributos}, que consisten en información adicional sobre el objeto. Uno de ellos es el atributo \texttt{names}, que permite que cada elemento dentro de un vector o una lista pueda tener su propio nombre, así como también que cada fila o columna de una matriz tenga su propio nombre, independientemente del identificador general del objeto.

\textbf{Vectores}

A cada elemento de un vector se le puede, opcionalmente, asignar un nombre. Esto se realiza de alguna de estas formas:

\begin{itemize}
\item
  Opción 1: después de crear el vector

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# El vector se llama "frutas" y tiene 4 elementos}
\NormalTok{frutas }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{frutas}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3 7 2 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Cada uno de estos elementos no tienen nombres}
\FunctionTok{names}\NormalTok{(frutas)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
NULL
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Le doy un nombre a cada elemento}
\FunctionTok{names}\NormalTok{(frutas) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"manzanas"}\NormalTok{, }\StringTok{"naranjas"}\NormalTok{, }\StringTok{"bananas"}\NormalTok{, }\StringTok{"peras"}\NormalTok{)}
\NormalTok{frutas}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
manzanas naranjas  bananas    peras 
       3        7        2        1 
\end{verbatim}
\item
  Opción 2: en el momento de crear el vector

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{frutas }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\AttributeTok{manzanas =} \DecValTok{3}\NormalTok{, }\AttributeTok{naranjas =} \DecValTok{7}\NormalTok{, }\AttributeTok{bananas =} \DecValTok{2}\NormalTok{, }\AttributeTok{peras =} \DecValTok{1}\NormalTok{)}
\NormalTok{frutas}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
manzanas naranjas  bananas    peras 
       3        7        2        1 
\end{verbatim}
\end{itemize}

Los nombres son útiles porque permiten indexar al vector, sin necesidad de usar como índice la posición del elemento:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{frutas[}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
naranjas 
       7 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{frutas[}\StringTok{"naranjas"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
naranjas 
       7 
\end{verbatim}

No todos los elementos de un vector deben tener nombre:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{frutas }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\AttributeTok{manzanas =} \DecValTok{3}\NormalTok{, }\DecValTok{7}\NormalTok{, }\AttributeTok{bananas =} \DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{frutas}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
manzanas           bananas          
       3        7        2        1 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(frutas)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "manzanas" ""         "bananas"  ""        
\end{verbatim}

\textbf{Matrices}

En el caso de las matrices, se le puede asignar nombres a sus filas y columnas:

\begin{itemize}
\item
  Opción 1: después de crear la matriz

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{( }\DecValTok{8}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{23}\NormalTok{, }
              \DecValTok{11}\NormalTok{, }\DecValTok{16}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{26}\NormalTok{, }
              \DecValTok{14}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{29}\NormalTok{), }
              \AttributeTok{nrow =} \DecValTok{3}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{rownames}\NormalTok{(x) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"C"}\NormalTok{)}
\FunctionTok{colnames}\NormalTok{(x) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"grupo1"}\NormalTok{, }\StringTok{"grupo2"}\NormalTok{, }\StringTok{"grupo3"}\NormalTok{, }\StringTok{"grupo4"}\NormalTok{)}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  grupo1 grupo2 grupo3 grupo4
A      8     13     18     23
B     11     16     21     26
C     14     19     24     29
\end{verbatim}
\item
  Opción 2: al crear la matriz
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{( }\DecValTok{8}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{23}\NormalTok{, }
              \DecValTok{11}\NormalTok{, }\DecValTok{16}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{26}\NormalTok{, }
              \DecValTok{14}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{29}\NormalTok{), }
            \AttributeTok{nrow =} \DecValTok{3}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{,}
            \AttributeTok{dimnames =} \FunctionTok{list}\NormalTok{(}\AttributeTok{Categorias =} \FunctionTok{c}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"C"}\NormalTok{), }
                            \AttributeTok{Grupos =} \FunctionTok{c}\NormalTok{(}\StringTok{"grupo1"}\NormalTok{, }\StringTok{"grupo2"}\NormalTok{, }\StringTok{"grupo3"}\NormalTok{, }\StringTok{"grupo4"}\NormalTok{)))}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
          Grupos
Categorias grupo1 grupo2 grupo3 grupo4
         A      8     13     18     23
         B     11     16     21     26
         C     14     19     24     29
\end{verbatim}

En este último ejemplo, se han elegido arbitrariamente los nombres \texttt{Categorias} y \texttt{Grupos} para llamar al conjunto completo de las filas y de las columnas, respectivamente. Esos nombres pueden ser cambiados por otros. Además, los nombres fueron encerrados en una \emph{lista}, una estructura de datos que estudiaremos en breve.

Al igual que con los vectores, podemos usar los nombres de filas y columnas para indexar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\StringTok{"B"}\NormalTok{, }\StringTok{"grupo2"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 16
\end{verbatim}

\hypertarget{operaciones-vectorizadas}{%
\subsection{Operaciones vectorizadas}\label{operaciones-vectorizadas}}

Con los conocimientos compartidos hasta aquí en esta unidad seremos capaces de escribir interesantes algoritmos para operar con vectores y matrices (por ejemplo: ordenar, buscar el mínimo, realizar cálculos algebraicos, etc.) y también de programarlos en R. En este proceso de aprendizaje, en la práctica de esta unidad vamos a encarar la tarea de escribir muchas funciones que, por lo general, ya forman parte de la sintaxis básica de cualquier lenguaje de programación. Sí\ldots{} trabajaremos de más, ¡pero es para poder aprender! No obstante, ahora vamos a mencionar algunos ejemplos de funciones que ya están disponibles en R y que evitan que tengamos que trabajar tanto.

La mayoría de las funciones de R están \textbf{vectorizadas}. Esto quiere decir que están diseñadas para operar al mismo tiempo con todos los elementos de los vectores y matrices y no es necesario recorrer cada posición, una por una, como aprendimos para incorporar nuestros primeros conocimientos sobre algoritmos. Las funciones operan en todos los elementos sin tener que usar estructuras iterativas, haciendo que el código sea más conciso, fácil de leer y con menos chances de cometer errores.

\textbf{Vectores}

Por ejemplo, supongamos que queremos sumar dos vectores, como en el *\textbf{ejercicio 2 de la práctica 4}. Gracias a que la suma en R está vectorizada, esto se logra haciendo sencillamente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{u }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{v }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{suma }\OtherTok{\textless{}{-}}\NormalTok{ u }\SpecialCharTok{+}\NormalTok{ v}
\NormalTok{suma}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  7 11  1
\end{verbatim}

Sin vectorización, deberíamos diseñar y programar un algoritmo como el siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{suma }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(}\FunctionTok{length}\NormalTok{(u))}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{length}\NormalTok{(u)) \{ }
\NormalTok{    suma[i] }\OtherTok{\textless{}{-}}\NormalTok{ u[i] }\SpecialCharTok{+}\NormalTok{ v[i]}
\NormalTok{\}}
\NormalTok{suma}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  7 11  1
\end{verbatim}

Como podemos notar, al ejecutar \texttt{u\ +\ v} R realiza la suma elemento a elemento entre los dos vectores. Esto también sucede con los otros operadores aritméticos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{u }\SpecialCharTok{{-}}\NormalTok{ v}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3 5 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{u }\SpecialCharTok{*}\NormalTok{ v}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 10 24 -2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{u }\SpecialCharTok{/}\NormalTok{ v}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  2.500000  2.666667 -2.000000
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{u }\SpecialCharTok{\%\%}\NormalTok{ v}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1 2 0
\end{verbatim}

Estas operaciones también funcionan con vectores de distinto largo. En este caso, R aplica la \textbf{regla del reciclaje}: el vector más corto se recicla (se repiten sus elementos) hasta alcanzar la longitud del más largo y luego se opera elemento a elemento. Como es raro que queramos operar con dos vectores de distinto largo, R por las dudas nos tira una advertencia:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{u }\SpecialCharTok{+}\NormalTok{ z}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Warning in u + z: longer object length is not a multiple of shorter object
length
\end{verbatim}

\begin{verbatim}
[1]  6 10  3
\end{verbatim}

Si hacemos operaciones que involucran a una constante y a un vector, R repetirá tal operación con cada elemento del vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{u }\SpecialCharTok{+} \DecValTok{5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 10 13  7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \SpecialCharTok{/}\NormalTok{ v}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  0.5000000  0.3333333 -1.0000000
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{10} \SpecialCharTok{*}\NormalTok{ z}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 10 20
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(u }\SpecialCharTok{+}\NormalTok{ v) }\SpecialCharTok{/} \DecValTok{100}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 0.07 0.11 0.01
\end{verbatim}

Si le aplicamos funciones matemáticas como \texttt{log()} o \texttt{sqrt()} a un vector, obtendremos como resultado el valor de dicha función en cada uno de los elementos del vector:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{log}\NormalTok{(u)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1.6094379 2.0794415 0.6931472
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1.000000 1.414214
\end{verbatim}

Hay funciones que cuando se aplican a un vector, logran resumirlo siguiendo algún criterio:

\begin{itemize}
\item
  Sumar todos los elementos de un vector:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(u)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 15
\end{verbatim}
\item
  Multiplicar todos los elementos de un vector:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{prod}\NormalTok{(u)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 80
\end{verbatim}
\item
  Calcular el promedio de los elementos de un vector:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(u)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 5
\end{verbatim}
\item
  Encontrar el valor mínimo y su ubicación en el vector (como en el \textbf{ejercicio 4 de la práctica 4}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{40}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{20}\NormalTok{)}
\FunctionTok{min}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 20
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{which.min}\NormalTok{(x) }\CommentTok{\# si el mínimo se repite, esta es la posición del primero}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{which}\NormalTok{(x }\SpecialCharTok{==} \FunctionTok{min}\NormalTok{(x)) }\CommentTok{\# si el mínimo se repite, esto muestra todas sus posiciones}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3 5
\end{verbatim}
\item
  Encontrar el valor máximo y su ubicación en el vector:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{max}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 90
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{which.max}\NormalTok{(x) }\CommentTok{\# si el mínimo se repite, esta es la posición del primero}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{which}\NormalTok{(x }\SpecialCharTok{==} \FunctionTok{max}\NormalTok{(x)) }\CommentTok{\# si el mínimo se repite, esto muestra todas sus posiciones}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 4
\end{verbatim}
\end{itemize}

Combinando las ideas anteriores, podemos resolver de forma muy rápida ciertos problemas, como el de calcular el producto escalar entre dos vectores (\textbf{ejercicio 5 de la práctica 4}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{u}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 5 8 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  2  3 -1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(u }\SpecialCharTok{*}\NormalTok{ v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 32
\end{verbatim}

En lo anterior, \texttt{u\ *\ v} hace la multiplicación elemento a elemento entre los vectores \texttt{u} y \texttt{v} y luego sumamos esos valores con \texttt{sum()}. Sin las operaciones vectorizadas, deberíamos hacer algo como lo siguiente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rtdo }\OtherTok{\textless{}{-}} \DecValTok{0}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{length}\NormalTok{(u)) \{ }
\NormalTok{    rtdo }\OtherTok{\textless{}{-}}\NormalTok{ rtdo }\SpecialCharTok{+}\NormalTok{ u[i] }\SpecialCharTok{*}\NormalTok{ v[i]}
\NormalTok{\}}
\NormalTok{rtdo}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 32
\end{verbatim}

En el \textbf{ejercicio 3} de la \textbf{Práctica 4} creamos las funciones \texttt{ordenar\_asc()} y \texttt{ordenar\_des()} para ordenar los elementos de un vector. Con las funciones disponibles en R, esto se puede hacer así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 40 70 20 90 20
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sort}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 20 20 40 70 90
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sort}\NormalTok{(x, }\AttributeTok{decreasing =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 90 70 40 20 20
\end{verbatim}

\textbf{Matrices}

Los casos anteriores tienen sus equivalentes cuando operamos con matrices. Por ejemplo, en el \textbf{ejercicio 7 de la práctica 4} programamos una función para hacer la suma entre dos matrices. Sin vectorización, esto involucra pasos como los siguientes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{)}
\NormalTok{b }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{)}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    5    2
[2,]    8    3
[3,]    2    1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    0    1
[2,]   -1    2
[3,]    3    4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{suma }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\ConstantTok{NA}\NormalTok{, }\FunctionTok{nrow}\NormalTok{(a), }\FunctionTok{ncol}\NormalTok{(a))}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{nrow}\NormalTok{(a)) \{}
    \ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{ncol}\NormalTok{(a)) \{}
\NormalTok{        suma[i, j] }\OtherTok{\textless{}{-}}\NormalTok{ a[i, j] }\SpecialCharTok{+}\NormalTok{ b[i, j]}
\NormalTok{    \}}
\NormalTok{\}}
\NormalTok{suma}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    5    3
[2,]    7    5
[3,]    5    5
\end{verbatim}

Gracias a las operaciones vectorizadas de R, esto se puede resumir en:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\SpecialCharTok{+}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    5    3
[2,]    7    5
[3,]    5    5
\end{verbatim}

A continuación, otros ejemplos de operaciones realizadas elemento a elemento con matrices:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\SpecialCharTok{+}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    5    3
[2,]    7    5
[3,]    5    5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\SpecialCharTok{{-}}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    5    1
[2,]    9    1
[3,]   -1   -3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\SpecialCharTok{*}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    0    2
[2,]   -8    6
[3,]    6    4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\SpecialCharTok{/}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
           [,1] [,2]
[1,]        Inf 2.00
[2,] -8.0000000 1.50
[3,]  0.6666667 0.25
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a}\SpecialCharTok{\^{}}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]   25    4
[2,]   64    9
[3,]    4    1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
         [,1]     [,2]
[1,] 2.236068 1.414214
[2,] 2.828427 1.732051
[3,] 1.414214 1.000000
\end{verbatim}

También podemos resumir la información contenida en una matriz:

\begin{itemize}
\item
  Suma de todos los elementos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    5    2
[2,]    8    3
[3,]    2    1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 21
\end{verbatim}
\item
  Promedio de todos los elementos:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3.5
\end{verbatim}
\item
  Suma de los elementos por fila:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rowSums}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  7 11  3
\end{verbatim}
\item
  Suma de los elementos por columna:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{colSums}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 15  6
\end{verbatim}
\item
  Promedio de los elementos por fila:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rowMeans}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3.5 5.5 1.5
\end{verbatim}
\item
  Promedio de los elementos por columna:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{colMeans}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 5 2
\end{verbatim}
\item
  Búsqueda de mínimos y máximos en una matriz:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{sample}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{20}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{5}\NormalTok{)}

\CommentTok{\# Valor máximo}
\FunctionTok{max}\NormalTok{(d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 100
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Posición (arr.ind = TRUE para que nos indique fila y columna)}
\FunctionTok{which}\NormalTok{(d }\SpecialCharTok{==} \FunctionTok{max}\NormalTok{(d), }\AttributeTok{arr.ind =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     row col
[1,]   4   2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Valor mínimo}
\FunctionTok{min}\NormalTok{(d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Posición}
\FunctionTok{which}\NormalTok{(d }\SpecialCharTok{==} \FunctionTok{min}\NormalTok{(d), }\AttributeTok{arr.ind =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     row col
[1,]   5   3
\end{verbatim}
\end{itemize}

Como aprenderán en Álgebra, las matrices numéricas son muy útiles en diversos campos y por eso existen distintas operaciones que se pueden realizar con las mismas. Veamos algunos ejemplos de la aplicación del álgebra matricial en R:

\begin{itemize}
\item
  Transpuesta de una matriz:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    5    2
[2,]    8    3
[3,]    2    1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{t}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3]
[1,]    5    8    2
[2,]    2    3    1
\end{verbatim}
\item
  Producto entre dos matrices:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{, }\AttributeTok{nrow =} \DecValTok{2}\NormalTok{)}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    5    2
[2,]    8    3
[3,]    2    1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    1    3
[2,]    2    4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\SpecialCharTok{\%*\%}\NormalTok{ e}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    9   23
[2,]   14   36
[3,]    4   10
\end{verbatim}
\item
  Inversa de la matriz:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{solve}\NormalTok{(e)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]   -2  1.5
[2,]    1 -0.5
\end{verbatim}
\item
  Obtener los elementos de la diagonal principal:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{diag}\NormalTok{(d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 89 78 52 27
\end{verbatim}
\end{itemize}

\hypertarget{operaciones-luxf3gicas-vectorizadas}{%
\subsection{Operaciones lógicas vectorizadas}\label{operaciones-luxf3gicas-vectorizadas}}

Cuando dos vectores o matrices se vinculan a través de una comparación, se opera elemento a elemento obteniendo un vector o matriz de valores lógicos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{40}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{20}\NormalTok{)}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{21}\NormalTok{)}
\NormalTok{x }\SpecialCharTok{\textgreater{}}\NormalTok{ y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  TRUE FALSE FALSE  TRUE FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\SpecialCharTok{\textless{}}\NormalTok{ y }\SpecialCharTok{*} \DecValTok{5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  TRUE  TRUE  TRUE FALSE  TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{)}
\NormalTok{b }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{)}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    5    2
[2,]    8    3
[3,]    2    1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    0    1
[2,]   -1    2
[3,]    3    4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\SpecialCharTok{!=}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,] TRUE TRUE
[2,] TRUE TRUE
[3,] TRUE TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\SpecialCharTok{\textgreater{}}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
      [,1]  [,2]
[1,]  TRUE  TRUE
[2,]  TRUE  TRUE
[3,] FALSE FALSE
\end{verbatim}

Si un vector o matriz de valores lógicos y queremos saber si todos o al menos uno de los elementos es igual a \texttt{TRUE}, podemos usar las funciones \texttt{all()} y \texttt{any()}, respectivamente:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{all}\NormalTok{(a }\SpecialCharTok{!=}\NormalTok{ b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{any}\NormalTok{(a }\SpecialCharTok{!=}\NormalTok{ b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{all}\NormalTok{(a }\SpecialCharTok{\textgreater{}}\NormalTok{ b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{any}\NormalTok{(a }\SpecialCharTok{\textgreater{}}\NormalTok{ b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

Las operaciones de comparación pueden hacerse entre cada elemento de un vector o matriz y un único valor:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\SpecialCharTok{\textless{}} \DecValTok{50}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  TRUE FALSE  TRUE FALSE  TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\SpecialCharTok{==} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
      [,1]  [,2]
[1,] FALSE FALSE
[2,] FALSE  TRUE
[3,] FALSE FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b }\SpecialCharTok{\textgreater{}} \DecValTok{0}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
      [,1] [,2]
[1,] FALSE TRUE
[2,] FALSE TRUE
[3,]  TRUE TRUE
\end{verbatim}

Los operadores lógicos que se utilizan para realizar cálculos elemento a elemento con vectores y matrices son \texttt{\&}, \texttt{\textbackslash{}} y \texttt{!}. Ellos nos permiten crear expresiones aún más complejas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\SpecialCharTok{\textless{}} \DecValTok{50} \SpecialCharTok{\&}\NormalTok{ y }\SpecialCharTok{\textgreater{}} \DecValTok{50}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE FALSE FALSE FALSE FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\SpecialCharTok{\textless{}} \DecValTok{0} \SpecialCharTok{|}\NormalTok{ b }\SpecialCharTok{\textgreater{}} \DecValTok{0}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
      [,1] [,2]
[1,] FALSE TRUE
[2,] FALSE TRUE
[3,]  TRUE TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{!}\NormalTok{(x }\SpecialCharTok{\textless{}=} \DecValTok{50}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE  TRUE FALSE  TRUE FALSE
\end{verbatim}

\hypertarget{uso-de-vectores-para-indexar-vectores-y-matrices}{%
\subsection{Uso de vectores para indexar vectores y matrices}\label{uso-de-vectores-para-indexar-vectores-y-matrices}}

Como ya sabemos, indexar es hacer referencia a uno o más elementos particulares dentro de una estructura de datos. Vimos que para indexar a un vector, hace falta sólo un índice:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\FloatTok{10.4}\NormalTok{, }\FloatTok{5.6}\NormalTok{, }\FloatTok{3.1}\NormalTok{, }\FloatTok{6.4}\NormalTok{, }\FloatTok{21.7}\NormalTok{)}
\NormalTok{x[}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3.1
\end{verbatim}

Y que para indexar matrices, son necesarios dos índices:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{,}\SpecialCharTok{{-}}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{20}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{7}\NormalTok{, }\DecValTok{12}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{8}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{17}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{)}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3]
[1,]    4   20   -8
[2,]   -2   -7   13
[3,]    1   12   17
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a[}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 13
\end{verbatim}

Pero también podemos indexar a múltiples elementos de un vector o una matriz a la vez:

\textbf{Vectores}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Mostrar los primeros tres elementos del vector x}
\NormalTok{x[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 10.4  5.6  3.1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Mostrar los elementos en las posiciones 2 y 4}
\NormalTok{x[}\FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 5.6 6.4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Mostrar el último elemento}
\NormalTok{x[}\FunctionTok{length}\NormalTok{(x)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 21.7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Indexar con valores lógicos. Obtenemos sólo las posiciones indicadas con TRUE:}
\NormalTok{x[}\FunctionTok{c}\NormalTok{(F, F, T, T, F)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3.1 6.4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Sabiendo que la siguiente operación devuelve TRUE o FALSE para cada posición de x:}
\NormalTok{x }\SpecialCharTok{\textgreater{}} \DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  TRUE FALSE FALSE FALSE  TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# ...la podemos usar para quedarnos con aquellos elementos de x mayores a 10:}
\NormalTok{x[x }\SpecialCharTok{\textgreater{}} \DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 10.4 21.7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#Mostrar todos los elementos menos el cuarto}
\NormalTok{x[}\SpecialCharTok{{-}}\DecValTok{4}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 10.4  5.6  3.1 21.7
\end{verbatim}

\textbf{Matrices}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Toda la fila 3}
\NormalTok{a[}\DecValTok{3}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  1 12 17
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Toda la columna 2}
\NormalTok{a[, }\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 20 -7 12
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Submatriz con las columnas 1 y 2}
\NormalTok{a[, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    4   20
[2,]   -2   -7
[3,]    1   12
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Submatriz con las columnas 1 y 3}
\NormalTok{a[, }\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    4   -8
[2,]   -2   13
[3,]    1   17
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Asignar el mismo valor en toda la fila 3}
\NormalTok{a[}\DecValTok{3}\NormalTok{, ] }\OtherTok{\textless{}{-}} \DecValTok{10}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3]
[1,]    4   20   -8
[2,]   -2   -7   13
[3,]   10   10   10
\end{verbatim}

\hypertarget{la-funciuxf3n-apply}{%
\subsection{\texorpdfstring{La función \texttt{apply()}}{La función apply()}}\label{la-funciuxf3n-apply}}

Supongamos que queremos encontrar el máximo valor en cada fila de una matriz. Podemos lograrlo de la siguiente forma. Creamos un vector \texttt{maximos} con lugar para guardar el máximo de cada fila. Luego, iteramos para recorrer cada fila de la matriz, buscar el mínimo y guardarlo en el vector \texttt{maximos}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3]
[1,]    4   20   -8
[2,]   -2   -7   13
[3,]   10   10   10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{maximos }\OtherTok{\textless{}{-}} \FunctionTok{numeric}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(a))}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{nrow}\NormalTok{(a)) \{}
\NormalTok{    maximos[i] }\OtherTok{\textless{}{-}} \FunctionTok{max}\NormalTok{(a[i, ])}
\NormalTok{\}}
\NormalTok{maximos}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 20 13 10
\end{verbatim}

En R existe una forma más práctica y eficiente de conseguir el mismo resultado:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{apply}\NormalTok{(a, }\DecValTok{1}\NormalTok{, max)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 20 13 10
\end{verbatim}

La función \texttt{apply()} sirve para aplicar una misma operación a cada fila o columna de una matriz. En el ejemplo anterior:

\begin{itemize}
\tightlist
\item
  el primer argumento, \texttt{a}, es la matriz a analizar.
\item
  el segundo argumento, \texttt{1}, indica que la operación se realizará fila por fila (para que se haga por columna, debemos indicar \texttt{2})
\item
  el tercer argumento, \texttt{max}, es el nombre de la función que se le aplica a cada fila.
\end{itemize}

De manera similar, podemos encontrar el mínimo valor de cada columna:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{apply}\NormalTok{(a, }\DecValTok{2}\NormalTok{, min)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] -2 -7 -8
\end{verbatim}

\hypertarget{generaciuxf3n-de-vectores-con-secuencias-numuxe9ricas}{%
\subsection{Generación de vectores con secuencias numéricas}\label{generaciuxf3n-de-vectores-con-secuencias-numuxe9ricas}}

A continuación mostramos cómo generar algunos vectores numéricos en R:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Enteros de 1 a 5}
\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1 2 3 4 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Números de 1 a 10 cada 2}
\FunctionTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1 3 5 7 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Números de 0 a {-}1 cada {-}0.1}
\FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\SpecialCharTok{{-}}\FloatTok{0.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  0.0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.6 -0.7 -0.8 -0.9 -1.0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Siete números equiespaciados entre 0 y 1}
\FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\AttributeTok{length.out =} \DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 0.0000000 0.1666667 0.3333333 0.5000000 0.6666667 0.8333333 1.0000000
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Repetir el 1 tres veces}
\FunctionTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1 1 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Repetir (1, 2, 3) tres veces}
\FunctionTok{rep}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1 2 3 1 2 3 1 2 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Repetir cada número tres veces}
\FunctionTok{rep}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{, }\AttributeTok{each =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1 1 1 2 2 2 3 3 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Generar una matriz diagonal}
\FunctionTok{diag}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3] [,4]
[1,]    3    0    0    0
[2,]    0    7    0    0
[3,]    0    0    1    0
[4,]    0    0    0    5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Generar una matriz identidad}
\FunctionTok{diag}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    0    0    0    0
[2,]    0    1    0    0    0
[3,]    0    0    1    0    0
[4,]    0    0    0    1    0
[5,]    0    0    0    0    1
\end{verbatim}

\hypertarget{concatenaciuxf3n-de-vectores-y-matrices}{%
\subsection{Concatenación de vectores y matrices}\label{concatenaciuxf3n-de-vectores-y-matrices}}

Los vectores pueden combinarse entre sí para crear nuevos vectores con \texttt{c()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{87}\NormalTok{)}
\NormalTok{z }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(x, y, x)}
\NormalTok{z}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  1  2  3  4  5 10 90 87  1  2  3  4  5
\end{verbatim}

Matrices que tienen la misma cantidad de filas pueden concatenarse una al lado de la otra con \texttt{cbind()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{)}
\NormalTok{b }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{)}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    5    2
[2,]    8    3
[3,]    2    1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    0    1
[2,]   -1    2
[3,]    3    4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{cbind}\NormalTok{(a, b)}
\NormalTok{d}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3] [,4]
[1,]    5    2    0    1
[2,]    8    3   -1    2
[3,]    2    1    3    4
\end{verbatim}

Matrices que tienen la misma cantidad de columnas pueden concatenarse una debajo de la otra con \texttt{cbind()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e }\OtherTok{\textless{}{-}} \FunctionTok{rbind}\NormalTok{(a, b)}
\NormalTok{e}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    5    2
[2,]    8    3
[3,]    2    1
[4,]    0    1
[5,]   -1    2
[6,]    3    4
\end{verbatim}

Estas funciones también permiten unir matrices con vectores:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{6}
\FunctionTok{cbind}\NormalTok{(e, x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
          x
[1,]  5 2 1
[2,]  8 3 2
[3,]  2 1 3
[4,]  0 1 4
[5,] -1 2 5
[6,]  3 4 6
\end{verbatim}

\hypertarget{listas}{%
\subsection{Listas}\label{listas}}

Una de las principales características de los \textbf{arreglos} es la \textbf{homegeneidad}: todos los elementos que contienen deben ser del mismo tipo. No se puede, por ejemplo, mezclar en una matriz valores numéricos y lógicos. Sin embargo, en muchos problemas resulta útil contar con alguna estructura de datos que permita agrupar objetos de diversos tipos. Esa es, justamente, la definición de una \textbf{lista}. Podemos imaginarla como una bolsa en la cual podemos meter todo tipo de objetos, incluyendo vectores, matrices y, por qué no, otras bolsas (es decir, bolsas dentro de una bolsa o listas dentro de una lista). Todos los lenguajes de programación proveen algún tipo de estructura con estas características, aunque no todos las llaman igual. Otros posibles nombres con los que se conocen pueden ser \emph{tupla} o \emph{agregado}. En R se llaman \textbf{listas} o \textbf{vectores recursivos}. El siguiente diagrama presenta una lista (recuadro con puntas redondeadas) que contiene:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Un vector numérico de largo 3.
\item
  Un vector carácter de largo 2.
\item
  Una matriz numérica de dimensión 2x2.
\item
  Un valor lógico.
\end{enumerate}

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{images/05_estructuras/estr09} 

}

\caption{Ejemplo de una lista}\label{fig:unnamed-chunk-180}
\end{figure}

La creación de esta lista se realiza mediante la función \texttt{list()}, cuyos argumentos son los elementos que queremos guardar en la lista, separados por comas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mi\_lista }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}
    \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\FloatTok{4.5}\NormalTok{, }\DecValTok{12}\NormalTok{, }\FloatTok{2.71}\NormalTok{),}
    \FunctionTok{c}\NormalTok{(}\StringTok{"hola"}\NormalTok{, }\StringTok{"chau"}\NormalTok{),}
    \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{8}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{16}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{2}\NormalTok{),}
    \ConstantTok{TRUE}
\NormalTok{)}
\NormalTok{mi\_lista}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[1]]
[1] -4.50 12.00  2.71

[[2]]
[1] "hola" "chau"

[[3]]
     [,1] [,2]
[1,]    8   13
[2,]   11   16

[[4]]
[1] TRUE
\end{verbatim}

Luego de correr la sentencia anterior, podemos ver que \texttt{mi\_lista} es un nuevo objeto disponible en el ambiente global y como tal está listado en el panel \emph{Environment}. Allí se nos indica que se trata de una lista y, además, podemos previsualizar su contenido al hacer clic en el círculo celeste que antecede a su nombre:

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{images/05_estructuras/lista_rstudio} 

}

\caption{La lista en la pestaña Environment de RStudio}\label{fig:unnamed-chunk-182}
\end{figure}

Usamos dobles corchetes \texttt{{[}{[}\ {]}{]}} para referenciar a cada objeto que forma parte de la lista. Además, si queremos indicar un elemento dentro de un objeto que forma parte de la lista, agregamos otro conjunto de corchetes como hacemos con vectores y matrices. Por ejemplo:

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{images/05_estructuras/estr10} 

}

\caption{Ejemplo de una lista}\label{fig:unnamed-chunk-183}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mi\_lista[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] -4.50 12.00  2.71
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mi\_lista[[}\DecValTok{1}\NormalTok{]][}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2.71
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mi\_lista[[}\DecValTok{2}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "hola" "chau"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mi\_lista[[}\DecValTok{2}\NormalTok{]][}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "chau"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mi\_lista[[}\DecValTok{3}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    8   13
[2,]   11   16
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mi\_lista[[}\DecValTok{3}\NormalTok{]][}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 11
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mi\_lista[[}\DecValTok{4}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mi\_lista[[}\DecValTok{4}\NormalTok{]][}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

Podemos asignar valor a algún elemento usando los índices de esa misma forma:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mi\_lista[[}\DecValTok{1}\NormalTok{]][}\DecValTok{3}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{0}
\NormalTok{mi\_lista}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[1]]
[1] -4.5 12.0  0.0

[[2]]
[1] "hola" "chau"

[[3]]
     [,1] [,2]
[1,]    8   13
[2,]   11   16

[[4]]
[1] TRUE
\end{verbatim}

Cada uno de los elementos de una lista puede tener un nombre propio. Podemos asignarle un nombre a uno, algunos o todos los integrantes en una lista:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mi\_lista }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}
    \AttributeTok{w =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\FloatTok{4.5}\NormalTok{, }\DecValTok{12}\NormalTok{, }\FloatTok{2.71}\NormalTok{),}
    \AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\StringTok{"hola"}\NormalTok{, }\StringTok{"chau"}\NormalTok{),}
    \AttributeTok{y =} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{8}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{16}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{2}\NormalTok{),}
    \AttributeTok{z =} \ConstantTok{TRUE}
\NormalTok{)}
\NormalTok{mi\_lista}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
$w
[1] -4.50 12.00  2.71

$x
[1] "hola" "chau"

$y
     [,1] [,2]
[1,]    8   13
[2,]   11   16

$z
[1] TRUE
\end{verbatim}

Esto amplía las opciones para hacer referencia a cada objeto y elemento allí contenido. Las siguientes sentencias son todas equivalentes y sirven para acceder al tercer elemento de la lista, cuyo nombre es \texttt{y}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mi\_lista[[}\DecValTok{3}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    8   13
[2,]   11   16
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mi\_lista[[}\StringTok{"y"}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    8   13
[2,]   11   16
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mi\_lista}\SpecialCharTok{$}\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    8   13
[2,]   11   16
\end{verbatim}

Finalmente, consideremos la situación en la cual queremos aplicarle la misma función a cada uno de los elementos que integran una lista. Para esto podemos usar \texttt{lapply()} o \texttt{sapply()}, parientes de la función \texttt{apply()} que vimos antes. Por ejemplo, tenemos una lista con varios vectores y queremos saber el largo de cada uno de ellos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mi\_lista }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{), }\AttributeTok{y =} \FunctionTok{c}\NormalTok{(}\StringTok{"uno"}\NormalTok{, }\StringTok{"dos"}\NormalTok{, }\StringTok{"tres"}\NormalTok{), }\AttributeTok{z =} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\NormalTok{mi\_lista}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
$x
[1]  1  8  9 -1

$y
[1] "uno"  "dos"  "tres"

$z
[1] 3 2
\end{verbatim}

Podemos ver el largo de cada elemento de la lista, uno por uno:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(mi\_lista}\SpecialCharTok{$}\NormalTok{x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(mi\_lista}\SpecialCharTok{$}\NormalTok{y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(mi\_lista}\SpecialCharTok{$}\NormalTok{z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2
\end{verbatim}

O podemos hacerlo así:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{lapply}\NormalTok{(mi\_lista, length)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
$x
[1] 4

$y
[1] 3

$z
[1] 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sapply}\NormalTok{(mi\_lista, length)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
x y z 
4 3 2 
\end{verbatim}

Ambas funciones le aplican la función elegida como segundo argumento (\texttt{length()}) a cada elemento de la lista indicada en el primer argumento (\texttt{mi\_lista}). La diferencia entre ellas es que \texttt{lapply()} devuelve una nueva lista con los resultados, mientras que \texttt{sapply()} los devuelve acomodados en un vector\footnote{Los ejemplos presentado aquí son muy generales. Dependiendo del tipo de estructura de datos a considerar y de la función a aplicar, la forma en que se presentan los resultados al aplicar alguna de estas funciones puede variar, pero por ahora eso no importa.}.

\textbf{Ejemplo: función que devuelve una lista}

En el capítulo anterior, dijimos que las funciones son subalgoritmos que podían devolver exactamente un objeto como resultado. Esto puede ser una limitación, ya que en algunos casos tal vez necesitemos devolver varios elementos de distinto tipo
\footnote{Si fuesen elementos del mismo tipo, los podríamos devolver dentro de un vector, por ejemplo, las dos soluciones reales distintas de una ecuación cuadrática.}
.
La solución consiste en devolver una lista que englobe a todos los objetos que nos interese que la función le entregue como resultado al algoritmo principal que la invocó. Como una lista es un único objeto, ¡la función puede devolverla sin ningún problema!

Para ejemplificar, recordemos el siguiente ejercicio de la práctica 3: escribir un programa para la creación de la función \texttt{triangulos(a,\ b,\ c)} que a partir de la longitud de los tres lados de un triángulo \texttt{a}, \texttt{b} y \texttt{d} (valores positivos) lo clasifica con los siguientes resultados posibles: no forman un triángulo (un lado mayor que la suma de los otros dos), triángulo equilátero, isósceles o escaleno. Vamos a modificar la función para que tenga el siguiente comportamiento: la función debe devolver el tipo de triángulo como cadena de texto y el valor numérico del perímetro del mismo (o un 0 si no es triángulo). Es decir, la función debe devolver tanto un objeto de tipo carácter y otro de tipo numérico. Para lograrlo los encerraremos en una lista:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{\# Función triangulos}
\CommentTok{\# Clasifica un triángulo según la longitud de sus lados}
\CommentTok{\# Entrada:}
\CommentTok{\#       {-} a, b, d, números reales positivos}
\CommentTok{\# Salida:}
\CommentTok{\#       {-} una lista cuyo primer elemento es un carácter que indica el tipo de}
\CommentTok{\#       triángulo y cuyo segundo elemento es el perímetro del triángulo o el valor 0}
\CommentTok{\#       si los lados provistos no corresponden a un triángulo}
\CommentTok{\#{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\NormalTok{triangulos }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(a, b, d) \{}
\NormalTok{    perimetro }\OtherTok{\textless{}{-}}\NormalTok{ a }\SpecialCharTok{+}\NormalTok{ b }\SpecialCharTok{+}\NormalTok{ d}
    \ControlFlowTok{if}\NormalTok{ (a }\SpecialCharTok{\textgreater{}}\NormalTok{ b }\SpecialCharTok{+}\NormalTok{ d }\SpecialCharTok{||}\NormalTok{ b }\SpecialCharTok{\textgreater{}}\NormalTok{ a }\SpecialCharTok{+}\NormalTok{ d }\SpecialCharTok{||}\NormalTok{ d }\SpecialCharTok{\textgreater{}}\NormalTok{ a }\SpecialCharTok{+}\NormalTok{ b) \{}
\NormalTok{        tipo }\OtherTok{\textless{}{-}} \StringTok{"no es triángulo"}
\NormalTok{        perimetro }\OtherTok{\textless{}{-}} \DecValTok{0}
\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (a }\SpecialCharTok{==}\NormalTok{ b }\SpecialCharTok{\&}\NormalTok{ a }\SpecialCharTok{==}\NormalTok{ d) \{}
\NormalTok{        tipo }\OtherTok{\textless{}{-}} \StringTok{"equilátero"}
\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (a }\SpecialCharTok{==}\NormalTok{ b }\SpecialCharTok{||}\NormalTok{ a }\SpecialCharTok{==}\NormalTok{ d }\SpecialCharTok{||}\NormalTok{ b }\SpecialCharTok{==}\NormalTok{ d) \{}
\NormalTok{        tipo }\OtherTok{\textless{}{-}} \StringTok{"isósceles"}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        tipo }\OtherTok{\textless{}{-}} \StringTok{"escaleno"}
\NormalTok{    \}}
    \FunctionTok{return}\NormalTok{(}\FunctionTok{list}\NormalTok{(}\AttributeTok{tipo =}\NormalTok{ tipo, }\AttributeTok{perimetro =}\NormalTok{ perimetro))}
    \CommentTok{\# atención con tipo = tipo: la primera vez es el nombre que le estamos dando}
    \CommentTok{\# al elemento de la lista, la segunda vez es la variable que guardamos en la lista}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Ejemplos del uso de esta función:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Guardamos el resultado devuelto (una lista) en el objeto resultado}
\NormalTok{resultado }\OtherTok{\textless{}{-}} \FunctionTok{triangulos}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\CommentTok{\# Miramos el primer elemento de la lista (carácter que indica el tipo)}
\NormalTok{resultado[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "escaleno"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{resultado}\SpecialCharTok{$}\NormalTok{tipo}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "escaleno"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Miramos el primer elemento de la lista (perímetro)}
\NormalTok{resultado[[}\DecValTok{2}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{resultado}\SpecialCharTok{$}\NormalTok{perimetro}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Miramos todo junto}
\NormalTok{resultado}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
$tipo
[1] "escaleno"

$perimetro
[1] 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Otro ejemplo:}
\NormalTok{resultado2 }\OtherTok{\textless{}{-}} \FunctionTok{triangulos}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{resultado2[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "no es triángulo"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{resultado2[[}\DecValTok{2}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 0
\end{verbatim}

\hypertarget{otras-consideraciones-lectura-opcional}{%
\section{Otras consideraciones (lectura opcional)}\label{otras-consideraciones-lectura-opcional}}

Dependiendo de cómo se almacenan los datos que componen a una estructura en el \emph{hardware} de la computadora, las mismas se pueden clasificar en \textbf{contiguas} o \textbf{enlazadas}. En las estructuras contiguas, los datos se sitúan en áreas adyacentes de memoria y cada uno de ellos se puede localizar partiendo de la posición en memoria del primer elemento de la estructura. En las estructuras enlazadas, los datos no se sitúan necesariamente de forma continua en la memoria sino que existen \emph{punteros} (otro tipo de dato que \emph{apunta} hacia determinada posición de memoria) que permite identificar cuál es el orden de los elementos dentro de la estructura.

Por otro lado, las estructuras también se pueden clasificar en \textbf{dinámicas} o \textbf{estáticas}, según si su tamaño puede cambiar o no durante la ejecución de un programa, respectivamente. Cuando se emplea una estructura estática, se declara con anterioridad el tamaño que ocupará en memoria y su dimensión no podrá variar, aún cuando no se ocupen todas las posiciones reservadas. En contraposición, una estructura dinámica puede cambiar en tamaño.

Antes se mencionó que las listas de R pueden contener objetos de distintos tipos. Para ser más rigurosos, una lista es un tipo especial de vector que agrupa punteros hacia distintos objetos. Técnicamente, todos los elementos de una lista son del mismo tipo (punteros), pero hacen referencia a distintos objetos, dándonos la impresión de que en una lista de R, sencillamente, podemos meter cualquier tipo de objeto.

\hypertarget{arreglos-multidimensionales-lectura-opcional}{%
\section{Arreglos multidimensionales (lectura opcional)}\label{arreglos-multidimensionales-lectura-opcional}}

Un \textbf{arreglo multidimensional} contiene más de dos dimensiones, es decir, requiere más de dos índices para identificar a cada uno de sus elementos. La representación matemática o visual ya no es tan sencilla como la de los vectores o matrices. Para interpretarlos o saber cuándo usarlos, pensamos que cada una de las dimensiones representa una característica de los elementos.

Por ejemplo, imaginemos que en un local comercial se quiere registrar cuántos clientes se atendieron en cada una de las tres cajas disponibles (primer dimensión del arreglo: caja 1, caja 2 o caja 3), ya sea en el turno mañana o tarde (segunda dimensión: 1 para la mañana o 2 para la tarde) en cada día hábil de una semana (tercera dimensión: 1 lunes, 2 martes, 3 miércoles, 4 jueves o 5 viernes). Si queremos registrar, por ejemplo, que la caja 1 en el turno tarde del día jueves atendió 12 clientes, tenemos que guardar el valor 12 en la posición {[}1, 2, 4{]} del arreglo.

El arreglo de 3 dimensiones que permite acomodar toda la información del ejemplo en una sola estructura puede definirse en R así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{clientes }\OtherTok{\textless{}{-}} \FunctionTok{array}\NormalTok{(}\DecValTok{0}\NormalTok{, }\AttributeTok{dim =} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\NormalTok{clientes}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
, , 1

     [,1] [,2]
[1,]    0    0
[2,]    0    0
[3,]    0    0

, , 2

     [,1] [,2]
[1,]    0    0
[2,]    0    0
[3,]    0    0

, , 3

     [,1] [,2]
[1,]    0    0
[2,]    0    0
[3,]    0    0

, , 4

     [,1] [,2]
[1,]    0    0
[2,]    0    0
[3,]    0    0

, , 5

     [,1] [,2]
[1,]    0    0
[2,]    0    0
[3,]    0    0
\end{verbatim}

Luego, si queremos registrar que la caja 1 en el turno tarde del día jueves atendió 12 clientes, hacemos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{clientes[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{] }\OtherTok{\textless{}{-}} \DecValTok{12}
\NormalTok{clientes}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
, , 1

     [,1] [,2]
[1,]    0    0
[2,]    0    0
[3,]    0    0

, , 2

     [,1] [,2]
[1,]    0    0
[2,]    0    0
[3,]    0    0

, , 3

     [,1] [,2]
[1,]    0    0
[2,]    0    0
[3,]    0    0

, , 4

     [,1] [,2]
[1,]    0   12
[2,]    0    0
[3,]    0    0

, , 5

     [,1] [,2]
[1,]    0    0
[2,]    0    0
[3,]    0    0
\end{verbatim}

En R, podemos ponerle un nombre a cada una de las dimensiones del arreglo (``caja'', ``turno'', ``dia''), para poder identificar mejor a qué aspecto hace referencia y, a su vez, un nombre a cada una de sus modalidades (por ejemplo, ``caja 1'', ``caja 2'' o ``caja 3''). Esto se logra de la siguiente forma:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dimnames}\NormalTok{(clientes) }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{caja =} \FunctionTok{c}\NormalTok{(}\StringTok{"caja 1"}\NormalTok{, }\StringTok{"caja 2"}\NormalTok{, }\StringTok{"caja 3"}\NormalTok{),}
                           \AttributeTok{turno =} \FunctionTok{c}\NormalTok{(}\StringTok{"mañana"}\NormalTok{, }\StringTok{"tarde"}\NormalTok{),}
                           \AttributeTok{dia =} \FunctionTok{c}\NormalTok{(}\StringTok{"lun"}\NormalTok{, }\StringTok{"mar"}\NormalTok{, }\StringTok{"mie"}\NormalTok{, }\StringTok{"jue"}\NormalTok{, }\StringTok{"vie"}\NormalTok{))}
\NormalTok{clientes}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
, , dia = lun

        turno
caja     mañana tarde
  caja 1      0     0
  caja 2      0     0
  caja 3      0     0

, , dia = mar

        turno
caja     mañana tarde
  caja 1      0     0
  caja 2      0     0
  caja 3      0     0

, , dia = mie

        turno
caja     mañana tarde
  caja 1      0     0
  caja 2      0     0
  caja 3      0     0

, , dia = jue

        turno
caja     mañana tarde
  caja 1      0    12
  caja 2      0     0
  caja 3      0     0

, , dia = vie

        turno
caja     mañana tarde
  caja 1      0     0
  caja 2      0     0
  caja 3      0     0
\end{verbatim}

Para situaciones como la anterior, resulta más útil guardar los valores en otros tipos de estructuras especializadas en conjuntos de datos, como veremos más adelante. Por esta razón, en esta asignatura no profundizaremos en el estudio de arreglos multidimensionales y nos bastaremos con vectores y matrices. Sin embargo, debemos saber de su existencia porque son estructuras útiles para ciertas tareas de programación.

\hypertarget{uso-de-archivos-de-datos}{%
\chapter{Uso de archivos de datos}\label{uso-de-archivos-de-datos}}

\hypertarget{introducciuxf3n}{%
\section{Introducción}\label{introducciuxf3n}}

Como hemos visto, los programas usan variables para guardar información: datos de entrada, resultados calculados, valores intermedios, etc. Sin embargo, la información guardada en las variables es efímera. Cuando los programas paran de correr, el valor almacenado en las variables se pierde. En muchas ocasiones, es necesario guardar información de una forma más permanente.

En estos casos, el enfoque usual es recolectar la información en un todo lógicamente cohesivo y guardarlo en un medio permanente que generalmente se graba en el disco rígido de la máquina, es decir, en un archivo. Un \textbf{archivo} o \textbf{fichero} es un conjunto de datos sobre un mismo tema tratado como una unidad de almacenamiento y organizado de forma estructurada para la búsqueda de un dato individual. Los archivos pueden contener instrucciones de programas o información creada o usada por un programa. Todos los objetos de datos permanentes que guardamos en nuestra computadora (documentos, juegos, programas ejecutables, código, etc.) son guardados en la forma de archivos.

Un archivo se identifica con un \textbf{nombre}, seguido por un \emph{punto} y una \textbf{extensión}, la cual es un sufijo empleado para indicar características de su contenido, el uso pretendido o el software con el cual puede ser empleado. Por ejemplo, un archivo que se llama \emph{planilla.xlsx} es una hoja de cálculo de Excel o un archivo llamado \emph{codigo.R} es un script de código de R.

\hypertarget{registros-campos-claves-y-bases-de-datos}{%
\subsection{Registros, campos, claves y bases de datos}\label{registros-campos-claves-y-bases-de-datos}}

En esta asignatura nos limitaremos a trabajar con archivos que guardan datos de forma tabular, en los que la unidad elemental que los compone es un \textbf{registro}, es decir, una colección de datos relativa a una misma entidad. En general, cada registro de un mismo archivo tiene la misma estructura que los demás. Los datos individuales sobre dicha entidad se organizan en \textbf{campos}. Un \textbf{campo} es la mínima unidad de información de un registro.

Para ejemplificar, trabajaremos con un archivo llamado \emph{mundiales.txt} que tiene datos sobre todos los mundiales de fútbol de la FIFA, incluyendo el del año 2022, en el cual nuestra selección argentina conquistó su tercer título. Cada fila del conjunto de datos corresponde a un país y cada columna hace referencia a las siguientes variables\footnote{Los partidos definidos en tiempo complementario se cuentan como victorias y derrotas, mientras que los partidos definidos por tandas de penales se cuentan como empates.}:

\begin{verbatim}
ARCHIVO: mundiales.txt
Campo 1 - seleccion: nombre del país, tipo carácter
Campo 2 - continente: continente al que pertenece el país, tipo carácter
Campo 3 - participaciones: cantidad de mundiales jugados, tipo numérico
Campo 4 - pg: cantidad de partidos ganados, tipo numérico
Campo 5 - pe: cantidad de partidos empatados, tipo numérico
Campo 6 - pp: cantidad de partidos perdidos, tipo numérico
Campo 7 - gf: cantidad de goles a favor, tipo numérico
Campo 8 - gc: cantidad de goles en contra, tipo numérico
Campo 9 - titulo: cantidad de mundiales ganados, tipo numérico
\end{verbatim}

Este archivo tiene 80 registros, ya que son 80 países los que han disputado algún mundial a lo largo de la historia. Los primeros registros lucen así:

\begin{longtable}[]{@{}
  >{\centering\arraybackslash}p{(\columnwidth - 16\tabcolsep) * \real{0.1549}}
  >{\centering\arraybackslash}p{(\columnwidth - 16\tabcolsep) * \real{0.1690}}
  >{\centering\arraybackslash}p{(\columnwidth - 16\tabcolsep) * \real{0.2394}}
  >{\centering\arraybackslash}p{(\columnwidth - 16\tabcolsep) * \real{0.0563}}
  >{\centering\arraybackslash}p{(\columnwidth - 16\tabcolsep) * \real{0.0563}}
  >{\centering\arraybackslash}p{(\columnwidth - 16\tabcolsep) * \real{0.0563}}
  >{\centering\arraybackslash}p{(\columnwidth - 16\tabcolsep) * \real{0.0704}}
  >{\centering\arraybackslash}p{(\columnwidth - 16\tabcolsep) * \real{0.0704}}
  >{\centering\arraybackslash}p{(\columnwidth - 16\tabcolsep) * \real{0.1268}}@{}}
\toprule()
\begin{minipage}[b]{\linewidth}\centering
seleccion
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
continente
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
participaciones
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
pg
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
pe
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
pp
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
gf
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
gc
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
titulos
\end{minipage} \\
\midrule()
\endhead
Brasil & América & 22 & 76 & 19 & 19 & 237 & 108 & 5 \\
Alemania & Europa & 20 & 68 & 21 & 23 & 232 & 130 & 4 \\
Argentina & América & 18 & 47 & 17 & 24 & 152 & 101 & 3 \\
Italia & Europa & 18 & 45 & 21 & 17 & 128 & 77 & 4 \\
Francia & Europe & 16 & 39 & 14 & 20 & 136 & 85 & 2 \\
\bottomrule()
\end{longtable}

Un campo está caracterizado por el tipo de datos que almacena (carácter, numérico, lógico) y en algunos contextos es necesario precisar su longitud (por ejemplo, cantidad de caracteres admitidos como máximo en los datos del campo). Algunos lenguajes, como R, admiten trabajar con campos de longitud variable (sin necesidad de que sea especificada con anticipación).

En el contexto del análisis de datos, cada columna o \emph{campo} en este tipo de archivos puede representar una variable observada sobre los individuos o unidades de interés, los cuales se encuentran dispuestos en las sucesivas filas.

Generalmente suele ser necesario identificar de manera única a cada registro de un archivo. Para esto suele considerarse a uno de los campos del archivo como el \textbf{campo clave} o, más sencillamente, \textbf{clave}. La \textbf{clave} o \emph{key} es el campo que identifica inequívocamente a cada registro, permitiendo diferenciarlo del resto, como podría ser el nombre de la selección en el ejemplo anterior. En ocasiones donde no hay un campo \emph{clave} es posible identificar un registro a través de la combinación de los valores presentes en más de uno de los campos.

Por último, cabe mencionar que llamamos \textbf{base de datos} a un conjunto de archivos que contienen datos relacionados entre sí, vinculados mediante sistemas complejos que enlazan las claves de uno y otro archivo y que pueden ser consultados mediante el uso de software especializado. Por eso, cuando trabajamos con los datos almacenados en un único archivo, es conveniente referirse a los mismos como ``conjunto de datos'' y no como ``base de datos''.

\hypertarget{organizaciuxf3n-de-archivos}{%
\subsection{Organización de archivos}\label{organizaciuxf3n-de-archivos}}

Existen distintos tipos de organización de los archivos según la forma en la que se pueda acceder a cada uno de sus registros:

\begin{itemize}
\item
  \textbf{Organización secuencial}

  Los registros se encuentran en cierto orden que debe ser respetado para la lectura de los mismos. Para leer el registro situado en la posición \emph{n}, el programa previamente tiene que pasar por los \emph{n-1} registros que ocupan las posiciones anteriores.

  Los archivos de tipo secuencial en general ocupan menos memoria y suelen ser utilizados para guardar contenidos que sufren pocas modificaciones. Los registros se graban consecutivamente en el soporte que los aloja (por ejemplo, en el disco). El orden físico con el que fueron escritos los registros coincide con el orden de lectura de los mismos.

  Los registros pueden leerse uno por uno hasta llegar al final del archivo, donde se indica de alguna manera el fin del mismo, muchas veces a través de un caracter especial como un asterisco o de una línea en blanco. Esta marca generalmente se conoce como \emph{EOF} (\emph{end of file}). La mayoría de los lenguajes de programación disponen de una función lógica que devuelve un valor \texttt{VERDADERO} cuando se alcanza el final del archivo.
\item
  \textbf{Organización directa}

  Son archivos que están organizados de manera que se pueda acceder de forma directa a cada registro mediante su posición en el soporte físico que lo contiene, sin tener que pasar secuencialmente por los registros anteriores. Poseen la ventaja de brindar un acceso rápido a la información y la posibilidad de leer y escribir registros en cualquier posición y orden.

  Se puede mencionar como desventaja de este tipo de organización el hecho de que requiere la programación de la forma de identificar la posición de un registro a partir de alguno de los valores de sus campos, generalmente, la \emph{clave}. Esto se hace mediante un algoritmo de transformación de la clave (llamado \emph{hash function}) que a partir de la misma devuelve la dirección del registro en el soporte físico. El archivo debe diseñarse teniendo en cuenta de antemano una cantidad total de registros fija.
\item
  \textbf{Organización indexada}

  Los archivos están estructurados de manera que los registros se pueden localizar sin pasar por los anteriores, consultando en una tabla adicional de índices la zona del archivo donde se encuentra el registro buscado. Esto permite localizar un registro por medio de su clave o del valor de algún campo en particular.

  Para imaginarnos esto, podemos pensar que un diccionario es un ejemplo de un archivo indexado, ya que podemos encontrar la región donde se encuentra un registro (palabra) mediante el índice de letras. Si queremos buscar el término ``programación'' en un diccionario, no recorremos todas las palabras del mismo desde la ``A'' hasta encontrar el término de interés, sino que buscamos en el índice en qué página del diccionario se encuentra la ``P'' y comenzamos una búsqueda secuencial desde la misma.

  Un archivo indexado, entonces, cuenta en realidad con dos archivos, uno de índices (que se recorre de forma secuencial) y otro con los registros propiamente dichos. Posee la ventaja de brindar un rápido acceso a los registros, pero con el costo de utilizar espacio adicional para la tabla de índices.
\end{itemize}

La organización más sencilla y más comúnmente empleada es la \textbf{secuencial}, aunque en algunos casos puede no ser la más eficiente. Si bien no todos los lenguajes de programación permiten el trabajo con archivos indexados o de organización directa, todos pueden manejar archivos secuenciales.

En esta asignatura no profundizaremos en esta distinción y trabajaremos con archivos guardados como documentos de Excel (extensión \emph{.xlsx}) o archivos de texto (extensión \emph{.txt} o \emph{.csv}), los cuales siguen una organización secuencial.

Un \textbf{archivo de texto} (también conocido como \emph{texto llano} o \emph{texto simple}) es un archivo informático que contiene únicamente texto formado por una secuencia ordenada de caracteres. El texto almacenado en este tipo de archivo carece de cualquier tipo de formato tipográfico (negrita, cursiva, colores, subrayado, fuente, etc.), lo cual permite que una gran variedad de programas pueda leer y editar el contenido. Cada renglón en el archivo de texto es un registro y los distintos campos suelen estar señalizados con tabulaciones (archivos \emph{.txt}, como el que usaremos de ejemplo, \emph{mundiales.txt}) o separados por comas o punto y comas (archivos \emph{.csv}).

Los archivos de texto están compuestos por caracteres ordinarios, como las letras, números y signos de puntuación, y por caracteres especiales que indican, por ejemplo, saltos de línea (\texttt{\textbackslash{}n}) y tabulaciones (\texttt{\textbackslash{}t}). Pero como en realidad las computadoras solamente entienden números, cada carácter es codificado internamente con una representación numérica binaria, que nosotros nunca llegamos a ver. Distintas maneras de hacer esta representación dan lugar a diferentes formatos de codificación de caracteres (como \emph{ASCII}, \emph{ISO-8859-1} o \emph{UTF-8}). Si en alguna oportunidad abrimos un archivo y nos percatamos que caracteres como la ``ñ'' o las tildes han sido reemplazadas por otros produciendo un aspecto ``raro'', significa que el archivo ha sido abierto empleando una codificación diferente de la que se utilizó al crear el archivo. La solución para este problema es muy sencilla, sólo hay que cambiar la opción de codificación a la hora de guardar o de abrir el archivo.

\hypertarget{operaciones-sobre-archivos}{%
\subsection{Operaciones sobre archivos}\label{operaciones-sobre-archivos}}

El uso de archivos en programación es muy importante ya que nos permite leer datos para hacer algún tipo de procesamiento y también guardar resultados obtenidos. El sistema operativo de la computadora es el que se encarga de manipular los archivos para que podamos leerlos o escribir en ellos, pero debemos aprender las sentencias que el lenguaje de programación elegido utiliza para encargarle esas tareas al sistema operativo. Los procedimientos básicos que los programas pueden llevar a cabo sobre los distintos tipos de archivos son:

\begin{itemize}
\item
  \textbf{Creación de un archivo}: para que un archivo pueda ser utilizado, antes tiene que existir, obviamente. Una vez que el archivo de datos fue creado y existe, se pueden hacer con él las restantes operaciones. En la mayoría de las aplicaciones que veremos, tendremos archivos que han sido creados con anterioridad y ya tienen registros, por lo cual usaremos pocas veces esta acción, pero eventualmente crearemos nuevos archivos para guardar nuevas versiones del conjunto de datos o para guardar resultados en otro tipo de documento.
\item
  \textbf{Apertura de un archivo}: para que un programa pueda operar sobre un archivo, la primera acción que debe realizar es la \textbf{apertura} del mismo, que incluye la identificación del archivo a utilizar y el modo (lectura o escritura). Esto hace que el sistema operativo establezca una \emph{conexión} con el archivo que mientras se mantenga activa permitirá la lectura y escritura de registros en el mismo. Dependiendo del lenguaje de programación o de las subsiguientes operaciones a realizar, en algunos casos la apertura tiene que ser indicada con alguna instrucción de manera explícita y en otros, no.
\item
  \textbf{Lectura de registros en un archivo}: la \textbf{lectura} consiste en transferir información del archivo a la memoria principal usada por el programa. En los archivos de organización secuencial, los registros se leen uno por uno, es decir, línea por línea, hasta llegar al final del archivo. Sin embargo, en la aplicaciones que nos interesan, el software se encarga de leer automáticamente todos los registros y almacenarlos en alguna estructura de datos especializada que definamos en el ambiente de trabajo.
\item
  \textbf{Escritura en un archivo}: la \textbf{escritura} es la transferencia de información guardada en las variables del programa al archivo.
\item
  \textbf{Cierre de un archivo}: cuando un programa no vaya a acceder más a un archivo, es necesario indicarlo a través del \textbf{cierre} del mismo, para que se interrumpa la conexión establecida por el sistema operativo. Esto hace que se liberen memoria y recursos del sistema, se prevenga la corrupción de los datos y se exprese explícitamente que ya no se hará más uso del mismo. En algunos lenguajes o para determinadas tareas, esto puede no ser necesario.
\item
  \textbf{Otras operaciones}: otras operaciones que se pueden realizar sobre los archivos, en base a combinaciones de las anteriores, incluyen a las acciones de:

  \begin{itemize}
  \tightlist
  \item
    \emph{Actualización}: añadir (dar de alta), modificar o eliminar (dar de baja) algún registro.
  \item
    \emph{Clasificación}: reubicar los registros de tal forma que queden ordenados por algún campo determinado.
  \item
    \emph{Fusión o mezcla}: combinar dos o más archivos para formar uno nuevo.
  \item
    \emph{Partición}: subdividir los registros por el valor que toman en algún campo para generar más de un archivo.
  \end{itemize}
\end{itemize}

\hypertarget{lectura-de-los-registros-del-archivo}{%
\section{Lectura de los registros del archivo}\label{lectura-de-los-registros-del-archivo}}

Ya hemos mencionado que R se organiza mediante un sistema de paquetes, algunos de los cuales vienen instalados con la distribución básica de R, mientras que otros deben ser instalados si tenés el particular interés de usarlos. R Base trae muchas funciones útiles para la importación de datos, así como para las subsiguientes tareas de manejo, transformación y resumen. Sin embargo, en esta asignatura aprenderemos a emplear una familia de paquetes conocida como \href{https://www.tidyverse.org}{\textbf{tidyverse}}, creados para la manipulación, exploración y visualización de datos con un diseño, estructuras y reglas de uso en común, que resultan muy amigables para programar.

\begin{center}\includegraphics[width=0.7\linewidth]{images/06_archivos/tidyverse} \end{center}

Instalamos esta colección de paquetes con:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"tidyverse"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Lo anterior se realiza una sola vez. Luego, cada vez que queramos usar este sistema, usamos \texttt{library()} para que queden a nuestra disposición las funciones provistas por los paquetes más importantes de esta gran familia:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\end{Highlighting}
\end{Shaded}

El \emph{tidyverse} provee una función de uso muy sencillo para leer datos guardados en un archivo de texto con campos separados por tabulaciones, como es el caso de \texttt{mundiales.txt}. En \href{https://github.com/mpru/introprog/tree/master/archivos}{este enlace} o en el aula virtual podrás encontrar el archivo de datos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{read\_delim}\NormalTok{(}\StringTok{"mundiales.txt"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Si tenemos que importar otro tipo de archivo (por ejemplo, de Excel o de texto separado con comas) y no nos acordamos cuál es la función que permite hacerlo, podemos recurrir al menú de importación de datos mediante el botón \texttt{Import\ Dataset} en el panel \texttt{Environment} de RStudio (arriba a la derecha). Ahí podremos elegir distintas opciones para la importación y automáticamente se generará y ejecutará el código de R necesario, el cual debemos copiar y pegar en nuestro \emph{script} para dejar sentado cómo se realizó la importación.

\begin{center}\includegraphics[width=0.3\linewidth]{images/06_archivos/importar1} \end{center}

Una vez completado este paso, en el ambiente podremos ver listado un nuevo objeto llamado \texttt{datos}, ya que ese es el nombre que elegimos como identificador para el conjunto de datos devuelto por la función \texttt{read\_delim()}. Allí también vemos una breve descripción que nos dice que \texttt{datos} tiene 80 observaciones (registros) de 9 variables (campos). Si hacemos clic sobre el nombre del objeto se abrirá una pestaña para que podamos explorar su contenido. Entonces\ldots{} ¿qué tipo de objeto es \texttt{datos}?:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(datos)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "spec_tbl_df" "tbl_df"      "tbl"         "data.frame" 
\end{verbatim}

Hasta ahora habíamos trabajado con tres tipos de datos básicos: numérico, carácter y lógico, y habíamos visto que con los mismos podíamos crear estructuras de datos como vectores, matrices o listas. Como indica la salida anterior, el objeto \texttt{datos} es de tipo \emph{data.frame}, lo cual significa que es una estructura de datos bidimensional (como una matriz) en la cual cada fila representa a un registro y cada columna representa a uno de los campos del archivo, pudiendo entonces almacenar valores de distinto tipo en cada una de ellas (a diferencia de los arreglos, cuyos valores son todos homogéneos)\footnote{Internamente, un \emph{data.frame} es sencillamente una lista, compuesta por vectores de distinto tipo que tienen todos el mismo largo y que se organizan como columnas. Además, esta lista es almacenada junto con cierta información adicional (\emph{atributos}) que nos permiten manipularla como una estructura tabular.}.

Existen algunas funciones de R que nos permiten explorar el contenido de un \emph{data.frame}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Muestra los nombres de las columnas (campos del archivo)}
\FunctionTok{names}\NormalTok{(datos)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "seleccion"       "continente"      "participaciones" "pg"             
[5] "pe"              "pp"              "gf"              "gc"             
[9] "titulos"        
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Muestra la "estructura" interna del dataset}
\FunctionTok{str}\NormalTok{(datos)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
spc_tbl_ [80 x 9] (S3: spec_tbl_df/tbl_df/tbl/data.frame)
 $ seleccion      : chr [1:80] "Brasil" "Alemania" "Argentina" "Italia" ...
 $ continente     : chr [1:80] "América" "Europa" "América" "Europa" ...
 $ participaciones: num [1:80] 22 20 18 18 16 16 16 11 14 14 ...
 $ pg             : num [1:80] 76 68 47 45 39 32 31 30 25 21 ...
 $ pe             : num [1:80] 19 21 17 21 14 22 17 14 13 10 ...
 $ pp             : num [1:80] 19 23 24 17 20 20 19 11 21 20 ...
 $ gf             : num [1:80] 237 232 152 128 136 104 108 96 89 69 ...
 $ gc             : num [1:80] 108 130 101 77 85 68 75 52 76 74 ...
 $ titulos        : num [1:80] 5 4 3 4 2 1 1 0 2 0 ...
 - attr(*, "spec")=
  .. cols(
  ..   seleccion = col_character(),
  ..   continente = col_character(),
  ..   participaciones = col_double(),
  ..   pg = col_double(),
  ..   pe = col_double(),
  ..   pp = col_double(),
  ..   gf = col_double(),
  ..   gc = col_double(),
  ..   titulos = col_double()
  .. )
 - attr(*, "problems")=<externalptr> 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Muestra la cantidad de filas y columnas}
\FunctionTok{dim}\NormalTok{(datos)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 80  9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Muestra la cantidad de filas}
\FunctionTok{nrow}\NormalTok{(datos)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 80
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Muestra la cantidad de columnas}
\FunctionTok{ncol}\NormalTok{(datos)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Muestra los primeros registros}
\FunctionTok{head}\NormalTok{(datos)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 6 x 9
  seleccion  continente participaciones    pg    pe    pp    gf    gc titulos
  <chr>      <chr>                <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>   <dbl>
1 Brasil     América                 22    76    19    19   237   108       5
2 Alemania   Europa                  20    68    21    23   232   130       4
3 Argentina  América                 18    47    17    24   152   101       3
4 Italia     Europa                  18    45    21    17   128    77       4
5 Francia    Europe                  16    39    14    20   136    85       2
6 Inglaterra Europa                  16    32    22    20   104    68       1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Muestra los últimos registros}
\FunctionTok{tail}\NormalTok{(datos)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 6 x 9
  seleccion     continente participaciones    pg    pe    pp    gf    gc titulos
  <chr>         <chr>                <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>   <dbl>
1 Emiratos Ára~ asia                     1     0     0     3     2    11       0
2 China         asia                     1     0     0     3     0     9       0
3 Canadá        América                  2     0     0     6     2    12       0
4 Haití         América                  1     0     0     3     2    14       0
5 R. D. del Co~ África                   1     0     0     3     0    14       0
6 El Salvador   América                  2     0     0     6     1    22       0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Muestra un resumen de cada campo}
\FunctionTok{summary}\NormalTok{(datos)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  seleccion          continente        participaciones        pg        
 Length:80          Length:80          Min.   : 1.000   Min.   : 0.000  
 Class :character   Class :character   1st Qu.: 1.750   1st Qu.: 0.750  
 Mode  :character   Mode  :character   Median : 4.500   Median : 4.000  
                                       Mean   : 6.112   Mean   : 9.375  
                                       3rd Qu.: 9.000   3rd Qu.:12.000  
                                       Max.   :22.000   Max.   :76.000  
       pe              pp               gf            gc        
 Min.   : 0.00   Min.   : 1.000   Min.   :  0   Min.   :  2.00  
 1st Qu.: 1.00   1st Qu.: 3.000   1st Qu.:  4   1st Qu.: 11.00  
 Median : 3.00   Median : 7.500   Median : 15   Median : 24.50  
 Mean   : 5.35   Mean   : 9.375   Mean   : 34   Mean   : 34.00  
 3rd Qu.: 8.00   3rd Qu.:14.250   3rd Qu.: 43   3rd Qu.: 49.25  
 Max.   :22.00   Max.   :28.000   Max.   :237   Max.   :130.00  
    titulos     
 Min.   :0.000  
 1st Qu.:0.000  
 Median :0.000  
 Mean   :0.275  
 3rd Qu.:0.000  
 Max.   :5.000  
\end{verbatim}

Un \emph{data.frame} puede ser indexado de la misma forma empleada con matrices, por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Mostrar las filas 3 y 4, columnas 1 y 3}
\NormalTok{datos[}\DecValTok{3}\SpecialCharTok{:}\DecValTok{4}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 2 x 2
  seleccion participaciones
  <chr>               <dbl>
1 Argentina              18
2 Italia                 18
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Mostrar las filas 3 y 4, columnas "seleccion" y "participaciones"}
\NormalTok{datos[}\DecValTok{3}\SpecialCharTok{:}\DecValTok{4}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\StringTok{"seleccion"}\NormalTok{, }\StringTok{"participaciones"}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 2 x 2
  seleccion participaciones
  <chr>               <dbl>
1 Argentina              18
2 Italia                 18
\end{verbatim}

Para hacer referencia exclusivamente a una variable dentro del \emph{data.frame}, usamos el nombre del conjunto de datos, seguido por el operador \texttt{\$} y el nombre de la variable, por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos}\SpecialCharTok{$}\NormalTok{titulos}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] 5 4 3 4 2 1 1 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[39] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[77] 0 0 0 0
\end{verbatim}

Lo anterior resulta en un vector, con el que se pueden hacer operaciones como buscar el valor máximo si queremos saber cuál es la cantidad máxima de títulos alcanzada:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{max}\NormalTok{(datos}\SpecialCharTok{$}\NormalTok{titulos)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 5
\end{verbatim}

Si bien en los ejemplos anteriores vemos que en muchos aspectos los \emph{data.frames} son similares a las matrices, a partir de ahora vamos a ver cómo utilizar funciones que fueron especialmente pensadas para ayudarnos a transformar y explorar los conjuntos de datos que están guardados en objetos de tipo \emph{data.frame} y que simplifican muchas tareas relacionadas al análisis de datos.

\hypertarget{manejo-de-datos}{%
\section{Manejo de datos}\label{manejo-de-datos}}

\hypertarget{editar-o-crear-nuevas-variables}{%
\subsection{Editar o crear nuevas variables}\label{editar-o-crear-nuevas-variables}}

Es muy común tener que modificar una variable existente o añadir una nueva, la cual puede depender de algún cálculo realizado a partir de otras columnas presentes en el dataset. Para cualquiera de estas actividades que implican \emph{modificar} o \emph{mutar} el dataset, emplearemos la función \texttt{mutate()}. Vamos a calcular la cantitad total de partidos que cada selección ha jugado en los mundiales a lo largo de toda la historia (\texttt{pj}), sumando la cantidad de partidos que ha ganado, empatado y perdido:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(datos, }\AttributeTok{pj =}\NormalTok{ pg }\SpecialCharTok{+}\NormalTok{ pe }\SpecialCharTok{+}\NormalTok{ pp)}
\end{Highlighting}
\end{Shaded}

¿Qué sucedió al correr esa instrucción?:

\begin{itemize}
\tightlist
\item
  Como primer argumento de la función proveemos el dataset con el que vamos a operar, \texttt{datos}.
\item
  Elegimos en segundo lugar un nombre para una nueva variable, \texttt{pj}, y la definimos como la suma de otras variables ya existentes.
\item
  El resultado es el dataset original con esta modificación y lo guardamos con el mismo nombre. Si hubiésemos elegido otro nombre, generaríamos una copia del dataset con la modificación, mientras conservamos el original sin cambios.
\end{itemize}

Al editar variables, podemos elegir entre sobrescribir o no una columna existente, así como también entre sobrescribir o no el conjunto de datos de partida. Para pensar\ldots{} sin ejecutarlas, responder: ¿cuál es la diferencia entre las siguientes instrucciones?

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Sentencia (a)}
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(datos, }\AttributeTok{pj =}\NormalTok{ pg }\SpecialCharTok{+}\NormalTok{ pe }\SpecialCharTok{+}\NormalTok{ pp)}

\CommentTok{\# Sentencia (b)}
\NormalTok{datos\_modif }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(datos, }\AttributeTok{pj =}\NormalTok{ pg }\SpecialCharTok{+}\NormalTok{ pe }\SpecialCharTok{+}\NormalTok{ pp)}

\CommentTok{\# Sentencia (c)}
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(datos, }\AttributeTok{pg =}\NormalTok{ pg }\SpecialCharTok{+}\NormalTok{ pe }\SpecialCharTok{+}\NormalTok{ pp)}
\end{Highlighting}
\end{Shaded}

Otras situaciones requieren que en lugar de \emph{mutar} de la misma forma toda una columna, los cambios dependan de alguna condición que los registros verifiquen o no. Por ejemplo, agreguemos una nueva variable que indique si cada país es o no campeón del mundo, en función de los valores disponibles en la variable \texttt{titulos}. Vamos a crear una nueva columna que se llame \texttt{campeon} y tenga el valor ``campeón'' cuando \texttt{titulos\ \textgreater{}\ 0} y ``no campeón'' en caso contrario, ayudándonos con la función \texttt{ifelse()}, la cual nos permite establecer una evaluación lógica y dos cursos de acción, en base a que esta resulte verdadera (\texttt{TRUE}) o falsa (\texttt{FALSE}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(datos, }\AttributeTok{campeon =} \FunctionTok{ifelse}\NormalTok{(titulos }\SpecialCharTok{\textgreater{}} \DecValTok{0}\NormalTok{, }\StringTok{"campeón"}\NormalTok{, }\StringTok{"no campeón"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Inspeccionamos la nueva columna, recurriendo a otra función del \texttt{tidyverse}, \texttt{count()}. Sólo 8 países han ganado el mundial alguna vez (¡y Argentina es uno de ellos!):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{count}\NormalTok{(datos, campeon)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 2 x 2
  campeon        n
  <chr>      <int>
1 campeón        8
2 no campeón    72
\end{verbatim}

La función anterior es muy útil para chequear los valores guardados en atributos de tipo texto. Usémosla para inspeccionar la variable \texttt{continente}. ¿Hay algo que nos llame la atención?

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{count}\NormalTok{(datos, continente)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 7 x 2
  continente     n
  <chr>      <int>
1 América       20
2 Asia           7
3 Europa        19
4 Europe        14
5 Oceanía        2
6 asia           5
7 África        13
\end{verbatim}

Detectamos inconsistencias en la forma de registrar los nombres de los continentes: Europa aparece en inglés y en español, Asia aparece con mayúscula y con minúscula. Debemos homogeneizar la nomenclatura para poder hacer cualquier análisis válido. En este caso, en el cual la corrección implica sólo ``recodificar'' categorías, podemos usar la función \texttt{recode()} de forma muy sencilla. Aquellos registros con ``Europe'' en \texttt{continente} son reemplazados por ``Europa'', y lo mismo ocurre con ``asia'', que será reemplazado por ``Asia''. Los otros valores quedan como estaban:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(datos, }\AttributeTok{continente =} \FunctionTok{recode}\NormalTok{(continente, }\StringTok{"Europe"} \OtherTok{=} \StringTok{"Europa"}\NormalTok{, }\StringTok{"asia"} \OtherTok{=} \StringTok{"Asia"}\NormalTok{))}
\FunctionTok{count}\NormalTok{(datos, continente)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 5 x 2
  continente     n
  <chr>      <int>
1 América       20
2 Asia          12
3 Europa        33
4 Oceanía        2
5 África        13
\end{verbatim}

Ediciones que requieran evaluaciones lógicas más complejas pueden realizarse con la función \texttt{case\_when()}, que para cada fila del dataset realiza una evaluación lógica. Si resulta \texttt{TRUE}, devuelve el valor mencionado al lado del \texttt{\textasciitilde{}}. Si resulta \texttt{FALSE}, continúa evaluando la siguiente operación lógica.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(}
\NormalTok{    datos, }
    \AttributeTok{continente =} \FunctionTok{case\_when}\NormalTok{(}
\NormalTok{        continente }\SpecialCharTok{==} \StringTok{"Europe"} \SpecialCharTok{\textasciitilde{}} \StringTok{"Europa"}\NormalTok{,}
\NormalTok{        continente }\SpecialCharTok{==} \StringTok{"asia"} \SpecialCharTok{\textasciitilde{}} \StringTok{"Asia"}\NormalTok{,}
        \ConstantTok{TRUE} \SpecialCharTok{\textasciitilde{}}\NormalTok{ continente }\CommentTok{\# opción por defecto}
\NormalTok{        )}
\NormalTok{    )}
\end{Highlighting}
\end{Shaded}

Dejamos la siguiente propuesta para seguir practicando: agregar nuevas columnas en las que se muestre

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\item
  Crear una nueva variable llamada \texttt{puntos} que indique cuál es el puntaje total obtenido por cada selección a lo largo del tiempo, teniendo en cuenta que cada partido ganado aporta 3 puntos, cada partido empatado aporta 1 punto y cada partido perdido aporta 0 puntos.
\item
  Crear una nueva variable llamada \texttt{dg}, diferencia de goles, definida como la resta entre los goles a favor y los goles en contra.
\end{enumerate}

\emph{Sugerencia}: en \texttt{mutate()} podemos poner muchas modificaciones juntas, separándolas con coma.

\hypertarget{renombrar-atributos}{%
\subsection{Renombrar atributos}\label{renombrar-atributos}}

Para cambiar los nombres de una o más variables usamos la función \texttt{rename()}, listando los cambios con la estructura \texttt{nombre\_nuevo\ =\ nombre\_viejo}. Por ejemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 80 x 13
   seleccion    continente participaciones    pg    pe    pp    gf    gc titulos
   <chr>        <chr>                <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>   <dbl>
 1 Brasil       América                 22    76    19    19   237   108       5
 2 Alemania     Europa                  20    68    21    23   232   130       4
 3 Argentina    América                 18    47    17    24   152   101       3
 4 Italia       Europa                  18    45    21    17   128    77       4
 5 Francia      Europa                  16    39    14    20   136    85       2
 6 Inglaterra   Europa                  16    32    22    20   104    68       1
 7 España       Europa                  16    31    17    19   108    75       1
 8 Países Bajos Europa                  11    30    14    11    96    52       0
 9 Uruguay      América                 14    25    13    21    89    76       2
10 Bélgica      Europa                  14    21    10    20    69    74       0
# i 70 more rows
# i 4 more variables: pj <dbl>, campeon <chr>, puntos <dbl>, dg <dbl>
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{rename}\NormalTok{(datos, }\AttributeTok{goles\_favor =}\NormalTok{ gf, }\AttributeTok{goles\_contra =}\NormalTok{ gc)}
\NormalTok{datos}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 80 x 13
   seleccion    continente participaciones    pg    pe    pp goles_favor
   <chr>        <chr>                <dbl> <dbl> <dbl> <dbl>       <dbl>
 1 Brasil       América                 22    76    19    19         237
 2 Alemania     Europa                  20    68    21    23         232
 3 Argentina    América                 18    47    17    24         152
 4 Italia       Europa                  18    45    21    17         128
 5 Francia      Europa                  16    39    14    20         136
 6 Inglaterra   Europa                  16    32    22    20         104
 7 España       Europa                  16    31    17    19         108
 8 Países Bajos Europa                  11    30    14    11          96
 9 Uruguay      América                 14    25    13    21          89
10 Bélgica      Europa                  14    21    10    20          69
# i 70 more rows
# i 6 more variables: goles_contra <dbl>, titulos <dbl>, pj <dbl>,
#   campeon <chr>, puntos <dbl>, dg <dbl>
\end{verbatim}

\hypertarget{unir-o-separar-columnas}{%
\subsection{Unir o separar columnas}\label{unir-o-separar-columnas}}

En ocasiones puede ser necesario generar una nueva variable ``pegando'' o uniendo los datos presentes en otras. Imaginemos que tal vez necesitamos contar con una única variable textual que contenga tanto el nombre de la selección como el continente al que pertenece. Para esto recurrimos a la función \texttt{unite()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{unite}\NormalTok{(datos, }\AttributeTok{col =} \StringTok{"pais\_continente"}\NormalTok{, seleccion, continente, }\AttributeTok{sep =} \StringTok{" {-} "}\NormalTok{, }\AttributeTok{remove =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{datos}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 80 x 14
   pais_continente       seleccion  continente participaciones    pg    pe    pp
   <chr>                 <chr>      <chr>                <dbl> <dbl> <dbl> <dbl>
 1 Brasil - América      Brasil     América                 22    76    19    19
 2 Alemania - Europa     Alemania   Europa                  20    68    21    23
 3 Argentina - América   Argentina  América                 18    47    17    24
 4 Italia - Europa       Italia     Europa                  18    45    21    17
 5 Francia - Europa      Francia    Europa                  16    39    14    20
 6 Inglaterra - Europa   Inglaterra Europa                  16    32    22    20
 7 España - Europa       España     Europa                  16    31    17    19
 8 Países Bajos - Europa Países Ba~ Europa                  11    30    14    11
 9 Uruguay - América     Uruguay    América                 14    25    13    21
10 Bélgica - Europa      Bélgica    Europa                  14    21    10    20
# i 70 more rows
# i 7 more variables: goles_favor <dbl>, goles_contra <dbl>, titulos <dbl>,
#   pj <dbl>, campeon <chr>, puntos <dbl>, dg <dbl>
\end{verbatim}

La opción \texttt{remove\ =\ FALSE} hace que las columnas que se usaron para unir permanezcan en el dataset luego de este cambio. El comportamiento por defecto es eliminarlas. Si lo que nos interesa es separar en dos columnas información que esté concatenada en una sola, usamos la contrapartida, \texttt{separate()}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{separate}\NormalTok{(datos, }\AttributeTok{col =}\NormalTok{ pais\_continente, }\AttributeTok{into =} \FunctionTok{c}\NormalTok{(}\StringTok{"seleccion"}\NormalTok{, }\StringTok{"continente"}\NormalTok{), }\AttributeTok{sep =} \StringTok{" {-} "}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Por defecto estas funciones utilizan como separador cualquier carácter no alfanumérico que figure en ese campo, incluidos los espacios. El argumento \texttt{sep} se utiliza para indicar el separador adecuado cuando el establecido por defecto no es adecuado. La separación se podría hacer en más de dos columnas, de ser necesario, cuando el separador elegido aparece más de una vez.

\hypertarget{filtrar-y-ordenar-registros}{%
\subsection{Filtrar y ordenar registros}\label{filtrar-y-ordenar-registros}}

Podemos quedarnos sólo con los registros que cumplan con ciertas condiciones utilizando la función \texttt{filter()}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Una condición}
\NormalTok{datos\_america }\OtherTok{\textless{}{-}} \FunctionTok{filter}\NormalTok{(datos, continente }\SpecialCharTok{==} \StringTok{"América"}\NormalTok{)}
\FunctionTok{nrow}\NormalTok{(datos\_america)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 20
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Dos condiciones}
\NormalTok{datos\_campeones\_america }\OtherTok{\textless{}{-}} \FunctionTok{filter}\NormalTok{(datos, continente }\SpecialCharTok{==} \StringTok{"América"}\NormalTok{, campeon }\SpecialCharTok{==} \StringTok{"campeón"}\NormalTok{)}
\FunctionTok{nrow}\NormalTok{(datos\_campeones\_america)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Alternativa equivalente: filter(datos, continente == "América" \& campeon == "si")}

\CommentTok{\# Al menos una de las primeras condiciones ("o") y la segunda}
\NormalTok{datos\_filtro }\OtherTok{\textless{}{-}} \FunctionTok{filter}\NormalTok{(datos, continente }\SpecialCharTok{==} \StringTok{"América"} \SpecialCharTok{|}\NormalTok{ campeon }\SpecialCharTok{==} \StringTok{"campeón"}\NormalTok{, participaciones }\SpecialCharTok{\textgreater{}} \DecValTok{10}\NormalTok{)}
\FunctionTok{nrow}\NormalTok{(datos\_filtro)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 10
\end{verbatim}

Para ordenar los registros según el orden creciente o decreciente en una columna, podemos usar la función \texttt{arrange()}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Orden creciente:}
\FunctionTok{arrange}\NormalTok{(datos, puntos)}

\CommentTok{\# Orden decreciente:}
\FunctionTok{arrange}\NormalTok{(datos, }\FunctionTok{desc}\NormalTok{(puntos))}

\CommentTok{\# Ordenar según más de una variable:}
\FunctionTok{arrange}\NormalTok{(datos, america, }\FunctionTok{desc}\NormalTok{(titulos))}
\end{Highlighting}
\end{Shaded}

\textbf{Actividad propuesta}: filtrar el conjunto de datos original para quedarse con los países que tengan una diferencia de goles positiva y guardar estos registros en un nuevo \emph{data.frame} llamado \texttt{datos\_dg\_positiva}.

\hypertarget{seleccionar-y-reordenar-columnas}{%
\subsection{Seleccionar y reordenar columnas}\label{seleccionar-y-reordenar-columnas}}

Podemos elegir quedarnos sólo con algunas columnas del dataset con la función \textbf{select()}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Elegir cuáles quedan}
\FunctionTok{select}\NormalTok{(datos, seleccion, participaciones)}

\CommentTok{\# Elegir cuáles se van}
\FunctionTok{select}\NormalTok{(datos, }\SpecialCharTok{{-}}\NormalTok{goles\_favor, }\SpecialCharTok{{-}}\NormalTok{goles\_contra)}

\CommentTok{\# Reordenar las columnas {-} everything() hace referencia al resto}
\FunctionTok{select}\NormalTok{(datos, seleccion, campeon, puntos, }\FunctionTok{everything}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\hypertarget{tuberuxedas-o-pipes}{%
\section{\texorpdfstring{Tuberías o \emph{pipes}}{Tuberías o pipes}}\label{tuberuxedas-o-pipes}}

Hasta ahora, esto es parte de lo que hicimos con los datos de los mundiales:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Lectura del archivo}
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{read\_delim}\NormalTok{(}\StringTok{"mundiales.txt"}\NormalTok{)}

\CommentTok{\# Calcular la cantidad total de partidos jugados en mundiales}
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(datos, }\AttributeTok{pj =}\NormalTok{ pg }\SpecialCharTok{+}\NormalTok{ pe }\SpecialCharTok{+}\NormalTok{ pp)}

\CommentTok{\# Indicar si cada país es o no campeón del mundo}
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(datos, }\AttributeTok{campeon =} \FunctionTok{ifelse}\NormalTok{(titulos }\SpecialCharTok{\textgreater{}} \DecValTok{0}\NormalTok{, }\StringTok{"campeón"}\NormalTok{, }\StringTok{"no campeón"}\NormalTok{))}

\CommentTok{\# Corregir los nombres de los continentes}
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(datos, }\AttributeTok{continente =} \FunctionTok{recode}\NormalTok{(continente, }\StringTok{"Europe"} \OtherTok{=} \StringTok{"Europa"}\NormalTok{, }\StringTok{"asia"} \OtherTok{=} \StringTok{"Asia"}\NormalTok{))}

\CommentTok{\# Calcular los puntos ganados por cada país y la diferencia de goles}
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(datos, }\AttributeTok{puntos =} \DecValTok{3} \SpecialCharTok{*}\NormalTok{ pg }\SpecialCharTok{+}\NormalTok{ pe, }\AttributeTok{dg =}\NormalTok{ gf }\SpecialCharTok{{-}}\NormalTok{ gc)}

\CommentTok{\# Cambiar los nombres de algunas columnas}
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{rename}\NormalTok{(datos, }\AttributeTok{goles\_favor =}\NormalTok{ gf, }\AttributeTok{goles\_contra =}\NormalTok{ gc)}

\CommentTok{\# Crear una nueva variable con el nombre del país y del continente}
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{unite}\NormalTok{(datos, }\AttributeTok{col =} \StringTok{"pais\_continente"}\NormalTok{, seleccion, continente, }\AttributeTok{sep =} \StringTok{" {-} "}\NormalTok{, }\AttributeTok{remove =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

En todas las instrucciones anteriores se repite la misma estructura: cada función toma al \emph{data.frame}, lo modifica y lo guarda, y esto se convierte en el input para la próxima función. Se puede escribir todo junto de manera más cómoda usando una \textbf{tubería} o \textbf{pipeline}. En una \textbf{tubería} el resultado de cada línea es el input para la línea siguiente (por eso eliminamos en cada función el primer argumento, el nombre del dataset). El símbolo \texttt{\%\textgreater{}\%}, conocido como \emph{pipe}, es la unión entre las partes de la tubería\footnote{También podemos usar el operador \texttt{\textbar{}\textgreater{}}.}. El atajo para escribir este operador de forma rápida con el teclado es \texttt{CTRL\ +\ Shift\ +\ M}. El \emph{data.frame} devuelto por la última función de la tubería es guardado en el objeto cuyo nombre se indica al comienzo.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\OtherTok{\textless{}{-}} 
    \FunctionTok{read\_delim}\NormalTok{(}\StringTok{"mundiales.txt"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{mutate}\NormalTok{(}
        \AttributeTok{pj =}\NormalTok{ pg }\SpecialCharTok{+}\NormalTok{ pe }\SpecialCharTok{+}\NormalTok{ pp,}
        \AttributeTok{campeon =} \FunctionTok{ifelse}\NormalTok{(titulos }\SpecialCharTok{\textgreater{}} \DecValTok{0}\NormalTok{, }\StringTok{"campeón"}\NormalTok{, }\StringTok{"no campeón"}\NormalTok{),}
        \AttributeTok{continente =} \FunctionTok{recode}\NormalTok{(continente, }\StringTok{"Europe"} \OtherTok{=} \StringTok{"Europa"}\NormalTok{, }\StringTok{"asia"} \OtherTok{=} \StringTok{"Asia"}\NormalTok{),}
        \AttributeTok{puntos =} \DecValTok{3} \SpecialCharTok{*}\NormalTok{ pg }\SpecialCharTok{+}\NormalTok{ pe, }
        \AttributeTok{dg =}\NormalTok{ gf }\SpecialCharTok{{-}}\NormalTok{ gc}
\NormalTok{    ) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{rename}\NormalTok{(}\AttributeTok{goles\_favor =}\NormalTok{ gf, }\AttributeTok{goles\_contra =}\NormalTok{ gc) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{unite}\NormalTok{(}\AttributeTok{col =} \StringTok{"pais\_continente"}\NormalTok{, seleccion, continente, }\AttributeTok{sep =} \StringTok{" {-} "}\NormalTok{, }\AttributeTok{remove =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{escritura-de-conjuntos-de-datos-en-archivos}{%
\section{Escritura de conjuntos de datos en archivos}\label{escritura-de-conjuntos-de-datos-en-archivos}}

Todas las modificaciones que hicimos del \emph{data.frame} con los ejemplos anteriores no modificaron el archivo original \texttt{mundiales.txt} que reside en el disco rígido de nuestra computadora, sino que sirvieron para modificar al objeto \texttt{datos} que reside en la memoria temporal durante la ejecución de la sesión de R. Si al terminar con el procesamiento de los datos queremos generar un nuevo archivo permanente con la nueva versión del dataset, tenemos que hacer algo específico para eso. R provee una gran variedad de funciones para guardar todo el contenido de un objeto de tipo \emph{data.frame} en un archivo, como se muestra en los ejemplos que siguen, en los que plasmamos la versión actual del \emph{data.frame} en un nuevo archivo llamado \texttt{mundiales\_procesado}. En cada ocasión, generamos un tipo de archivo distinto:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Guardarlo en un archivo de texto separado por tabulaciones}
\FunctionTok{write\_delim}\NormalTok{(datos, }\AttributeTok{file =} \StringTok{"mundiales\_procesados.txt"}\NormalTok{, }\AttributeTok{delim =} \StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{"}\NormalTok{)}

\CommentTok{\# Guardarlo en un archivo de texto separado por comas}
\FunctionTok{write\_csv}\NormalTok{(datos, }\AttributeTok{file =} \StringTok{"mundiales\_procesados.csv"}\NormalTok{)}

\CommentTok{\# Guardarlo en un archivo de Excel}
\CommentTok{\# install.packages("writexl")}
\FunctionTok{library}\NormalTok{(writexl)}
\FunctionTok{write\_xlsx}\NormalTok{(datos, }\StringTok{"mundiales\_procesado.xlsx"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{resumen-de-datos}{%
\section{Resumen de datos}\label{resumen-de-datos}}

Una vez que los datos han sido organizados y depurados según corresponda, el siguiente paso de cualquier análisis es hacer un breve análisis exploratorio. En esta sección veremos cómo calcular algunas estadísticas y realizar tablas de distribuciones de frecuencias, ya sea para variables categóricas o cuantitativas.

\hypertarget{cuxe1lculo-de-estaduxedsticas}{%
\subsection{Cálculo de estadísticas}\label{cuxe1lculo-de-estaduxedsticas}}

Imaginemos ahora que queremos saber cuántas veces en promedio han participado estas 80 selecciones del mundial. Esto se puede lograr de manera muy sencilla con \texttt{mean()}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(datos}\SpecialCharTok{$}\NormalTok{participaciones)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 6.1125
\end{verbatim}

Otra alternativa es utilizar la función \texttt{summarise()} del \texttt{tidyverse}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summarise}\NormalTok{(datos, }\AttributeTok{promedio =} \FunctionTok{mean}\NormalTok{(participaciones))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 1 x 1
  promedio
     <dbl>
1     6.11
\end{verbatim}

Si bien esta última forma parece ser más compleja, tiene algunas ventajas:

\begin{itemize}
\tightlist
\item
  Devuelve el resultado como un objeto de tipo \emph{data.frame}, que puede ser usado como ``materia prima'' en otros análisis.
\item
  Permite resumir muchas variables a la vez, en general o por grupos, aplicando uno o varios cálculos de resumen.
\end{itemize}

Por ejemplo, si queremos obtener el puntaje promedio obtenido por las selecciones de cada continente utilizamos \texttt{summarise()} en conjunto con \texttt{group\_by()}, relacionando ambas funciones en una tubería:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{group\_by}\NormalTok{(continente) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{summarise}\NormalTok{(}\AttributeTok{prom\_puntos =} \FunctionTok{mean}\NormalTok{(puntos))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 5 x 2
  continente prom_puntos
  <chr>            <dbl>
1 América          38.2 
2 Asia              7.67
3 Europa           50   
4 Oceanía           9.5 
5 África           11.7 
\end{verbatim}

Podemos seguir alargando la tubería, para pedir que el resultado anterior se presente de forma descendente, de modo que veamos rápidamente cuál es el continente con mayor promedio de puntos obtenidos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{group\_by}\NormalTok{(continente) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{summarise}\NormalTok{(}\AttributeTok{prom\_puntos =} \FunctionTok{mean}\NormalTok{(puntos)) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(prom\_puntos))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 5 x 2
  continente prom_puntos
  <chr>            <dbl>
1 Europa           50   
2 América          38.2 
3 África           11.7 
4 Oceanía           9.5 
5 Asia              7.67
\end{verbatim}

Dentro de \texttt{summarise()} podemos pedir más de un resumen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{group\_by}\NormalTok{(continente) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{summarise}\NormalTok{(}
        \AttributeTok{prom\_puntos =} \FunctionTok{mean}\NormalTok{(puntos),      }\CommentTok{\# promedio de los puntos de los países}
        \AttributeTok{min\_puntos =} \FunctionTok{min}\NormalTok{(puntos),        }\CommentTok{\# mínimo puntaje en ese continente}
        \AttributeTok{max\_puntos =} \FunctionTok{max}\NormalTok{(puntos),        }\CommentTok{\# máximo puntaje en ese continente}
        \AttributeTok{total\_titulos =} \FunctionTok{sum}\NormalTok{(titulos),    }\CommentTok{\# mundiales ganados por países del continente}
        \AttributeTok{total\_pj =} \FunctionTok{sum}\NormalTok{(pj),              }\CommentTok{\# cantidad total de partidos jugados}
        \AttributeTok{prom\_dg =} \FunctionTok{mean}\NormalTok{(dg),              }\CommentTok{\# promedio de la diferencia de goles}
        \AttributeTok{n =} \FunctionTok{n}\NormalTok{()                          }\CommentTok{\# cantidad de registros en cada continente}
\NormalTok{    ) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 5 x 8
  continente prom_puntos min_puntos max_puntos total_titulos total_pj prom_dg
  <chr>            <dbl>      <dbl>      <dbl>         <dbl>    <dbl>   <dbl>
1 América          38.2           0        247            10      534   -0.75
2 Asia              7.67          0         31             0      126  -12.4 
3 Europa           50             1        225            12     1080    8.79
4 Oceanía           9.5           3         16             0       26  -15   
5 África           11.7           0         23             0      162   -7.38
# i 1 more variable: n <int>
\end{verbatim}

\hypertarget{distribuciones-de-frecuencias-para-variables-categuxf3ricas}{%
\subsection{Distribuciones de frecuencias para variables categóricas}\label{distribuciones-de-frecuencias-para-variables-categuxf3ricas}}

Cuando en los archivos de datos existen campos de tipo carácter, que representan variables categóricas, es común resumirlos creando \textbf{tablas de frecuencias}. Ya vimos que la función \texttt{count()} nos permite obtener la \textbf{frecuencia absoluta} (bajo el nombre de \texttt{n}) de cada categoría:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{count}\NormalTok{(datos, continente)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 5 x 2
  continente     n
  <chr>      <int>
1 América       20
2 Asia          12
3 Europa        33
4 Oceanía        2
5 África        13
\end{verbatim}

Sin embargo, utilizaremos un paquete que es muy útil para generar tablas de frecuencias, llamado \texttt{janitor}. No forma parte del \texttt{tidyverse} pero está creado con el mismo diseño. Lo instalamos y cargamos:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# install.packages("janitor")}
\FunctionTok{library}\NormalTok{(janitor)}
\end{Highlighting}
\end{Shaded}

Ahora usamos la función \texttt{tabyl} del paquete \texttt{janitor} para crear una tabla de frecuencias:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{frecuencias }\OtherTok{\textless{}{-}} \FunctionTok{tabyl}\NormalTok{(datos, continente)}
\NormalTok{frecuencias}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 continente  n percent
    América 20  0.2500
       Asia 12  0.1500
     Europa 33  0.4125
    Oceanía  2  0.0250
     África 13  0.1625
\end{verbatim}

Lo anterior es un nuevo \emph{data.frame} con tres variables, el continente, la frecuencia absoluta \texttt{n} y la frecuencia relativa, que si bien son proporciones que varían entre 0 y 1, el software las llama \texttt{percent}. En este caso, con pocas categorías, podemos apreciar rápidamente cuál es el continente con mayor y menor cantidad de países que participaron de mundiales, pero si queremos resaltar esta información podemos hacer algunos filtrados. A continuación, filtramos el \emph{data.frame} \texttt{frecuencias} para retener aquellas filas donde el valor de \texttt{n} sea igual a su mínimo o a su máximo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{minimo }\OtherTok{\textless{}{-}} \FunctionTok{filter}\NormalTok{(frecuencias, n }\SpecialCharTok{==} \FunctionTok{min}\NormalTok{(n))}
\NormalTok{minimo}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 continente n percent
    Oceanía 2   0.025
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{maximo }\OtherTok{\textless{}{-}} \FunctionTok{filter}\NormalTok{(frecuencias, n }\SpecialCharTok{==} \FunctionTok{max}\NormalTok{(n))}
\NormalTok{maximo}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 continente  n percent
     Europa 33  0.4125
\end{verbatim}

Notemos que los objetos \texttt{minimo} y \texttt{maximo} son nuevos \emph{data.frames}, con tan sólo una observación. Podríamos usarlos para emitir algún mensaje con los hallazgos. Por supuesto que si hubiesen empates en los valores máximos o mínimos tendríamos que pensar otra forma de comunicar el mensaje, pero con todos los conocimientos que tenemos de programación esa tarea es sencilla de resolver:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cat}\NormalTok{(}\StringTok{"El continente con la mayor cantidad de países que han participado de mundiales es"}\NormalTok{, }
\NormalTok{        maximo}\SpecialCharTok{$}\NormalTok{continente, }\StringTok{"con"}\NormalTok{, maximo}\SpecialCharTok{$}\NormalTok{n, }\StringTok{"selecciones, mientras que el de menor participación es"}\NormalTok{, }
\NormalTok{        minimo}\SpecialCharTok{$}\NormalTok{continente, }\StringTok{"con"}\NormalTok{, minimo}\SpecialCharTok{$}\NormalTok{n, }\StringTok{"selecciones."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
El continente con la mayor cantidad de países que han participado de mundiales es Europa con 33 selecciones, mientras que el de menor participación es Oceanía con 2 selecciones.
\end{verbatim}

Un aspecto útil de la función \texttt{tabyl()} es que puede ser acompañada por funciones que comienzan con el nombre \texttt{adorn\_} y sirven para agregar algún tipo de ``adorno'' a la tabla, por ejemplo, los totales:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{frecuencias }\OtherTok{\textless{}{-}} 
\NormalTok{    frecuencias }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{adorn\_totals}\NormalTok{()}
\NormalTok{frecuencias}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 continente  n percent
    América 20  0.2500
       Asia 12  0.1500
     Europa 33  0.4125
    Oceanía  2  0.0250
     África 13  0.1625
      Total 80  1.0000
\end{verbatim}

Podríamos mejorar levemente la tabla de frecuencias cambiando los nombres de sus columnas, con la función \texttt{rename()}. Para poder usar nombres que contengan espacios, tenemos que encerrarlos en comillas invertidas (esto es poco práctico a la hora de escribir código, sólo sirve para mejorar la apariencia del resultado):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{frecuencias }\OtherTok{\textless{}{-}} 
\NormalTok{    frecuencias }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{rename}\NormalTok{(}\AttributeTok{Continente =}\NormalTok{ continente, }\StringTok{\textasciigrave{}}\AttributeTok{Frec. Absoluta}\StringTok{\textasciigrave{}} \OtherTok{=}\NormalTok{ n, }\StringTok{\textasciigrave{}}\AttributeTok{Frec. Relativa}\StringTok{\textasciigrave{}} \OtherTok{=}\NormalTok{ percent)}
\NormalTok{frecuencias}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 Continente Frec. Absoluta Frec. Relativa
    América             20         0.2500
       Asia             12         0.1500
     Europa             33         0.4125
    Oceanía              2         0.0250
     África             13         0.1625
      Total             80         1.0000
\end{verbatim}

Si escribimos todos los pasos que hicimos en una sola tubería, nos quedaría así:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{frecuencias }\OtherTok{\textless{}{-}} 
\NormalTok{    datos }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{tabyl}\NormalTok{(continente) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{adorn\_totals}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{rename}\NormalTok{(}\AttributeTok{Continente =}\NormalTok{ continente, }\StringTok{\textasciigrave{}}\AttributeTok{Frec. Absoluta}\StringTok{\textasciigrave{}} \OtherTok{=}\NormalTok{ n, }\StringTok{\textasciigrave{}}\AttributeTok{Frec. Relativa}\StringTok{\textasciigrave{}} \OtherTok{=}\NormalTok{ percent)}
\NormalTok{frecuencias}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 Continente Frec. Absoluta Frec. Relativa
    América             20         0.2500
       Asia             12         0.1500
     Europa             33         0.4125
    Oceanía              2         0.0250
     África             13         0.1625
      Total             80         1.0000
\end{verbatim}

Otro tipo de escenario se presenta cuando queremos analizar las frecuencias de dos variables categóricas. La función \texttt{count()} también permite obtener conteos asociados a cada combinación posible de las categorías de dos o más variables. El resultado, como siempre, es un \emph{data.frame} con una columna para cada una de las variables involucradas y otra para las frecuencias absolutas. Así, podemos ver que de todos los países americanos que jugaron algún mundial, 17 nunca fueron campeones y 3 sí.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{count}\NormalTok{(datos, continente, campeon, }\AttributeTok{sort =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 7 x 3
  continente campeon        n
  <chr>      <chr>      <int>
1 Europa     no campeón    28
2 América    no campeón    17
3 África     no campeón    13
4 Asia       no campeón    12
5 Europa     campeón        5
6 América    campeón        3
7 Oceanía    no campeón     2
\end{verbatim}

Esta forma de presentar los resultados es útil cuando deseamos identificar combinaciones de categorías con los valores mínimos y máximos. Sin embargo, frecuencias como las anteriores suelen ser presentadas en \textbf{tablas de contingencia} o \textbf{tablas de doble entrada}, donde las filas se corresponden a las categorías de una variable y las columnas, a las de la otra. La función \texttt{tabyl()} presenta los conteos de esa forma:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabla\_cont\_campeon }\OtherTok{\textless{}{-}} \FunctionTok{tabyl}\NormalTok{(datos, continente, campeon)}
\NormalTok{tabla\_cont\_campeon}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 continente campeón no campeón
     África       0         13
    América       3         17
       Asia       0         12
     Europa       5         28
    Oceanía       0          2
\end{verbatim}

Podemos destacar cuál es el continente con mayor cantidad de campeones filtrando al registro con máximo valor en la columna \texttt{campeón}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\NormalTok{(tabla\_cont\_campeon, campeón }\SpecialCharTok{==} \FunctionTok{max}\NormalTok{(campeón))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 continente campeón no campeón
     Europa       5         28
\end{verbatim}

La función \texttt{adorn\_totals()} nos permite de manera muy sencilla agregar totales marginales, tanto para filas como columnas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{tabyl}\NormalTok{(continente, campeon) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{adorn\_totals}\NormalTok{(}\AttributeTok{where =} \FunctionTok{c}\NormalTok{(}\StringTok{"row"}\NormalTok{, }\StringTok{"col"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 continente campeón no campeón Total
     África       0         13    13
    América       3         17    20
       Asia       0         12    12
     Europa       5         28    33
    Oceanía       0          2     2
      Total       8         72    80
\end{verbatim}

Además, podemos pedir frecuencias relativas en lugar de absolutas, ya sea de la distribución conjunta de las dos variables (\texttt{denominator\ =\ all}), condicionada a la fila (\texttt{denominator\ =\ row}) o a la columna (\texttt{denominator\ =\ col}).

\begin{itemize}
\item
  \textbf{Distribución conjunta de las variables}: podemos ver, por ejemplo, que el 3.8\% de todos los países participantes son de América y han salido campeón alguna vez.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{tabyl}\NormalTok{(continente, campeon) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{adorn\_totals}\NormalTok{(}\AttributeTok{where =} \FunctionTok{c}\NormalTok{(}\StringTok{"row"}\NormalTok{, }\StringTok{"col"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{adorn\_percentages}\NormalTok{(}\AttributeTok{denominator =} \StringTok{"all"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}  \CommentTok{\# cálculo de proporciones}
  \FunctionTok{adorn\_pct\_formatting}\NormalTok{(}\AttributeTok{digits =} \DecValTok{1}\NormalTok{)            }\CommentTok{\# mostrarlas como porcentaje (opcional)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 continente campeón no campeón  Total
     África    0.0%      16.2%  16.2%
    América    3.8%      21.2%  25.0%
       Asia    0.0%      15.0%  15.0%
     Europa    6.2%      35.0%  41.2%
    Oceanía    0.0%       2.5%   2.5%
      Total   10.0%      90.0% 100.0%
\end{verbatim}
\item
  \textbf{Distribución condicional de ``campeon'' dado ``continente''}: los porcentajes suman 1 en cada fila. De todos los países americanos que alguna vez participaron de un mundial, el 15\% logró ser campeón y el 85\%, no.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{tabyl}\NormalTok{(continente, campeon) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{adorn\_totals}\NormalTok{(}\AttributeTok{where =} \FunctionTok{c}\NormalTok{(}\StringTok{"row"}\NormalTok{, }\StringTok{"col"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{adorn\_percentages}\NormalTok{(}\AttributeTok{denominator =} \StringTok{"row"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{adorn\_pct\_formatting}\NormalTok{(}\AttributeTok{digits =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 continente campeón no campeón  Total
     África    0.0%     100.0% 100.0%
    América   15.0%      85.0% 100.0%
       Asia    0.0%     100.0% 100.0%
     Europa   15.2%      84.8% 100.0%
    Oceanía    0.0%     100.0% 100.0%
      Total   10.0%      90.0% 100.0%
\end{verbatim}
\item
  \textbf{Distribución condicional de ``continente'' dado ``campeón''}: los porcentajes suman 1 en cada columna. De todos los países que salieron campeones, el 62.5\% son europeos y el 37.5\% restante, americanos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{tabyl}\NormalTok{(continente, campeon) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{adorn\_totals}\NormalTok{(}\AttributeTok{where =} \StringTok{"row"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{adorn\_percentages}\NormalTok{(}\AttributeTok{denominator =} \StringTok{"col"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{adorn\_pct\_formatting}\NormalTok{(}\AttributeTok{digits =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 continente campeón no campeón
     África    0.0%      18.1%
    América   37.5%      23.6%
       Asia    0.0%      16.7%
     Europa   62.5%      38.9%
    Oceanía    0.0%       2.8%
      Total  100.0%     100.0%
\end{verbatim}
\end{itemize}

También podemos mostrar frecuencias absolutas y relativas al mismo tiempo, así como editar los títulos. Ejemplificamos mostrando nuevamente la distribución conjunta:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{tabyl}\NormalTok{(continente, campeon) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{adorn\_totals}\NormalTok{(}\AttributeTok{where =} \FunctionTok{c}\NormalTok{(}\StringTok{"row"}\NormalTok{, }\StringTok{"col"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{adorn\_percentages}\NormalTok{(}\AttributeTok{denominator =} \StringTok{"all"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{adorn\_pct\_formatting}\NormalTok{(}\AttributeTok{digits =} \DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{adorn\_ns}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{adorn\_title}\NormalTok{(}\AttributeTok{placement =} \StringTok{"top"}\NormalTok{, }\StringTok{"Continente"}\NormalTok{, }\StringTok{"Campeones del mundo"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
            Campeones del mundo                       
 Continente             campeón no campeón       Total
     África            0.0% (0) 16.2% (13)  16.2% (13)
    América            3.8% (3) 21.2% (17)  25.0% (20)
       Asia            0.0% (0) 15.0% (12)  15.0% (12)
     Europa            6.2% (5) 35.0% (28)  41.2% (33)
    Oceanía            0.0% (0)  2.5%  (2)   2.5%  (2)
      Total           10.0% (8) 90.0% (72) 100.0% (80)
\end{verbatim}

\hypertarget{distribuciones-de-frecuencias-para-variables-cuantitativas}{%
\subsection{Distribuciones de frecuencias para variables cuantitativas}\label{distribuciones-de-frecuencias-para-variables-cuantitativas}}

Cuando se exploran datos de variables cuantitativas, es común realizar tablas de frecuencias agrupando los valores observados en intervalos. Usando la función \texttt{cut()} dentro de \texttt{mutate()} podemos especificar los puntos de corte y generar una nueva columna que informa a qué intervalo pertenece cada observación. El argumento \texttt{right} en \texttt{cut()} sirve para establecer si queremos que los intervalos sean cerrados por derecha (\texttt{TRUE}) o por izquierda (\texttt{FALSE}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(datos, }\AttributeTok{intervalos =} \FunctionTok{cut}\NormalTok{(goles\_favor, }\AttributeTok{breaks =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{250}\NormalTok{, }\DecValTok{50}\NormalTok{), }\AttributeTok{right =} \ConstantTok{FALSE}\NormalTok{))}

\FunctionTok{select}\NormalTok{(datos, seleccion, goles\_favor, intervalos)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 80 x 3
   seleccion    goles_favor intervalos
   <chr>              <dbl> <fct>     
 1 Brasil               237 [200,250) 
 2 Alemania             232 [200,250) 
 3 Argentina            152 [150,200) 
 4 Italia               128 [100,150) 
 5 Francia              136 [100,150) 
 6 Inglaterra           104 [100,150) 
 7 España               108 [100,150) 
 8 Países Bajos          96 [50,100)  
 9 Uruguay               89 [50,100)  
10 Bélgica               69 [50,100)  
# i 70 more rows
\end{verbatim}

Ahora podemos emplear la nueva columna \texttt{intervalos} para realizar tablas de frecuencias como vimos antes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabla\_gf }\OtherTok{\textless{}{-}} \FunctionTok{tabyl}\NormalTok{(datos, intervalos)}
\NormalTok{tabla\_gf}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 intervalos  n percent
     [0,50) 63  0.7875
   [50,100) 10  0.1250
  [100,150)  4  0.0500
  [150,200)  1  0.0125
  [200,250)  2  0.0250
\end{verbatim}

Aunque lo vemos a simple vista, podemos programar la búsqueda del intervalo de valores con la mayor frecuencia y emitir un mensaje:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{maximo }\OtherTok{\textless{}{-}} \FunctionTok{filter}\NormalTok{(tabla\_gf, n }\SpecialCharTok{==} \FunctionTok{max}\NormalTok{(n))}
\NormalTok{maximo}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 intervalos  n percent
     [0,50) 63  0.7875
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cat}\NormalTok{(}\StringTok{"El intervalo de cantidad de goles a favor con la mayor cantidad de observaciones es"}\NormalTok{,}
    \FunctionTok{as.character}\NormalTok{(maximo}\SpecialCharTok{$}\NormalTok{intervalos), }\StringTok{"con"}\NormalTok{, maximo}\SpecialCharTok{$}\NormalTok{n, }\StringTok{"países."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
El intervalo de cantidad de goles a favor con la mayor cantidad de observaciones es [0,50) con 63 países.
\end{verbatim}

También podemos agregar columnas de frecuencias acumuladas, como suele ser común cuando se resumen variables cuantitativas o cualitativas ordinales. Para esto usamos la función \texttt{cumsum()}, que calcula una \emph{suma acumulada}, es decir, cada fila tiene la suma de los valores encontrados desde la primera hasta ella inclusive. Además, aprovechamos a elegir nombres y cambiar los anteriores para que se vean mejor la impresión de la tabla:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabla\_gf }\OtherTok{\textless{}{-}} 
\NormalTok{    tabla\_gf }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{mutate}\NormalTok{(}
        \StringTok{\textasciigrave{}}\AttributeTok{Frec. Abs. Acumulada}\StringTok{\textasciigrave{}} \OtherTok{=} \FunctionTok{cumsum}\NormalTok{(n),}
        \StringTok{\textasciigrave{}}\AttributeTok{Frec. Rel. Acumulada}\StringTok{\textasciigrave{}} \OtherTok{=} \FunctionTok{cumsum}\NormalTok{(percent)}
\NormalTok{    ) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{rename}\NormalTok{(}
        \StringTok{\textasciigrave{}}\AttributeTok{Goles a favor}\StringTok{\textasciigrave{}} \OtherTok{=}\NormalTok{ intervalos,}
        \StringTok{\textasciigrave{}}\AttributeTok{Frec. Absoluta}\StringTok{\textasciigrave{}} \OtherTok{=}\NormalTok{ n, }
        \StringTok{\textasciigrave{}}\AttributeTok{Frec. Relativa}\StringTok{\textasciigrave{}} \OtherTok{=}\NormalTok{ percent}
\NormalTok{    )}
\NormalTok{tabla\_gf}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 Goles a favor Frec. Absoluta Frec. Relativa Frec. Abs. Acumulada
        [0,50)             63         0.7875                   63
      [50,100)             10         0.1250                   73
     [100,150)              4         0.0500                   77
     [150,200)              1         0.0125                   78
     [200,250)              2         0.0250                   80
 Frec. Rel. Acumulada
               0.7875
               0.9125
               0.9625
               0.9750
               1.0000
\end{verbatim}

\hypertarget{escritura-de-resultados-en-archivos}{%
\section{Escritura de resultados en archivos}\label{escritura-de-resultados-en-archivos}}

Anteriormente hemos mencionado que cuando trabajamos con archivos podemos realizar acciones tanto de lectura como de escritura y hasta el momento hemos visto cómo leer registros de un archivo y guardar los datos de un \emph{data.frame} en uno nuevo. En este apartado presentamos cómo crear un archivo de texto desde R, de manera que pueda utilizarse para escribir y guardar allí los resultados obtenidos en tareas básicas de exploración.

Vamos a volcar los hallazgos sobre los mundiales en un archivo de texto llamado \texttt{salida.txt}. En R, la función \texttt{sink()} permite escribir en un archivo de texto todos los resultados que habitualmente vemos en la consola. Sus argumentos son:

\begin{itemize}
\tightlist
\item
  \texttt{file}: nombre del archivo, si no existe será creado. Se guarda en el directorio de trabajo actual, a menos que indiquemos aquí la ruta completa hacia otra carpeta.
\item
  \texttt{append}: si el archivo ya existía, por default lo sobrescribe (borra lo anterior), a menos que indiquemos \texttt{append\ =\ TRUE} para que agregue nuevas líneas sin borrar las anteriores.
\item
  \texttt{split}: mientras la conexión al archivo está activa, por defecto los resultados que enviamos al mismo no se muestran en la consola de R, a menos que indiquemos \texttt{split\ =\ TRUE}, en cuyo caso sucederán ambas cosas: los resultados serán escritos en el archivo y se verán en la consola.
\end{itemize}

Cuando se desea cerrar la conexión al archivo, se debe correr \texttt{sink()} sin ningún argumento. Todo lo que \emph{imprimamos} con \texttt{cat()} entre ambos llamados a \texttt{sink()} se guardará en el archivo. La última parte del código en el problema anterior debe ser:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Crear conexión al archivo de salida y poner un encabezado}
\FunctionTok{sink}\NormalTok{(}\AttributeTok{file =} \StringTok{"salida.txt"}\NormalTok{, }\AttributeTok{append =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{split =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"==========================================}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"            ARCHIVO DE RESULTADOS         }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"==========================================}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}

\FunctionTok{cat}\NormalTok{(}\StringTok{"=============== ESTADÍSTICAS ===============}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{datos }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{group\_by}\NormalTok{(continente) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{summarise}\NormalTok{(}
        \StringTok{\textasciigrave{}}\AttributeTok{Países participantes}\StringTok{\textasciigrave{}} \OtherTok{=} \FunctionTok{n}\NormalTok{(),}
        \StringTok{\textasciigrave{}}\AttributeTok{Promedio de puntos}\StringTok{\textasciigrave{}} \OtherTok{=} \FunctionTok{mean}\NormalTok{(puntos),}
        \StringTok{\textasciigrave{}}\AttributeTok{Títulos obtenidos}\StringTok{\textasciigrave{}} \OtherTok{=} \FunctionTok{sum}\NormalTok{(titulos),}
        \StringTok{\textasciigrave{}}\AttributeTok{Total de partidos jugados}\StringTok{\textasciigrave{}} \OtherTok{=} \FunctionTok{sum}\NormalTok{(pj),}
        \StringTok{\textasciigrave{}}\AttributeTok{Promedio de diferencia de goles}\StringTok{\textasciigrave{}} \OtherTok{=} \FunctionTok{mean}\NormalTok{(dg)}
\NormalTok{    )}

\FunctionTok{cat}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{=============== DISTRIBUCIÓN DE SELECCIONES SEGÚN CONTINENTE ===============}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Tabla básica}
\NormalTok{frecuencias }\OtherTok{\textless{}{-}} \FunctionTok{tabyl}\NormalTok{(datos, continente)}

\CommentTok{\# Detectar máximo y mínimo}
\NormalTok{maximo }\OtherTok{\textless{}{-}} \FunctionTok{filter}\NormalTok{(frecuencias, n }\SpecialCharTok{==} \FunctionTok{max}\NormalTok{(n))}
\NormalTok{minimo }\OtherTok{\textless{}{-}} \FunctionTok{filter}\NormalTok{(frecuencias, n }\SpecialCharTok{==} \FunctionTok{min}\NormalTok{(n))}

\CommentTok{\# Completar la tabla con totales y cambiar nombres}
\NormalTok{frecuencias }\OtherTok{\textless{}{-}} 
\NormalTok{  frecuencias }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{adorn\_totals}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{rename}\NormalTok{(}\AttributeTok{Continente =}\NormalTok{ continente, }\StringTok{\textasciigrave{}}\AttributeTok{Frec. Absoluta}\StringTok{\textasciigrave{}} \OtherTok{=}\NormalTok{ n, }\StringTok{\textasciigrave{}}\AttributeTok{Frec. Relativa}\StringTok{\textasciigrave{}} \OtherTok{=}\NormalTok{ percent)}
\NormalTok{frecuencias}

\CommentTok{\# Emitir mensaje}
\FunctionTok{cat}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{El continente con la mayor cantidad de países que han participado de mundiales es"}\NormalTok{, }
\NormalTok{    maximo}\SpecialCharTok{$}\NormalTok{continente, }\StringTok{"con"}\NormalTok{, maximo}\SpecialCharTok{$}\NormalTok{n, }\StringTok{"selecciones, mientras que el de menor participación es"}\NormalTok{, }
\NormalTok{    minimo}\SpecialCharTok{$}\NormalTok{continente, }\StringTok{"con"}\NormalTok{, minimo}\SpecialCharTok{$}\NormalTok{n, }\StringTok{"selecciones.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\FunctionTok{cat}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{=============== DISTRIBUCIÓN CONJUNTA DE CONTINENTES Y CAMPEONES ===============}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{datos }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{tabyl}\NormalTok{(continente, campeon) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{adorn\_totals}\NormalTok{(}\AttributeTok{where =} \FunctionTok{c}\NormalTok{(}\StringTok{"row"}\NormalTok{, }\StringTok{"col"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{adorn\_percentages}\NormalTok{(}\AttributeTok{denominator =} \StringTok{"all"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{adorn\_pct\_formatting}\NormalTok{(}\AttributeTok{digits =} \DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{adorn\_ns}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{adorn\_title}\NormalTok{(}\AttributeTok{placement =} \StringTok{"top"}\NormalTok{, }\StringTok{"Continente"}\NormalTok{, }\StringTok{"Campeones del mundo"}\NormalTok{)}

\FunctionTok{cat}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{=============== DISTRIBUCIÓN CONDICIONAL DE CAMPEONES EN CADA CONTINENTE ===============}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{datos }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{tabyl}\NormalTok{(continente, campeon) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{adorn\_totals}\NormalTok{(}\AttributeTok{where =} \FunctionTok{c}\NormalTok{(}\StringTok{"row"}\NormalTok{, }\StringTok{"col"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{adorn\_percentages}\NormalTok{(}\AttributeTok{denominator =} \StringTok{"row"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{adorn\_pct\_formatting}\NormalTok{(}\AttributeTok{digits =} \DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{adorn\_ns}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{adorn\_title}\NormalTok{(}\AttributeTok{placement =} \StringTok{"top"}\NormalTok{, }\StringTok{"Continente"}\NormalTok{, }\StringTok{"Campeones del mundo"}\NormalTok{)}

\FunctionTok{cat}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{=============== DISTRIBUCIÓN CONDICIONAL DE CONTINENTES DADO CAMPEONES ===============}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{datos }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{tabyl}\NormalTok{(continente, campeon) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{adorn\_totals}\NormalTok{(}\AttributeTok{where =} \StringTok{"row"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{adorn\_percentages}\NormalTok{(}\AttributeTok{denominator =} \StringTok{"col"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{adorn\_pct\_formatting}\NormalTok{(}\AttributeTok{digits =} \DecValTok{1}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{adorn\_ns}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{adorn\_title}\NormalTok{(}\AttributeTok{placement =} \StringTok{"top"}\NormalTok{, }\StringTok{"Continente"}\NormalTok{, }\StringTok{"Campeones del mundo"}\NormalTok{)}

\FunctionTok{cat}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{==================== DISTRIBUCIÓN DE LA CANTIDAD DE GOLES A FAVOR ====================}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Crear intervalos y tabla}
\NormalTok{datos }\OtherTok{\textless{}{-}} \FunctionTok{mutate}\NormalTok{(datos, }\AttributeTok{intervalos =} \FunctionTok{cut}\NormalTok{(goles\_favor, }\AttributeTok{breaks =} \FunctionTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{250}\NormalTok{, }\DecValTok{50}\NormalTok{), }\AttributeTok{right =} \ConstantTok{FALSE}\NormalTok{))}
\NormalTok{tabla\_gf }\OtherTok{\textless{}{-}} \FunctionTok{tabyl}\NormalTok{(datos, intervalos)}

\CommentTok{\# Detectar el intervalo con la mayor frecuencia}
\NormalTok{maximo }\OtherTok{\textless{}{-}} \FunctionTok{filter}\NormalTok{(tabla\_gf, n }\SpecialCharTok{==} \FunctionTok{max}\NormalTok{(n))}

\CommentTok{\# Agregar columnas acumuladas, mejorar la apariencia y calcular totales}
\NormalTok{tabla\_gf }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{mutate}\NormalTok{(}
        \StringTok{\textasciigrave{}}\AttributeTok{Frec. Abs. Acumulada}\StringTok{\textasciigrave{}} \OtherTok{=} \FunctionTok{cumsum}\NormalTok{(n),}
        \StringTok{\textasciigrave{}}\AttributeTok{Frec. Rel. Acumulada}\StringTok{\textasciigrave{}} \OtherTok{=} \FunctionTok{cumsum}\NormalTok{(percent)}
\NormalTok{    ) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{rename}\NormalTok{(}
        \StringTok{\textasciigrave{}}\AttributeTok{Goles a favor}\StringTok{\textasciigrave{}} \OtherTok{=}\NormalTok{ intervalos,}
        \StringTok{\textasciigrave{}}\AttributeTok{Frec. Absoluta}\StringTok{\textasciigrave{}} \OtherTok{=}\NormalTok{ n, }
        \StringTok{\textasciigrave{}}\AttributeTok{Frec. Relativa}\StringTok{\textasciigrave{}} \OtherTok{=}\NormalTok{ percent}
\NormalTok{    ) }\SpecialCharTok{\%\textgreater{}\%} 
    \CommentTok{\# Agregar totales sólo para Frec Absoluta y Frec Rel (sí o sí hay que escribir todos los argumentos de la función) }
    \FunctionTok{adorn\_totals}\NormalTok{(}\AttributeTok{where =} \StringTok{"row"}\NormalTok{, }\AttributeTok{fill =} \StringTok{"{-}"}\NormalTok{, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{name =} \StringTok{"Total"}\NormalTok{, }\StringTok{\textasciigrave{}}\AttributeTok{Frec. Absoluta}\StringTok{\textasciigrave{}}\NormalTok{, }\StringTok{\textasciigrave{}}\AttributeTok{Frec. Relativa}\StringTok{\textasciigrave{}}\NormalTok{)}

\CommentTok{\# Emitir mensaje}
\FunctionTok{cat}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{El intervalo de cantidad de goles a favor con la mayor cantidad de observaciones es"}\NormalTok{, }
    \FunctionTok{as.character}\NormalTok{(maximo}\SpecialCharTok{$}\NormalTok{intervalos), }\StringTok{"con"}\NormalTok{, maximo}\SpecialCharTok{$}\NormalTok{n, }\StringTok{"países.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Cerrar conexión al archivo}
\FunctionTok{sink}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

El archivo \texttt{salida.txt} queda así:

\begin{verbatim}
==========================================
            ARCHIVO DE RESULTADOS         
==========================================

==================== ESTADÍSTICAS ====================

# A tibble: 5 × 6
  continente `Países participantes` `Promedio de puntos` `Títulos obtenidos` `Total de partidos jugados` Promedio de diferencia de gol…¹
  <chr>                       <int>                <dbl>               <dbl>                       <dbl>                           <dbl>
1 América                        20                38.2                   10                         534                           -0.75
2 Asia                           12                 7.67                   0                         126                          -12.4 
3 Europa                         33                50                     12                        1080                            8.79
4 Oceanía                         2                 9.5                    0                          26                          -15   
5 África                         13                11.7                    0                         162                           -7.38
# ℹ abbreviated name: ¹​`Promedio de diferencia de goles`

==================== DISTRIBUCIÓN DE SELECCIONES SEGÚN CONTINENTE ====================

 Continente Frec. Absoluta Frec. Relativa
    América             20         0.2500
       Asia             12         0.1500
     Europa             33         0.4125
    Oceanía              2         0.0250
     África             13         0.1625
      Total             80         1.0000

El continente con la mayor cantidad de países que han participado de mundiales es Europa con 33 selecciones, mientras que el de menor participación es Oceanía con 2 selecciones.

==================== DISTRIBUCIÓN CONJUNTA DE CONTINENTES Y CAMPEONES ====================

            Campeones del mundo                       
 Continente             campeón no campeón       Total
     África            0.0% (0) 16.2% (13)  16.2% (13)
    América            3.8% (3) 21.2% (17)  25.0% (20)
       Asia            0.0% (0) 15.0% (12)  15.0% (12)
     Europa            6.2% (5) 35.0% (28)  41.2% (33)
    Oceanía            0.0% (0)  2.5%  (2)   2.5%  (2)
      Total           10.0% (8) 90.0% (72) 100.0% (80)

==================== DISTRIBUCIÓN CONDICIONAL DE CAMPEONES EN CADA CONTINENTE ====================

            Campeones del mundo                        
 Continente             campeón  no campeón       Total
     África            0.0% (0) 100.0% (13) 100.0% (13)
    América           15.0% (3)  85.0% (17) 100.0% (20)
       Asia            0.0% (0) 100.0% (12) 100.0% (12)
     Europa           15.2% (5)  84.8% (28) 100.0% (33)
    Oceanía            0.0% (0) 100.0%  (2) 100.0%  (2)
      Total           10.0% (8)  90.0% (72) 100.0% (80)

==================== DISTRIBUCIÓN CONDICIONAL DE CONTINENTES DADO CAMPEONES ====================

            Campeones del mundo            
 Continente             campeón  no campeón
     África            0.0% (0)  18.1% (13)
    América           37.5% (3)  23.6% (17)
       Asia            0.0% (0)  16.7% (12)
     Europa           62.5% (5)  38.9% (28)
    Oceanía            0.0% (0)   2.8%  (2)
      Total          100.0% (8) 100.0% (72)

==================== DISTRIBUCIÓN CONDICIONAL DE CONTINENTES DADO CAMPEONES ====================

 Goles a favor Frec. Absoluta Frec. Relativa Frec. Abs. Acumulada Frec. Rel. Acumulada
        [0,50)             63         0.7875                   63               0.7875
      [50,100)             10         0.1250                   73               0.9125
     [100,150)              4         0.0500                   77               0.9625
     [150,200)              1         0.0125                   78                0.975
     [200,250)              2         0.0250                   80                    1
         Total             80         1.0000                    -                    -

El intervalo de cantidad de goles a favor con la mayor cantidad de observaciones es [0,50) con 63 países.
\end{verbatim}

\hypertarget{lectura-opcional}{%
\section{Lectura opcional}\label{lectura-opcional}}

\hypertarget{otros-ejemplos-para-obtener-resuxfamenes}{%
\subsection{Otros ejemplos para obtener resúmenes}\label{otros-ejemplos-para-obtener-resuxfamenes}}

Cuando aplicamos el mismo tipo de resumen a varias variables (en este caso, la media), podemos usar \texttt{across}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{group\_by}\NormalTok{(continente) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{summarise}\NormalTok{(}\FunctionTok{across}\NormalTok{(}\FunctionTok{c}\NormalTok{(goles\_favor, goles\_contra), mean))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 5 x 3
  continente goles_favor goles_contra
  <chr>            <dbl>        <dbl>
1 América          37.9          38.6
2 Asia              8.67         21.1
3 Europa           50.9          42.1
4 Oceanía          10.5          25.5
5 África           12.1          19.5
\end{verbatim}

Podemos aplicar el mismo tipo de resumen para todas las variables que tengan alguna característica en particular, por ejemplo, ser numéricas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datos }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{group\_by}\NormalTok{(continente) }\SpecialCharTok{\%\textgreater{}\%} 
    \FunctionTok{summarise}\NormalTok{(}\FunctionTok{across}\NormalTok{(}\FunctionTok{where}\NormalTok{(is.numeric), mean))}
\end{Highlighting}
\end{Shaded}

\hypertarget{tablas-de-frecuencia-con-r-base}{%
\subsection{Tablas de frecuencia con R Base}\label{tablas-de-frecuencia-con-r-base}}

Utilizar el paquete \texttt{janitor} no es la única forma de inspeccionar frecuencias. Se puede hacer de forma sencilla con funciones incorporadas en R Base, aunque la forma de presentar los resultados es menos vistosa:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Frecuencias absolutas}
\NormalTok{tabla1 }\OtherTok{\textless{}{-}} \FunctionTok{table}\NormalTok{(datos}\SpecialCharTok{$}\NormalTok{continente)}
\NormalTok{tabla1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}

 África América    Asia  Europa Oceanía 
     13      20      12      33       2 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Frencuencias relativas}
\FunctionTok{prop.table}\NormalTok{(tabla1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}

 África América    Asia  Europa Oceanía 
 0.1625  0.2500  0.1500  0.4125  0.0250 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Tabla de contingencia para dos variables}
\NormalTok{tabla2 }\OtherTok{\textless{}{-}} \FunctionTok{table}\NormalTok{(datos}\SpecialCharTok{$}\NormalTok{continente, datos}\SpecialCharTok{$}\NormalTok{campeon)}
\NormalTok{tabla2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
         
          campeón no campeón
  África        0         13
  América       3         17
  Asia          0         12
  Europa        5         28
  Oceanía       0          2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Distribución conjunta}
\FunctionTok{prop.table}\NormalTok{(tabla2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
         
          campeón no campeón
  África   0.0000     0.1625
  América  0.0375     0.2125
  Asia     0.0000     0.1500
  Europa   0.0625     0.3500
  Oceanía  0.0000     0.0250
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Distribución condicional de campeon dado continente}
\FunctionTok{prop.table}\NormalTok{(tabla2, }\AttributeTok{margin =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
         
            campeón no campeón
  África  0.0000000  1.0000000
  América 0.1500000  0.8500000
  Asia    0.0000000  1.0000000
  Europa  0.1515152  0.8484848
  Oceanía 0.0000000  1.0000000
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Distribución condicional de continente dado campeon}
\FunctionTok{prop.table}\NormalTok{(tabla2, }\AttributeTok{margin =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
         
             campeón no campeón
  África  0.00000000 0.18055556
  América 0.37500000 0.23611111
  Asia    0.00000000 0.16666667
  Europa  0.62500000 0.38888889
  Oceanía 0.00000000 0.02777778
\end{verbatim}

\hypertarget{cambiar-el-formato-de-un-data.frame}{%
\subsection{\texorpdfstring{Cambiar el formato de un \emph{data.frame}}{Cambiar el formato de un data.frame}}\label{cambiar-el-formato-de-un-data.frame}}

Dependiendo de los requerimientos de los análisis que estemos realizando, es muy frecuente necesitar cambiar el formato que tienen los datos. Por ejemplo, puede ser necesario apilar columnas una debajo de otra, resultando en un dataset con más filas (más largo) y menos columnas (más angosto). La situación contraria también se puede presentar y consiste en desacoplar información concatenada en una sola columna para ubicarla en varias columnas adyacentes, resultando en una dataset con más columnas (más ancho) y menos filas (más corto). Por supuesto, estas transformaciones tienen que hacerse sin mezclar los registros:

\textbf{Formato ancho a largo}

Armemos un pequeño ejemplo de juguete para imaginar bien de qué se trata esto. Supongamos que tenemos datos con la cantidad vendida de 3 productos en distintos meses. De la siguiente forma se puede crear un \emph{data.frame} ``a mano'', sin leer los datos desde un archivo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ejemplo1 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{producto =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{,}
  \AttributeTok{septiembre =} \FunctionTok{c}\NormalTok{(}\DecValTok{234}\NormalTok{, }\DecValTok{657}\NormalTok{, }\DecValTok{989}\NormalTok{),}
  \AttributeTok{octubre =} \FunctionTok{c}\NormalTok{(}\DecValTok{841}\NormalTok{, }\DecValTok{621}\NormalTok{, }\DecValTok{589}\NormalTok{),}
  \AttributeTok{noviembre =} \FunctionTok{c}\NormalTok{(}\DecValTok{521}\NormalTok{, }\DecValTok{147}\NormalTok{, }\DecValTok{258}\NormalTok{)}
\NormalTok{)}
\NormalTok{ejemplo1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  producto septiembre octubre noviembre
1        1        234     841       521
2        2        657     621       147
3        3        989     589       258
\end{verbatim}

A ese formato le decimos ``ancho'' porque una misma variable (cantidad de ventas) se ubica en muchas columnas, cuyos nombres se confunden con lo que en realidad debe ser otra variable, el mes. Queremos pasarlo a un formato largo para que se vea así:

\begin{verbatim}
# A tibble: 9 x 3
  producto mes        ventas
     <int> <chr>       <dbl>
1        1 septiembre    234
2        1 octubre       841
3        1 noviembre     521
4        2 septiembre    657
5        2 octubre       621
6        2 noviembre     147
7        3 septiembre    989
8        3 octubre       589
9        3 noviembre     258
\end{verbatim}

Lo logramos con la función \texttt{pivot\_longer()}, cuyos argumentos son:

\begin{itemize}
\tightlist
\item
  \textbf{data}: el dataset que vamos a modificar
\item
  \textbf{cols}: columnas que queremos apilar (o las que no queremos apilar, si es más fácil de indicar)
\item
  \textbf{names\_to}: cómo queremos que se llame la nueva columna que contendrá los nombres de las columnas apiladas.
\item
  \textbf{values\_to}: cómo queremos que se llame la nueva columna que contendrá los valores de las columnas apiladas.
\end{itemize}

\begin{center}\includegraphics[width=0.6\linewidth]{images/06_archivos/original-dfs-tidy} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ejemplo2 }\OtherTok{\textless{}{-}} \FunctionTok{pivot\_longer}\NormalTok{(}
  \AttributeTok{data =}\NormalTok{ ejemplo1, }
  \AttributeTok{cols =} \FunctionTok{c}\NormalTok{(septiembre, octubre, noviembre), }
  \AttributeTok{names\_to =} \StringTok{"mes"}\NormalTok{, }
  \AttributeTok{values\_to =} \StringTok{"ventas"}
\NormalTok{)}
\NormalTok{ejemplo2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 9 x 3
  producto mes        ventas
     <int> <chr>       <dbl>
1        1 septiembre    234
2        1 octubre       841
3        1 noviembre     521
4        2 septiembre    657
5        2 octubre       621
6        2 noviembre     147
7        3 septiembre    989
8        3 octubre       589
9        3 noviembre     258
\end{verbatim}

\textbf{Formato largo a ancho}

A su vez, la función \texttt{pivot\_wider()} permite pasar de \textbf{formatos largos} a \textbf{formatos anchos} (al revés de \texttt{pivot\_longer()}):

\begin{center}\includegraphics[width=0.6\linewidth]{images/06_archivos/spread} \end{center}

Podríamos usarlo si queremos volver a la versión original de la base. Para ello necesitamos usar estos argumentos:

\begin{itemize}
\tightlist
\item
  \textbf{data}: el dataset
\item
  \textbf{names\_from}: columna que tiene los nombres de las nuevas columnas
\item
  \textbf{values\_from}: columna que tiene los valores que se distribuirán en las nuevas columnas
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pivot\_wider}\NormalTok{(}
  \AttributeTok{data =}\NormalTok{ ejemplo2, }
  \AttributeTok{names\_from =}\NormalTok{ mes, }
  \AttributeTok{values\_from =}\NormalTok{ ventas}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 3 x 4
  producto septiembre octubre noviembre
     <int>      <dbl>   <dbl>     <dbl>
1        1        234     841       521
2        2        657     621       147
3        3        989     589       258
\end{verbatim}

\hypertarget{fusionar-dos-data.frames}{%
\subsection{\texorpdfstring{Fusionar dos \texttt{data.frames}}{Fusionar dos data.frames}}\label{fusionar-dos-data.frames}}

Muchas veces, los análisis de datos involucran múltiples tablas o conjuntos de datos, los cuales deben combinarse para dar respuesta a las preguntas de interés.. En estos casos importan las \textbf{relaciones} que se establecen entre las bases, más allá de los datos individuales que contenga cada uno de ellas. \texttt{R} nos ofrece diversas alternativas, las cuales dependen del tipo de relación que deseemos establecer entre los conjuntos de datos. Para definir estas relaciones debemos establecer qué variable funcionará como \texttt{key} o clave identificadora de los casos. Esta \texttt{key} debe figurar en ambos conjuntos de datos y representar lo mismo para que tenga sentido la relación. Las fusiones pueden clasificarse en dos grupos: las que producen modificaciones en uno de los conjuntos (\emph{mutating joins}) y las que actúan como filtros (\emph{filtering joins}).

\textbf{Mutating Joins}

Son funciones que permiten unir conjuntos de datos, agregando en uno de ellos nuevas variables que provienen del otro, a partir las filas con \texttt{key} coincidente:

\begin{verbatim}
- `left_join()`
- `right_join()`
- `inner_join()`
- `full_join()`
\end{verbatim}

Hacen una \emph{mutación} en el sentido de que añaden columnas a uno de los conjuntos. Consideremos los siguientes conjuntos de datos, donde \emph{X1} será la clave:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Datos1 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{X1 =} \FunctionTok{c}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"C"}\NormalTok{), }\AttributeTok{X2 =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\NormalTok{Datos2 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{X1 =} \FunctionTok{c}\NormalTok{(}\StringTok{"D"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"A"}\NormalTok{), }\AttributeTok{X3 =} \FunctionTok{c}\NormalTok{(}\DecValTok{9}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.4\linewidth]{images/06_archivos/Tabla1} \end{center}

Veamos los distintos tipos de \emph{mutating joins}:

\begin{itemize}
\item
  \texttt{left\_join()}: esta opción devuelve un conjunto de datos que contiene todas las filas de la tabla de la izquierda, agregando las columnas de la tabla de la derecha.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{DatosUnidos }\OtherTok{\textless{}{-}} \FunctionTok{left\_join}\NormalTok{(Datos1, Datos2, }\AttributeTok{by =} \StringTok{"X1"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  \begin{center}\includegraphics[width=0.7\linewidth]{images/06_archivos/leftjoin} \end{center}
\item
  \texttt{right\_join()}: devuelve un conjunto de datos que contiene todas las filas de la tabla de la derecha y agrega columnas de la tabla izquierda.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{DatosUnidos }\OtherTok{\textless{}{-}} \FunctionTok{right\_join}\NormalTok{(Datos1, Datos2, }\AttributeTok{by =} \StringTok{"X1"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  \begin{center}\includegraphics[width=0.7\linewidth]{images/06_archivos/rightjoin} \end{center}
\item
  \texttt{inner\_join()}: devuelve un conjunto de datos con todas las columnas pero sólo para las observaciones (filas) cuyos identificadores se repiten en ambos conjuntos de datos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{DatosUnidos }\OtherTok{\textless{}{-}} \FunctionTok{inner\_join}\NormalTok{(Datos1, Datos2, }\AttributeTok{by =} \StringTok{"X1"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  \begin{center}\includegraphics[width=0.7\linewidth]{images/06_archivos/innerjoin} \end{center}
\item
  \texttt{full\_join()}: devuelve un conjunto de datos con todas las filas y columnas, fusionando a través de la \texttt{key} para las filas coincidentes entre ambos conjuntos.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{DatosUnidos }\OtherTok{\textless{}{-}} \FunctionTok{full\_join}\NormalTok{(Datos1, Datos2, }\AttributeTok{by =} \StringTok{"X1"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  \begin{center}\includegraphics[width=0.7\linewidth]{images/06_archivos/fulljoin} \end{center}
\end{itemize}

\textbf{Filtering Joins}

Son funciones que permiten unir las observaciones de dos datasets, pero sólo afectan a las filas sin alterar las columnas o variables. Funcionan como un \textbf{filtro} para las observaciones de una base de datos, de acuerdo a si \emph{están} o \emph{no están} (según el sentido que se elija) en otra base de datos:

\begin{itemize}
\item
  \texttt{semi\_join()}: devuelve todas las observaciones que están en \texttt{Datos1} que también están en \texttt{Datos2}, manteniendo sólo las columnas de \texttt{Datos1}. La relación se piensa como en \texttt{inner\_join()}, pero el resultado es sólo la base \texttt{Datos1} filtrada.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{DatosFiltrados }\OtherTok{\textless{}{-}} \FunctionTok{semi\_join}\NormalTok{(Datos1, Datos2, }\AttributeTok{by =} \StringTok{"X1"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  \begin{center}\includegraphics[width=0.7\linewidth]{images/06_archivos/semijoin} \end{center}
\item
  \texttt{anti\_join()}: devuelve aquellas observaciones que están en \texttt{Datos1} pero \textbf{no están} en \texttt{Datos2}, manteniendo las columnas de \texttt{Datos1}. Es el filtro contrario a \texttt{semi\_join()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{DatosFiltrados }\OtherTok{\textless{}{-}} \FunctionTok{anti\_join}\NormalTok{(Datos1, Datos2, }\AttributeTok{by =} \StringTok{"X1"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  \begin{center}\includegraphics[width=0.7\linewidth]{images/06_archivos/antijoin} \end{center}
\end{itemize}

\textbf{Otros detalles sobre las keys}

Hasta ahora hemos visto ejemplos donde las columnas que se usaron como claves identificadoras tenían valores únicos, sin repetir. Si la clave identificadora está duplicada en una de las bases de datos, la relación que \texttt{R} brindará con las funciones \texttt{*\_join()} será del tipo ``uno a varios'':

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d1 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{val\_x =} \FunctionTok{c}\NormalTok{(}\StringTok{"x1"}\NormalTok{, }\StringTok{"x2"}\NormalTok{, }\StringTok{"x3"}\NormalTok{, }\StringTok{"x4"}\NormalTok{), }
  \AttributeTok{key =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{)}

\NormalTok{d2 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{key =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{), }
  \AttributeTok{val\_y =} \FunctionTok{c}\NormalTok{(}\StringTok{"y1"}\NormalTok{, }\StringTok{"y2"}\NormalTok{)}
\NormalTok{)}

\FunctionTok{full\_join}\NormalTok{(d1, d2)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{images/06_archivos/1dupkeys} \end{center}

Si ambas bases de datos tienen claves duplicadas, las funciones \texttt{*\_join()} devuelven todas las combinaciones posibles:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d1 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{val\_x =} \FunctionTok{c}\NormalTok{(}\StringTok{"x1"}\NormalTok{, }\StringTok{"x2"}\NormalTok{, }\StringTok{"x3"}\NormalTok{, }\StringTok{"x4"}\NormalTok{),}
  \AttributeTok{key =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{)}

\NormalTok{d2 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{key =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{),}
  \AttributeTok{val\_y =} \FunctionTok{c}\NormalTok{(}\StringTok{"y1"}\NormalTok{, }\StringTok{"y2"}\NormalTok{, }\StringTok{"y3"}\NormalTok{, }\StringTok{"y4"}\NormalTok{)}
\NormalTok{)}

\FunctionTok{full\_join}\NormalTok{(d1, d2)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.5\linewidth]{images/06_archivos/2dupkeys} \end{center}

Muchas veces nos interesa que las observaciones de los conjuntos de datos se relacionen a través de más de una variable, es decir, queremos identificar a cada registro a través de más de una columna. En este caso tenemos 2 opciones:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inventar una nueva variable identificadora (\texttt{key}) que de algún modo contenga la información de esas variables e identifique a cada observación de manera única (por ejemplo, pegar ambas columnas en una sola).
\item
  Indicarle directamente en \texttt{R} que la relación entre las bases de datos debe hacerse a través de varias variables. En el argumento \texttt{by} de las funciones \texttt{*\_join()} ponemos el vector de variables \texttt{by\ =\ c(Vble1,\ Vble2,\ Vble3)} mediante las cuales queremos que se relacionen las bases.
\end{enumerate}

Por defecto, los conjuntos de datos se unen a través de todas las variables que llevan el mismo nombre en ambos conjuntos, lo que suele denominarse \textbf{unión natural}. Si usamos \texttt{by} para indicar qué columnas vinculan ambas bases, y entre las columnas no mencionadas quedan variables con el mismo nombre en los dos conjuntos, entonces estas aparecerán repetidas en el dataset resultante, con una extensión en su nombre para identificar su origen (\emph{nombre\_columna.x, nombre\_columna.y}).

Las variables usadas como \texttt{key} podrían no tener el mismo nombre en ambos conjuntos de datos. Por ejemplo, si en Datos1 tenemos \emph{DNI} y en Datos2 tenemos \emph{Documento}, no es necesario renombrar estas columnas: al indicar \textbf{\texttt{by\ =\ c("DNI"\ =\ "Documento")}}, R las reconoce como la misma variable, las utilizará como clave y conservará el primer nombre (\emph{DNI} en este ejemplo).

\hypertarget{otros-tuxf3picos}{%
\chapter{Otros tópicos}\label{otros-tuxf3picos}}

Las reglas que aprendimos para escribir el pseudocódigo nos permiten traducir nuestros algoritmos a cualquier lenguaje de computación de manera muy general y sencilla. Sin embargo, cada lenguaje de programación tiene diseñado su propio conjunto de funciones y estructuras de datos que facilitan algunas tareas. Una vez que hemos incorporado los conceptos básicos de la programación, podemos dedicarnos a aprender las profundidades de un lenguaje en particular.

En este capítulo vamos mencionar algunas cosas útiles sobre R y otras cuestiones.

\hypertarget{la-consola}{%
\section{La consola}\label{la-consola}}

Cuando prendemos nuestra computadora nos encontramos con una interfaz gráfica implementada por el sistema operativo para que podamos hacer lo que necesitemos de manera sencilla usando ventanas y menúes, interactuando con el sistema a través del mouse, teclado, micrófono o pantalla táctil. Sin embargo, es posible usar la compu de otra forma, escribiendo comandos especiales en una ventanita, llamada \textbf{consola} que es capaz de interpretarlos para hacer cualquier tipo de actividad, sin utilizar la interfaz gráfica. Años atrás, esta era la única manera disponible de usar la computadora (por ejemplo, con sistema operativo MS-DOS de Windows).

Saber usar la consola es muy útil para automatizar actividades, realizar tareas administrativas, manipular varios archivos u objetos en simultáneo, lanzar a correr proyectos grandes, conectarse de manera remota a un servidor, etc. La primera vez que uno se mete en esto puede ser intimidante, pero no hay que olvidar que ya estamos acostumbrados a usar la consola de R, con lo cual esto de escribir comandos e interpretar respuestas es algo familiar.

Los términos \emph{terminal}, \emph{consola}, \emph{shell} y \emph{línea de comandos} son términos que a veces se usan como sinónimos sin demasiada preocupación, como si fuesen distintas formas de llamar a lo mismo: una ventanita donde puedo escribir comandos y hacer que sucedan cosas en la computadora. Sin embargo, hay pequeñas diferencias entre estos conceptos, que acá tratamos de resumir (aunque ni siquiera entre informáticos hay mucho acuerdo en las definiciones):

\begin{itemize}
\tightlist
\item
  \textbf{Shell} (intérprete de línea de comandos): es software, es un programa que corre otros programas, procesa los comandos que recibe y devuelve resultados Ejemplo: Bash (la más común en sistemas Linux), sh, PowerShell, etc.
\item
  \textbf{Terminal}: un programa que propicia la transferencia de input/output entre el usuario y la shell. No ejecuta comandos, pero recibe los comandos que el shell va a procesar. Ejemplos: Command prompt, guake, gnome-terminal, etc. Antiguamente, se trataba de las múltiples estaciones con un monitor y un teclado que una gran computadora tenía para ser usada por varias personas.
\item
  \textbf{Consola}: un tipo particular de terminal, con una ventana escribir inputs y leer outputs. Históricamente, se trataba de un panel físico (consola) con controles. Siri o Cortana podrían considerarse terminales, pero no son consolas, ya que no hay que escribir para mandar comandos. Terminal y consola se usan prácticamente como sinónimos.
\end{itemize}

Para abrir una terminal en Linux se puede usar el atajo \texttt{ctrl\ +\ alt\ +\ t} y en Windows se puede escribir \texttt{cmd} en Inicio.

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/07_otros/terminal} 

}

\caption{Abrir la terminal en Windows. En computadoras con Windows en español, en lugar de Command Prompt dice Símbolo del sistema.}\label{fig:unnamed-chunk-279}
\end{figure}

Así luce la línea de comandos de Windows:

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/07_otros/terminal2} 

}

\caption{Línea de comandos de Windows.}\label{fig:unnamed-chunk-280}
\end{figure}

Los comandos se escriben en la última línea a continuación del símbolo \texttt{\textgreater{}}, que a su vez está precedido por la ruta a la carpeta que es el directorio de trabajo actual de la terminal, en este caso, \texttt{C:\textbackslash{}Users\textbackslash{}Marcos} (carpeta \texttt{Marcos}, dentro de la carpeta \texttt{Users}, en el disco \texttt{C}).

Si bien hay muchísimos comandos para utilizar en la terminal, acá vamos a mencionar algunos como ejemplo:

\begin{itemize}
\tightlist
\item
  Mostrar en qué carpeta (directorio) de la compu estamos situados: \emph{pwd} en Linux o \emph{cd} en Windows
\item
  Listar todos los archivos y carpetas que tenemos en el directorio actual: \emph{ls} en Linux o \emph{dir} en Windows
\item
  Entrar a una subcarpeta desde el directorio en el que estamos: \emph{cd nombresubcarpeta}
\item
  Ver la ayuda de los comandos: \emph{help}
\item
  Limpiar la consola: \emph{cls} en Windows o \emph{clear} en Linux
\item
  Cerrar la consola: \emph{exit}
\end{itemize}

Por ejemplo, podemos ver todos los archivos que existen en el directorio actual con \texttt{ls}:

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/07_otros/terminal3} 

}

\caption{Contenido del directorio actual (Windows).}\label{fig:unnamed-chunk-281}
\end{figure}

Para los siguientes ejemplos, trabajaremos en una carpeta llamada \texttt{Ejemplos}, cuyo \emph{path} es \texttt{C:\textbackslash{}Users\textbackslash{}Marcos\textbackslash{}Trabajo\textbackslash{}Ejemplos} que tiene la siguiente composición:

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/07_otros/terminal4} 

}

\caption{Carpeta en la cual deseamos trabajar.}\label{fig:unnamed-chunk-282}
\end{figure}

Podemos convertir a dicha carpeta como nuestro nuevo directorio de trabajo con el comando \texttt{cd} (\emph{change directory}):

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/07_otros/terminal5} 

}

\caption{Cambio de directorio de trabajo y listado de archivos en el mismo.}\label{fig:unnamed-chunk-283}
\end{figure}

En Windows hay una forma más directa de abrir la terminal y que ya tenga seteada como directorio de trabajo a una carpeta deseada. Antes de abrir la terminal, vamos con el \emph{Explorador de archivos} a la carpeta en cuestión, nos posicionamos en la barra del explorador, escribimos \texttt{cmd} y le damos \texttt{ENTER}. Automáticamente se abrirá la terminal, con esta carpeta como directorio de referencia.

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/07_otros/terminal6} 

}

\caption{Abrir la terminal desde una carpeta en particular en Windows.}\label{fig:unnamed-chunk-284}
\end{figure}

Desde la terminal podemos correr nuestros programas de R. Hacer esto es necesario cuando tenemos que programar alguna tarea de gran escala que se ejecutará de manera remota en algún servidor o cuando necesitamos encapsular nuestro programa para que otros lo puedan correr sin siquiera saber nada de R.

Veamos un ejemplo. En la carpeta \texttt{C:\textbackslash{}Users\textbackslash{}Marcos\textbackslash{}Trabajo\textbackslash{}Ejemplos} tengo guardado el siguiente script, en un archivo llamado \texttt{mi\_programa.R} que tiene este contenido:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \StringTok{"¡Hola, Mundo!"}
\NormalTok{b }\OtherTok{\textless{}{-}} \DecValTok{3}
\NormalTok{d }\OtherTok{\textless{}{-}} \DecValTok{5}
\FunctionTok{cat}\NormalTok{(}\StringTok{"==========================================}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"                 RESULTADOS               }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"==========================================}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"El valor de b es "}\NormalTok{, b, }\StringTok{", mientras que d vale "}\NormalTok{, d, }\StringTok{".}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{, }\AttributeTok{sep =} \StringTok{""}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"La suma entre ellos es igual a "}\NormalTok{, b }\SpecialCharTok{+}\NormalTok{ d, }\StringTok{".}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{, }\AttributeTok{sep =} \StringTok{""}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"Este es un saludo:"}\NormalTok{, a)}
\end{Highlighting}
\end{Shaded}

Para ejecutar este programa desde la terminal, sin abrir RStudio o R, utilizo el comando \texttt{Rscript}, que le indica a la computadora que el contenido del archivo \texttt{mi\_programa.R} debe ser evaluado por R. Esto es lo que se observa en la consola:

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/07_otros/terminal7} 

}

\caption{Correr el programa de R desde la consola en Windows.}\label{fig:unnamed-chunk-286}
\end{figure}

Todo lo que en el programa estaba encerrado en una llamada a la función \texttt{cat()} es lo que se muestra como mensajes en la terminal. Notar que la instrucción \texttt{RScript\ mi\_programa.R} funcione, debemos tener como directorio de trabajo aquella carpeta que aloja al archivo \texttt{mi\_programa.R}, en caso contrario el sistema nos alertará que el mismo no está disponible.

Para que lo anterior funcione en Windows, hay que indicarle al sistema operativo que \texttt{Rscript} es un comando que se instaló con R y que lo puede encontrar en la carpeta de los archivos del programa R. Esto hay que hacerlo una sola vez editando las \textbf{variables de entorno} de Windows, que son cadenas de texto que contienen información acerca del sistema para determinar, por ejemplo, dónde buscar algunos archivos. Esto se logra siguiendo estos pasos:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Fijarse en qué carpeta de la compu está instalado R. Seguramente lo encuentres si, abriendo el explorador de archivo, vas siguiendo este camino: \texttt{Este\ equipo\ \textgreater{}\ Windows\ (C:)\ \textgreater{}\ Archivos\ de\ programa\ \textgreater{}\ R\ \textgreater{}\ R-version\ \textgreater{}\ bin}. En esta carpeta tiene que haber dos archivos, llamados \texttt{R.exe} y \texttt{Rscript.exe}. Si es así, hacé clic con el botón derecho del mouse sobre cualquiera de ellos, luego en ``Propiedades'' y copiá el path que aparece en ``Ubicación'' (deberías copiar algo como \texttt{C:\textbackslash{}Program\ Files\textbackslash{}R\textbackslash{}R-3.6.0\textbackslash{}bin}).
\item
  En Inicio, escribir ``Entorno'' y hacer clic en la opción ``Editar las variables de entorno del sistema (panel de control)''.
\item
  Hacer clic en el botón ``Variables de entorno''.
\item
  En el cuadro ``Variables del sistema'', hacer clic en la variable ``Path'' y luego en ``Editar''.
\item
  Hacer clic en ``Nuevo'', pegar la dirección \texttt{C:\textbackslash{}Program\ Files\textbackslash{}R\textbackslash{}R-3.6.0\textbackslash{}bin} y dar Enter. Luego, hacer clic en ``Aceptar'' tres veces para cerrar todo.
\item
  ¡Listo! Ya podés correr tus programas desde la consola con el comando \emph{Rscript}.
\end{enumerate}

Lo bueno de esto es que si corremos nuestros programas desde la terminal, podemos hacer cosas interactivas. Por ejemplo, para todo lo que pusimos \texttt{LEER} en nuestros pseudocódigos, ahora podemos hacer verdaderamente que la persona usuaria del programa provea los valores correspondientes.

Veamos algunos ejemplos.

\textbf{Práctica 2, Ejercicio 1: paridad de un número}

La función \texttt{scan()} es la que permite \emph{escanear} o \emph{leer} valores que los usuarios ingresen por la terminal. Entre sus argumentos tenemos a \texttt{file}, que si lo seteamos como \texttt{file\ =\ "stdin"} indica que vamos a leer información desde la consola. Otros argumentos que son de utilidad incluyen a \texttt{n\ =\ 1}, que indica que sólo leeremos un valor y \texttt{quiet\ =\ TRUE} que le pide a esta función que no emita ningún mensaje. Por ejemplo, si el siguiente código se guarda en el archivo \texttt{paridad.R} y es ejecutado desde la consola, le va a pedir a la persona que lo esté usando que indique cualquier número y luego le va a comunicar si es par o impar:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cat}\NormalTok{(}\StringTok{"==========================================}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"           PARIDAD DE UN NÚMERO           }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"==========================================}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"Ingrese un número entero y presione enter:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{n }\OtherTok{\textless{}{-}} \FunctionTok{scan}\NormalTok{(}\AttributeTok{file =} \StringTok{"stdin"}\NormalTok{, }\AttributeTok{n =} \DecValTok{1}\NormalTok{, }\AttributeTok{quiet =} \ConstantTok{TRUE}\NormalTok{)}
\ControlFlowTok{if}\NormalTok{ (n }\SpecialCharTok{\%\%} \DecValTok{2} \SpecialCharTok{==} \DecValTok{0}\NormalTok{) \{}
    \FunctionTok{cat}\NormalTok{(n, }\StringTok{"es par}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
    \FunctionTok{cat}\NormalTok{(n, }\StringTok{"es impar}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Esto es lo que ocurre en la terminal:

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/07_otros/terminal8} 

}

\caption{Programa paridad.R.}\label{fig:unnamed-chunk-288}
\end{figure}

\textbf{Práctica 2, Ejercicio 3: salario}

En este ejemplo, tenemos que leer tres valores, dos de lo cuales son de tipo carácter. Para esto tenemos que agregar en la función \texttt{scan()} el argumento \texttt{what\ =\ ""}, que admite el ingreso de caracteres alfanuméricos (por default \texttt{scan()} sòlo espera recibir valores numéricos). Si el siguiente código se guarda en el archivo \texttt{salario.R} y se lo ejecuta desde la consola, produce el resultado que se muestra en la imagen:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cat}\NormalTok{(}\StringTok{"==========================================}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"           CÁLCULO DEL SALARIO            }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"==========================================}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"Ingrese la cantidad de horas trabajadas:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{horas }\OtherTok{\textless{}{-}} \FunctionTok{scan}\NormalTok{(}\StringTok{"stdin"}\NormalTok{, }\AttributeTok{n =} \DecValTok{1}\NormalTok{, }\AttributeTok{quiet =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Ingrese el día de la semana (DOM LUN MAR MIE JUE VIE SAB):}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{dia }\OtherTok{\textless{}{-}} \FunctionTok{scan}\NormalTok{(}\StringTok{"stdin"}\NormalTok{, }\AttributeTok{what =} \StringTok{""}\NormalTok{, }\AttributeTok{n =} \DecValTok{1}\NormalTok{, }\AttributeTok{quiet =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Ingrese el turno (M T N):}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{turno }\OtherTok{\textless{}{-}} \FunctionTok{scan}\NormalTok{(}\StringTok{"stdin"}\NormalTok{, }\AttributeTok{what =} \StringTok{""}\NormalTok{, }\AttributeTok{n =} \DecValTok{1}\NormalTok{, }\AttributeTok{quiet =} \ConstantTok{TRUE}\NormalTok{)}

\NormalTok{salario }\OtherTok{\textless{}{-}}\NormalTok{ horas }\SpecialCharTok{*} \DecValTok{400}
\ControlFlowTok{if}\NormalTok{ (turno }\SpecialCharTok{==} \StringTok{"N"}\NormalTok{) \{}
\NormalTok{    salario }\OtherTok{\textless{}{-}}\NormalTok{ salario }\SpecialCharTok{+}\NormalTok{ horas }\SpecialCharTok{*} \DecValTok{200}
\NormalTok{\}}
\ControlFlowTok{if}\NormalTok{ (turno }\SpecialCharTok{==} \StringTok{"DOM"}\NormalTok{) \{}
\NormalTok{    salario }\OtherTok{\textless{}{-}}\NormalTok{ salario }\SpecialCharTok{+}\NormalTok{ horas }\SpecialCharTok{*} \DecValTok{100}
\NormalTok{\}}
\FunctionTok{cat}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{El salario que se debe abonar es $"}\NormalTok{, salario, }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\AttributeTok{sep =} \StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/07_otros/terminal9} 

}

\caption{Programa salario.R.}\label{fig:unnamed-chunk-290}
\end{figure}

\textbf{Práctica 4, Ejercicio 1: suma de elementos de un vector}\footnote{Si estás leyendo esto antes de que hayamos visto en clase la Unidad 5, podés omitir este último ejemplo y retomarlo más adelante en el cursado.}

En este ejercicio escribimos una función para sumar los elementos de un vector. Vamos a ver cómo hacer para que un usuario nos diga cuáles son los valores que quiere sumar desde la consola. Primero preguntamos cuántos números se desean sumar y luego los recibimos en el vector \texttt{v}. Si el siguiente código queda guardado en el archivo \texttt{suma.R} y se lo corre desde la terminal, produce el resultado que se muestra en la imagen.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cat}\NormalTok{(}\StringTok{"==========================================}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"              SUMA DE NÚMEROS             }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"==========================================}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"¿Cuántos números va a ingresar?}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{n }\OtherTok{\textless{}{-}} \FunctionTok{scan}\NormalTok{(}\StringTok{"stdin"}\NormalTok{, }\AttributeTok{n =} \DecValTok{1}\NormalTok{, }\AttributeTok{quiet =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Ingrese los números, presionando Enter luego de cada uno:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{v }\OtherTok{\textless{}{-}} \FunctionTok{scan}\NormalTok{(}\StringTok{"stdin"}\NormalTok{, }\AttributeTok{n =}\NormalTok{ n, }\AttributeTok{quiet =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{suma }\OtherTok{\textless{}{-}} \DecValTok{0}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{length}\NormalTok{(v)) \{}
\NormalTok{    suma }\OtherTok{\textless{}{-}}\NormalTok{ suma }\SpecialCharTok{+}\NormalTok{ v[i]}
\NormalTok{\}}
\FunctionTok{cat}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{La suma de los números es:"}\NormalTok{, suma, }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{images/07_otros/terminal10} 

}

\caption{Programa suma.R.}\label{fig:unnamed-chunk-292}
\end{figure}

\hypertarget{uso-de-argumentos-en-la-luxednea-de-comandos-al-ejecutar-cuxf3digo-de-r}{%
\section{Uso de argumentos en la línea de comandos al ejecutar código de R}\label{uso-de-argumentos-en-la-luxednea-de-comandos-al-ejecutar-cuxf3digo-de-r}}

En ejemplos anteriores hemos visto cómo capturar distintas piezas de información de forma interactiva mediante la función \texttt{scan()} mientras estamos ejecutando un programa de R desde la línea de comandos.

En otras ocasiones, en lugar de pausar la ejecución del programa a la espera de que el usuario ingrese algún valor, es conveniente especificar algunas opciones directamente en la instrucción \texttt{Rscript} que ejecuta el código.

Por ejemplo, imaginemos que tenemos un programa llamado \texttt{resumen.R} que se encarga de hacer un análisis descriptivo de un conjunto de datos que están guardados en un archivo de texto de nombre \texttt{02\_05\_22.txt}. Al ejecutar este programa desde la terminal, podemos indicar el nombre del archivo como un argumento adicional de esta forma:

\begin{verbatim}
Rscript resumen.R 02_05_22.txt
\end{verbatim}

Ahora supongamos que este mismo tipo de análisis se repite todos los días con datos nuevos. En lugar de modificar nuestro script \texttt{resumen.R}, ejecutamos lo anterior con el nombre del archivo que corresponda y listo:

\begin{verbatim}
Rscript resumen.R 03_05_22.txt
Rscript resumen.R 04_05_22.txt
Rscript resumen.R 05_05_22.txt
\end{verbatim}

Para que esto funcione, el programa que está guardado en \texttt{resumen.R} debe ser capaz de capturar el nombre del archivo que tiene leer y que el usuario se lo está pasando como un argumento adicional en la instrucción \texttt{Rscript}.

La función que se encarga de capturar los argumentos adicionales que enviamos desde la terminal es \texttt{commandArgs()}. Toma todos los elementos que escribamos y los reúne en un vector de tipo carácter. Por ejemplo, el archivo \texttt{ejemplo1.R} tiene el siguiente contenido:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Capturar los argumentos pasados desde la terminal en un vector}
\NormalTok{args }\OtherTok{\textless{}{-}} \FunctionTok{commandArgs}\NormalTok{(}\AttributeTok{trailingOnly =} \ConstantTok{TRUE}\NormalTok{)}

\CommentTok{\# Contar cuántos argumentos nos pasaron}
\FunctionTok{cat}\NormalTok{(}\StringTok{"Nos pasaron"}\NormalTok{, }\FunctionTok{length}\NormalTok{(args), }\StringTok{"argumentos.}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Mostrar los argumentos que nos pasaron}
\FunctionTok{cat}\NormalTok{(}\StringTok{"Los argumentos que nos pasaron son:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\FunctionTok{cat}\NormalTok{(args, }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Aunque los argumentos sean números, son tomados como carácter}
\FunctionTok{cat}\NormalTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Los argumentos se toman como valores de tipo:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\FunctionTok{class}\NormalTok{(args)}
\end{Highlighting}
\end{Shaded}

Al ejecutarlo desde la línea de comandos con los argumentos ``hola'', ``chau'' y ``4'' obtenemos:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Rscript}\NormalTok{ ejemplo1.R hola chau 4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Nos pasaron 3 argumentos.

Los argumentos que nos pasaron son:
hola chau 4 

Los argumentos se toman como valores de tipo:
[1] "character"
\end{verbatim}

Si lo ejecutamos sin argumentos:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Rscript}\NormalTok{ ejemplo1.R}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Nos pasaron 0 argumentos.

Los argumentos que nos pasaron son:
 

Los argumentos se toman como valores de tipo:
[1] "character"
\end{verbatim}

Ahora vamos a suponer que el programa \texttt{ejemplo2.R} tiene como objetivo contar un chiste o decir un refrán, según lo que se le pida en el único argumento que se le pasa al correrlo desde la terminal. Si el argumento es igual ``chiste'', se cuenta el chiste; si es igual a ``refran'' se cuenta el refrán; y en otro caso no se hace nada. El contenido del archivo es:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Capturar los argumentos pasados desde la terminal en un vector}
\NormalTok{args }\OtherTok{\textless{}{-}} \FunctionTok{commandArgs}\NormalTok{(}\AttributeTok{trailingOnly =} \ConstantTok{TRUE}\NormalTok{)}

\ControlFlowTok{if}\NormalTok{ (args[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==} \StringTok{"chiste"}\NormalTok{) \{}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"{-} Juan, cómo has cambiado.}\SpecialCharTok{\textbackslash{}n}\StringTok{{-} Yo no soy Juan.}\SpecialCharTok{\textbackslash{}n}\StringTok{{-} Más a mi favor.}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (args[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==} \StringTok{"refran"}\NormalTok{) \{}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"No por mucho madrugar amanece más temprano.}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
    \CommentTok{\# Genero un error para que el programa se detenga, avisando lo que pasa}
    \FunctionTok{stop}\NormalTok{(}\StringTok{"El argumento provisto debe ser igual a chiste o refran.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Ejecutamos este archivo pasando distintos valores para su argumento:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Rscript}\NormalTok{ ejemplo2.R refran}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
No por mucho madrugar amanece más temprano.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Rscript}\NormalTok{ ejemplo2.R chiste}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
- Juan, cómo has cambiado.
- Yo no soy Juan.
- Más a mi favor.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Rscript}\NormalTok{ ejemplo2.R hola}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error: El argumento provisto debe ser igual a chiste o refran.
Execution halted
\end{verbatim}

Podemos controlar la cantidad de argumentos admitidos generando errores en el código para aquellas situaciones donde el usuario envíe menos o más que la cantidad deseada. Por ejemplo, en el caso anterior, es obligatorio enviar uno y sólo un argumento:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Capturar los argumentos pasados desde la terminal en un vector}
\NormalTok{args }\OtherTok{\textless{}{-}} \FunctionTok{commandArgs}\NormalTok{(}\AttributeTok{trailingOnly =} \ConstantTok{TRUE}\NormalTok{)}

\CommentTok{\# Controlar la cantidad de argumentos}
\ControlFlowTok{if}\NormalTok{ (}\FunctionTok{length}\NormalTok{(args) }\SpecialCharTok{==} \DecValTok{0} \SpecialCharTok{||} \FunctionTok{length}\NormalTok{(args) }\SpecialCharTok{\textgreater{}} \DecValTok{1}\NormalTok{) \{}
    \FunctionTok{stop}\NormalTok{(}\StringTok{"Debe proveer exactamente un argumento, que debe ser igual a chiste o refran.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{\}}

\ControlFlowTok{if}\NormalTok{ (args[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==} \StringTok{"chiste"}\NormalTok{) \{}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"{-} Juan, cómo has cambiado.}\SpecialCharTok{\textbackslash{}n}\StringTok{{-} Yo no soy Juan.}\SpecialCharTok{\textbackslash{}n}\StringTok{{-} Más a mi favor.}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (args[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==} \StringTok{"refran"}\NormalTok{) \{}
    \FunctionTok{cat}\NormalTok{(}\StringTok{"No por mucho madrugar amanece más temprano.}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
    \CommentTok{\# Genero un error para que el programa se detenga, avisando lo que pasa}
    \FunctionTok{stop}\NormalTok{(}\StringTok{"El argumento provisto debe ser igual a chiste o refran.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Veamos lo que pasa si cumplimos o no con la cantidad exacta de argumentos que hay que pasarle al código de R:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Rscript}\NormalTok{ ejemplo3.R}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error: Debe proveer exactamente un argumento, que debe ser igual a chiste o refran.
Execution halted
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Rscript}\NormalTok{ ejemplo3.R chiste refran}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error: Debe proveer exactamente un argumento, que debe ser igual a chiste o refran.
Execution halted
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Rscript}\NormalTok{ ejemplo3.R chiste}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
- Juan, cómo has cambiado.
- Yo no soy Juan.
- Más a mi favor.
\end{verbatim}

Imaginemos por último que es obligatorio pasar un primer argumento (``chiste'' o ``refran'') y que opcionalmente se puede pasar un segundo argumento, que se va a tratar de un número para indicar cuántas veces queremos que el chiste o el refrán se repita. Como todos los argumentos se pasan como datos de tipo carácter, para poder usar el número tendremos que convertirlo a dato de tipo numérico.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Capturar los argumentos pasados desde la terminal en un vector}
\NormalTok{args }\OtherTok{\textless{}{-}} \FunctionTok{commandArgs}\NormalTok{(}\AttributeTok{trailingOnly =} \ConstantTok{TRUE}\NormalTok{)}

\CommentTok{\# Si no proveyó argumentos, generar un error y que se detenga el programa}
\ControlFlowTok{if}\NormalTok{ (}\FunctionTok{length}\NormalTok{(args) }\SpecialCharTok{==} \DecValTok{0}\NormalTok{) \{}
    \FunctionTok{stop}\NormalTok{(}\StringTok{"Debe proveer al menos un argumento (chiste o refran)."}\NormalTok{)}
\NormalTok{\}}

\CommentTok{\# Si proveyó más de 2 argumentos, generar un error y que se detenga el programa}
\ControlFlowTok{if}\NormalTok{ (}\FunctionTok{length}\NormalTok{(args) }\SpecialCharTok{\textgreater{}} \DecValTok{2}\NormalTok{) \{}
    \FunctionTok{stop}\NormalTok{(}\StringTok{"No debe proveer más de 2 argumentos. El primero es obligatorio (chiste o refran) y el segundo es opcional (un número que indica la cantidad de veces a repetir el chiste o el refrán)."}\NormalTok{)}
\NormalTok{\}}

\CommentTok{\# Si no hay segundo argumento, args[2] es NA}
\ControlFlowTok{if}\NormalTok{ (}\FunctionTok{is.na}\NormalTok{(args[}\DecValTok{2}\NormalTok{])) \{}
\NormalTok{    n }\OtherTok{\textless{}{-}} \DecValTok{1}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    n }\OtherTok{\textless{}{-}} \FunctionTok{as.numeric}\NormalTok{(args[}\DecValTok{2}\NormalTok{])}
\NormalTok{\}}

\CommentTok{\# Repetir n veces}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\NormalTok{n) \{}
    \ControlFlowTok{if}\NormalTok{ (args[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==} \StringTok{"chiste"}\NormalTok{) \{}
        \FunctionTok{cat}\NormalTok{(}\StringTok{"{-} Juan, cómo has cambiado.}\SpecialCharTok{\textbackslash{}n}\StringTok{{-} Yo no soy Juan.}\SpecialCharTok{\textbackslash{}n}\StringTok{{-} Más a mi favor.}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (args[}\DecValTok{1}\NormalTok{] }\SpecialCharTok{==} \StringTok{"refran"}\NormalTok{) \{}
        \FunctionTok{cat}\NormalTok{(}\StringTok{"No por mucho madrugar amanece más temprano.}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \CommentTok{\# Genero un error para que el programa se detenga, avisando lo que pasa}
        \FunctionTok{stop}\NormalTok{(}\StringTok{"El argumento provisto debe ser igual a chiste o refran.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Veamos ahora cómo funciona:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Rscript}\NormalTok{ ejemplo4.R refran 5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
No por mucho madrugar amanece más temprano.

No por mucho madrugar amanece más temprano.

No por mucho madrugar amanece más temprano.

No por mucho madrugar amanece más temprano.

No por mucho madrugar amanece más temprano.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Rscript}\NormalTok{ ejemplo4.R chiste 3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
- Juan, cómo has cambiado.
- Yo no soy Juan.
- Más a mi favor.

- Juan, cómo has cambiado.
- Yo no soy Juan.
- Más a mi favor.

- Juan, cómo has cambiado.
- Yo no soy Juan.
- Más a mi favor.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Rscript}\NormalTok{ ejemplo4.R refran}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
No por mucho madrugar amanece más temprano.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Rscript}\NormalTok{ ejemplo4.R}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error: Debe proveer al menos un argumento (chiste o refran).
Execution halted
\end{verbatim}

Si querés probar estos ejemplos, podés crear los archivos de código mencionados copiando y pegando las instrucciones o descargarlos de \href{https://github.com/mpru/introprog/tree/master/archivos}{este enlace}.

Además de la función \texttt{commandArgs()} existen paquetes de R para poder trabajar con argumentos y opciones de formas mucho más elaboradas, como los paquetes \texttt{argparse} y \texttt{optparse}, entre otros.

\hypertarget{bibliografuxeda}{%
\chapter*{Bibliografía}\label{bibliografuxeda}}
\addcontentsline{toc}{chapter}{Bibliografía}

\textbf{Bibliografía de la asignatura}

\begin{itemize}
\tightlist
\item
  Casale, Juan Carlos (2012). \emph{Introducción a la Programación}. Buenos Aires: Editorial Fox Andina.
\item
  Cerrada Somolinos, José y Collado Machuca, Manuel (2015). \emph{Fundamentos De Programación}. Madrid: Editorial Universitaria Ramón Areces.
\item
  Martínez López, Pablo (2013). \emph{Las bases conceptuales de la Programación: una nueva forma de aprender a programar}. La Plata: Editorial de la Universidad Nacional de Quilmes.
\item
  Quetglás, Gregorio; Toledo Lobo, Francisco; Cerverón Lleó, Vicente (1995). \emph{Fundamentos de informática y programación}. Valencia: Editorial V.J.
\item
  Wicham, Hadley (2019). \emph{Advanced R}. Florida: Editorial Chapman and Hall/CRC.
\end{itemize}

\textbf{Textos consultados para la reseña histórica de la programación}:

\begin{itemize}
\tightlist
\item
  \href{https://es.wikipedia.org/wiki/Ada_Lovelace}{\emph{Ada Lovelace - Wikipedia}}. Consultado el 21/04/21.
\item
  \href{https://en.wikipedia.org/wiki/Difference_engine}{\emph{Difference engine - Wikipedia}}. Consultado el 21/04/21.
\item
  \href{https://www.nextu.com/blog/generaciones-de-las-computadoras/}{\emph{Generaciones de las computadoras}}. Consultado el 21/04/21.
\item
  \href{https://www.profesionalreview.com/2018/10/13/generaciones-de-ordenadores/}{\emph{Generaciones de ordenadores}}. Consultado el 21/04/21.
\item
  \href{https://es.wikipedia.org/wiki/Anexo:Historia_de_la_computaci\%C3\%B3n}{\emph{Historia de la programación - Wikipedia}}. Consultado el 21/04/21.
\item
  \href{https://people.idsia.ch/~juergen/zuse.html}{\emph{Konrad Zuse - people.idsia.ch}}. Consultado el 21/04/21.
\item
  \href{https://culturacientifica.com/2016/10/05/los-huesos-napier-la-multiplicacion-arabe/\#:~:text=Los\%20huesos\%20de\%20Napier\%2C\%20tambi\%C3\%A9n,de\%20las\%20tablas\%20de\%20multiplicar}{\emph{Los huesos de Napier, la multiplicación árabe y tú}}. Consultado el 21/04/21.
\item
  \href{https://www.significados.com/computacion/}{\emph{Significado de computación}}. Consultado el 21/04/21.
\end{itemize}

\textbf{Otros artículos consultados}

\begin{itemize}
\tightlist
\item
  \href{https://www.aprenderprogramacion.com.ar/2020/03/1-breve-historia-de-la-programacion.html}{\emph{Aprender programación - Curso de Java}}. Consultado el 25/04/21.
\item
  \href{http://www.utn.edu.ec/reduca/programacion/fundamentos/fundamentos_de_programacin.html}{\emph{Fundamentos de programación}}. Consultado el 25/04/21.
\item
  \href{https://www.profesionalreview.com/2019/11/10/hardware-software-definiciones/}{\emph{Hardware y software: definiciones y conceptos}}. Consultado el 25/04/21.
\item
  \href{https://www.bbc.co.uk/bitesize/guides/zts8d2p/revision/1}{\emph{Introduction to programming}}. Consultado el 25/04/21.
\item
  \href{http://www1.frm.utn.edu.ar/informatica1/VIANI/PROGRAMACION\%20ESTRUCTURADA/PROGRAMACION\%20ESTRUCTURADA.PDF}{\emph{Programación estructurada}}. Consultado el 25/04/21.
\item
  \href{https://textexpander.com/blog/the-7-most-common-types-of-errors-in-programming-and-how-to-avoid-them}{\emph{The 7 Most Common Types of Errors in Programming and How to Avoid Them}}. Consultado el 25/04/21.
\item
  \href{https://levelup.gitconnected.com/what-is-abstraction-in-programming-2f35c8c72e15}{\emph{What is abstraction in programming?}}. Consultado el 25/04/21.
\end{itemize}

\end{document}
